<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[胶卷与纸媒]]></title>
    <url>%2F2018%2F03%2F15%2F%E8%83%B6%E5%8D%B7%E4%B8%8E%E7%BA%B8%E5%AA%92%2F</url>
    <content type="text"><![CDATA[胶卷界最近有些事情要发生：很好用的Agfa Vista 400/200都要停产了。这两款Fuji代工的胶卷传出停产的消息我一点也不奇怪，因为Fuji每年按照惯例都会停产几款卖得挺火的胶卷。2017说是胶卷复兴元年，Kodak复产了Ektarchrome E100，还有一大票黑白卷冒了出来，可是Fuji逆势而行却停产了Natura 1600和provia 400x。大势所趋是没办法，这个世界永远都是利益驱动而不是情怀。胶卷确实已经是过时的产物，大概再往后就没有玩胶卷的人了，我们大概是最后一代玩胶卷的孩子了。 前阵子在微信公众号里面发现《大众软件》还活着，遂好奇在网上搜索了一下这个十多年前很风光的游戏杂志的现状。《大众软件》在16年停刊之后曾经出过一次众筹，说要“让每个人都有一本大软”，但是最后众筹做出来的效果确实不如人意。 胶卷和纸媒这两样在以前看似没有关联的东西，在如今已经被冠以“过时”的称呼。胶卷大概在千禧年前后最为火热，之后就一直走下坡路了。而纸媒，我记得小学初中的时候经常买的杂志《数码时代》、《大众软件》、《电脑迷》等，早已经在几年前没有踪影了。看来这两样东西已经被时代远远抛在后头了。 Kodak发明了数码相机，最后自己却被数码相机干死；《数码时代》杂志整天讲数码产品，最后自己被互联网干死。这个虚拟的数字时代到来之后，一切都便利了很多：我不用花钱买胶卷，花时间等洗胶卷；我不用花钱买一个月才出一期的杂志。但是我总觉得我不属于这个数码时代，我可是一个有情怀的人。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>胶卷</tag>
        <tag>纸媒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于三年来摄影之路的思考]]></title>
    <url>%2F2017%2F10%2F08%2F%E5%85%B3%E4%BA%8E%E4%B8%89%E5%B9%B4%E6%9D%A5%E6%91%84%E5%BD%B1%E4%B9%8B%E8%B7%AF%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[三年前的九月，我用自己的零花钱买了人生中第一台相机——索尼 nex-6。三年之后，回望着三年来的摄影之路感慨良多，总结下来，这三年来的我对摄影的看法可以分为三个阶段。 第一阶段：胡乱拍这是我刚买相机的阶段，那时候因为没钱，所以只给配了一个国产的大光圈镜头。即使这样，也算体验了做一个“虚化狗”的感觉。在这个阶段我什么都拍，可能看到一个消防喉都觉得很有趣要想着去虚化一下。烂片率高，但也因为拍得多，所以也有一些出片。 第二阶段：珍惜每一次快门这个阶段应该是买相机的第二年，我记得第二年一年我仅仅拍了3000张照片。在这一阶段里面，我心里一直有一个观念既是“想好了再拍”。所以我很经常举起相机通过取景器去思考这样拍下的照片是否好看，如果发现不完美，我就放弃拍摄。 第三阶段：胡乱拍话说进入第三阶段，这是我也不能想象的。到了第二阶段的末期，我开始接触胶片，从此我更加珍惜每一次快门。但是我压根没想到我还会进入到第三阶段。缘起于我一次夜晚的街拍。在那次的街拍中，我竭尽所能地耗尽我的快门，甚至对着同一个对象连拍三四张，这是我以前压根不敢想象的。我盲拍，我还没对上焦就拍，我边走边拍从不停下，我把ISO调到3200。我不会像以前那样，想好光圈快门构图再去拍，我也不会放大去对焦直到完全对上才拍。我直接把ISO设置在3200，不再去管这样会有多大的噪点；我更不会在意什么焦点清晰，焦外奶化。我看见了，我拍了，我管他妈的。 下面放一些那晚拍的照片。]]></content>
      <categories>
        <category>Photograph</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读aiosplite源码笔记]]></title>
    <url>%2F2017%2F09%2F28%2F%E9%98%85%E8%AF%BBaiosplite%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在GIthub是看到这样一个aiospilte的库，具体是将sqlite改成异步的。发现源码体积挺小的，遂看一下，看完后发现作者脑路新奇。作者主要使用了代理模式，代理了Connection和Cursor这两个sqlite3的类。但是作者新奇就在于，其实这是一个披着异步外衣的多线程。作者对于每一个连接都新建一个独立线程。仅仅使用异步作为询问，而实际费IO的操作是在独立的线程中。 作者的Connection类继承自threading.Thread。 使用Python的上下文管理器： 12345678async def __aenter__(self) -&gt; 'Connection': self.start() await self._connect() return selfasync def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None: await self.close() self._conn = None 可见，每开一个连接，就创建一个新的独立的线程。对于每个独立的线程，执行run()方法，self._tx是Queue，放置着包装好的待执行的函数。可见，所有的实际操作fn()是阻塞的。 12345678910111213141516def run(self) -&gt; None: """Execute function calls on a separate thread.""" while self._running: try: fn = self._tx.get(timeout=0.1) except Empty: continue try: Log.debug('executing %s', fn) result = fn() Log.debug('returning %s', result) self._rx.put(result) except Exception as e: Log.exception('returning exception %s', e) self._rx.put(e) 而所谓的异步的_execute()，它仅仅作为询问用，它每隔一段时间看看结果队列self._rx是否有结果，有结果即返回。 12345678910111213141516171819202122async def _execute(self, fn, *args, **kwargs): """Queue a function with the given arguments for execution.""" await self._lock.acquire() pt = partial(fn, *args, **kwargs) self._tx.put_nowait(pt) while True: try: result = self._rx.get_nowait() break except Empty: await asyncio.sleep(0.1) continue self._lock.release() if isinstance(result, Exception): raise result return result 作者还在这里加了锁。作者这样做是为了防止结果的混乱。举个例子，如下代码，可能因为await asyncio.sleep(0.1)，而造成cursor2拿到的是table1的结果。值得注意的是，如果同一EventLoop里面有其他需要获得锁的协程，可能会导致Bug的出现。 123async with aiosqlite.connect(...) as db: cursor1 = await db.execute('SELECT * FROM table1') cursor2 = await db.execute('SELECT * FROM table2')]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪实摄影（1）]]></title>
    <url>%2F2017%2F09%2F24%2F%E7%BA%AA%E5%AE%9E%E6%91%84%E5%BD%B1%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[何为纪实摄影1910年，在布鲁塞尔举行的第五届国际摄影大会期间，有人为纪实摄影提出了一个中性的、有弹性的界定：“纪实摄影必须用作对各种各样问题的研究，因此，作为这方面的需要，纪实摄影要对所研究的主题尽可能地提供详尽的细节。任何照片都可以作为一个特别的瞬间用作研究。不存在可以被忽视的东西。美成了纪实摄影第二重要的因素，对图像所有的要求是要清晰、细节丰富，而且为了尽可能长时间地保存，要细心处理之。” “纪实”（Document）这个字来源于拉丁文Docere（教育），所以从根本上说，那种强调纪实摄影是单纯记录的说法，是不正确的。美国著名纪实摄影家亚瑟·罗特斯坦认为：“纪实这个词描述的是一种风格与一种方法。曾经有过许多别的建议——写实的（realistic）、事实的（factual）、史实的（historical）——但是无一能传达纪实传统对真相的深刻尊敬、以及对我们世界积极诠释的强烈欲望。” 时代一生活丛书《纪实摄影》中也写道；“镜头前而的景物是真实的，但摄影家能够运用他的照相机使景物表现出另一种真实、一种更深刻而且也忤是更重要的真实——他可以作出评论。如果说纪实摄影的笔一属性是它表现现实世界真相的能力，那么，它的第二属性就是传达摄影家评论这种真相的能力。” 纪实摄影家的多萝西娅·兰格(Dorothea Lange，1895一1965年）女士对纪实摄影的研究源于她丰富的实践经验和不断深人的思考。应纯粹派摄影大师安塞尔·亚当斯的请求，她为《摄影大观》一书撰写的“纪实摄影”词条这样写道：“纪实摄影记录我们这个时代的社会景象。它反映现在，但为将来作纪实。它的焦点是人与人的关系。它记录人们在工作中、战争中和娱乐中的行为身或在一天二十四小时中`四李中。甚至一年中周而复始的活动。它描写人类的客种制度，家庭、教堂、政府、政治组织、社会团体、工会。它不仅展现它们的表面形象，同时还刻意揭示人们的活动方式，接受生活的方式，表示虔诚的方式，以及影响人类行为的方式。它涉及工作方法、工作者之间的相互依赖，以及被雇者与雇佣者之间的相互依赖用它来做一本记录变化的小册子那真是太合适不过了。工艺的进步会提喬生活水准同时也会造成失业，改变城市面貌和农业她貌。这些趋势的证据一一过去、现在及未来预兆的同时存在一一：，明显地出现于旧的和新的各种形式之中，旧的和新的各种习俗之中，总之，出现于各个方．纪实摄影立足于自身的长处，并且靠自身便能产生效力榨单一的一张照片也许可以是新闻照片、肖像照片、艺术照片或纪实照片一．是其中的任何一种，是全部，或哪种也不是。在社会科学的工具一一一图表，数据、地图和文字中，照片纪实现正受到越来越多的重视。纪实摄影不仅需要专业工作者参加，而且还需要业余爱好者的参与，只有通过那些业余爱好者有趣的作品对主题的选择和跟踪，照相机对我们时代及我们复杂社会的纪实才能恰如其分地抓住本质，并产生广泛的影响。“ 休伯伦：“我认为纪实摄影就是表现人与他们生活的环境是如何联系在一起的。“ 锡德·罗格斯曼：“摄影家的作用在于帮助人们理解他们周围的世界。尽管我们今天拍的整箱的照片不会有人愿意购买，但我知道，总有一天他们会有用的，这就是我们的成功。” 西斯金德：“对我而言，纪实摄影意味着拍摄那些人们在欣赏时不会想到拍摄这是谁的照片。” 纪实摄影的作者可以是专业的，也可以是业余的，但他们对题材的反映都是全面而充分的，真实而朴实，摄影师的第一任务是记录，第二任务是评价——这种基于事实之上的评价可以体现在摄影师对题材的选择中，也可以蕴藏在对摄影技术手段的选择以及文字的叙述中。 1850-1880：萌芽期的纪实摄影在19世纪中叶，刚刚萌芽的纪实摄影实际上是以简单记录摄影的面目出现。“最广义地说，这些记录性的照片就是纪实摄影：摄影者认为它们是现实世界中最重要的得东西。” 如William Henry Fox Talbot拍的工人 David Octavius Hill与Robert Adamson拍摄的渔夫 早期的摄影家们常常跋山涉水或者远去他乡记录异国情调或美妙景色。但是按照摄影史学家迪罗凯尼格（Thilo Koenig）的说法，直到19世纪末叶，还没有影可以称作是真正意上的“社会的”摄影或“社会纪实摄影”。“纪实”更多意味着一种技术，而不是一种摄影类型或者摄影风格。摄影作为社会批判和社会调查的工具并没有被自觉地、广泛地使用。同时，由于受湿版、大镜箱、长时间曝光等技术因素的限制，早期纪实摄影大多是一些直接拍摄的、静态的、单纯的、表面化的图像，并且以自然光下的外景为多。照片既没有感情色彩，也少有个人判断。所以严格地说，这个阶段的纪实摄影．只能是纪实性的摄影。 我们把这一时期（1850-1880）的纪实摄影，看做是纪实摄影的启蒙时期。 香港的曾恩波先生认为，世界上第一张记录照片，是英国人理查·毕亚德（Richard Beard）拍摄的，这张已失传的照片为1851年梅休（Mayhew）编著的《伦敦劳工和伦敦贫民》用作插图。 被誉为“紳士摄影家”的英国人罗杰、芬顿（Roger Fenton）与詹拇斯·罗伯逊（James Robertson）于1855年拍摄的克里来亚战争，罗马尼亚布加勒斯特的业余摄影家帕普提斯特拍摄的巴尔干半島战争，都是最早记录战争的摄影。 1857年应伦敦《Illustrated Times》杂志和立体摄影公司的要求，罗伯特·豪利特（Robert Howlett）拍的“英国大东方号”汽船装配工程，这艘巨大的轮船能载客4000余人，规模空前。 1859年威廉，英格兰德（William England）拍摄的《尼亚加拉河上的吊桥》。1860年法国摄影家德尔梅特（Delmaet）和迪朗台尔（Durandelle）拍摄的巴黎歌剧院建设进展的照片。1878年亨利·比查德（Henri Bechard）拍摄的《攀登大金字塔》以及1880年无名氏拍摄的《建设中的布鲁克林大桥》、安德鲁·J·拉塞尔（Andrew J·Russall）1869年拍摄的《犹他州铁路合龙》等。 日常生活和异域风情方面有1846——1848年间阿尔伯特·桑德斯·索斯沃思（Albert Sands Southworth）和乔赛亚·约翰逊·霍斯（Josiah Johnson Hawes）拍摄的《马萨驻塞州综合医院手术室里的女病人》、1859年爱德华飞安东尼（Edward Anthony）拍摄的《组约的街景》、威廉·约翰逊1856年拍的《弹棉花的劳工》、卡尔洛·那亚（Carlo Naya）拍摄的《鱼篓上的孩子们，威尼斯，1870年代》等。 反映贫穷百姓生活的有尤金尼奥，蒙纽里（Eugenio Maunoury）的《三张肖像，1863》、玛丽·L·堪伯尼斯·邦费尔斯(Marie Lydie Cabannis Bonfils)的《阿拉伯族流浪妇女，1870年》、维拉比·威力克·胡帕尔（Willoughby Wallace Hooper)的《马德拉斯灾荒中最后的牧人，约1876一1878年》等。 自然事件类有乔治奥·萨默尔（Giorgio Sommer）1872年拍摄的《成苏威火山喷发》等。 苏格兰摄影家托马斯·安楠（Thomas Annan）1868年间拍摄的格拉斯哥即将拆除的老城、法国摄影家查尔斯·马维尔（Charles Marville）拍摄的老巴黎，与后来的尤金·阿切特的摄影一脉相承，开创了都市文献纪实摄影的先河·但是，这些摄影家拍摄的照片大多比较零散，谈不上仝面记录更谈不上思想性和深刻性。]]></content>
      <categories>
        <category>Photograph</category>
      </categories>
      <tags>
        <tag>纪实摄影 - 摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于底片的冲洗]]></title>
    <url>%2F2017%2F09%2F22%2F923%2F</url>
    <content type="text"><![CDATA[显影显影液是最重要的冲洗化学药品，因为它形成影像，将已曝光的胶片转变为底片。再次过程中，显影液与胶片感光乳剂中的感光晶体发生反应，并将它们转变为黑色的金属银。胶片曝光越充分，已显影的银团越厚。在底片上，接受大量曝光的胶片区域（明亮的被摄物体区域）变得最黑暗。 停影停影液通常是很稀的乙酸组成的。你也可以使用普通水的漂洗来终止显影处理。 定影经过显影液的处理后，在照相机中曝光的所有银微粒都已变黑形成了影像。不过，胶片还含有未在照相机中曝光的银微粒。 定影液，也称为海波（硫代硫酸钠），是一种去除未曝光的银的化学药品。如果不定影，那么未曝光的区域也会因为暴露在光线下而最终变黑。 底片冲洗步骤 预浸：浸泡胶片一分钟，软化感光乳剂并促进均匀显影。倒入水后，在桌子上轻轻敲打罐子底部数次，以便气泡排出去。此时水的温度不应与后面显影的温度（通常是20℃）相差太大。 倒入显影液：从显影液完全倒入开始计数，这大概需要五秒的时间。倒入显影液后，在桌子上轻轻敲打罐子底部数次，以便气泡排出去。 摇晃：在显影的最初30秒内连续摇动显影罐。每次停止摇晃的时候，都需要排出气泡。 倒出显影液：在显影时间结束之前5~10秒开始倒出药液。 停影：所有显影液一旦倒出，立刻将停影液倒入罐内。当停影液完全倒入时开始计数。这需要30秒到一分钟。期间连续摇晃显影罐。 定影：倒出停影液之后，立即倒入定影液，摇晃显影罐的时间至少是定影所需要时间的一半甚至全部。定影一定要定透！ 初次水洗：水洗胶片5分钟。注意不能用太大的水流直接冲洗胶片，避免导致胶片损坏。 使用水洗促进剂：倒入水洗促进液，摇晃显影罐的时间至少是定影所需要时间的一半甚至全部。 末次水洗：水洗胶片5~10分钟。注意不能用太大的水流直接冲洗胶片，避免导致胶片损坏。 防水渍液：轻轻倒入防水渍液，不要搅动显影罐（搅动可能会起肥皂泡）。浸泡胶片30秒到一分钟。 晾干：要用有配重的架子，在干燥无尘的环境中晾干胶片。用柔软的海绵（如洗碗用的）润湿后轻轻擦干胶片。等待1~3小时。 压片：将晾干的胶片剪成条装入底片袋，用重物压24小时。 显影时间对底片反差的影响 要使底片反差变大，增加正常显影时间10%~25%或更多。 要使底片反差变小，减少正常显影时间10%~15%或更多。 曝光与显影底片阴影区域的密度主要由胶片曝光决定，高光区域的密度主要由显影决定。因此：按阴影区域曝光，按高光区域显影。 如果胶片曝光太少，显影后的阴影区域就会显得密度不够，不足以可获得适当的纹理细节。改变显影并不能产生胶片上什么也没有的被摄物体细节；他只能改变现有细节的反差。因此为了产生具有适当阴影密度的底片，你必须给予胶片充足的曝光。 阴影区域是接受曝光最少的区域；它们在底片上形成用不了很多时间。剩下的时间显影主要影响高光区域。因此，胶片显影时间越长，在已冲洗底片上的高光密度越大。高光区域会显著变厚，而阴影区域则不会。随着阴影和高光区域密度之间的差异变大，底片的反差变大。 迫冲一档迫冲，增加显影时间35%~50%；两档迫冲，增加显影时间75%~100%。具体以胶片供应商提供的数据为准。 迫冲会导致： 损失阴影细节 反差增大 颗粒度增加 减冲一档减冲，减少显影时间10%~20%；两档减冲，减少显影时间25%~30%。具体以胶片供应商提供的数据为准。 减冲会导致： 反差变小 减少颗粒度 冲洗问题]]></content>
      <categories>
        <category>Photograph</category>
      </categories>
      <tags>
        <tag>胶片</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近况]]></title>
    <url>%2F2017%2F09%2F22%2F922%2F</url>
    <content type="text"><![CDATA[发现已经有半年之久没有更过博客了。最近突然想起还有博客这个玩意，心血来潮在坏掉又返修回来的Surface上部署好环境。终于写下这半年来的第一篇博文。 关于工作自从辞职了忙完毕业设计之后，我就再也没有碰过代码了。迷迷糊糊地来了南方电网，现在在梅州培训基地做起了农民工，经过两个月的暴晒，黑了5个EV。 现实跟理想还是有差距的，原本打算可以去到江门的信息中心做自己本行的工作。但是分配结果出来大失所望，还是没能如愿以偿。最后搞到了配电的培训，不知道培训过后是要做苦逼的配电工作还是别的更苦逼的工作。 说实话，没能留在广州多少有一点遗憾。其实我并不是一个太过爱玩的人，但是毕竟年轻，自己还是想经历更多有趣的东西。在广州工作生活虽然比起台山或者江门，苦很多累很多，租房吃饭一个月下来其实也多赚不了多少钱。但现在每每看到广州有好看的演出，或者看到朋友圈的朋友在广州觅食，我也觉得没留在广州挺可惜的。 选择来到南方电网这个国企还是有自己的原因，就像我跟前公司的HR说的那样“我觉得我在广州工作会买不起房子。”毕竟广州的房价远远比我的工资涨得快多了。我刚来大学城的时候大学城的房子还是一万多的，现在毕业了升到了四五万了。买不起房这个是最主要最主要的原因。当然我也可以选择不在广州买房，我可以在广州工作个四五年然后再回去台山工作。这样听起来很不错，但是自己想到，回到台山这种城市，我只有两个选择：公务员或者国企。这两者都是很看重工龄这个东西，我五年之后回去可能别人已经多我一半的工资。已经买房买车到了结婚的年纪了，而我才重头开始。 不过南网待我不薄，待遇在小城市来说是相当可以的。现在唯一要做的事情就是好好干下去咯。 关于生活在家里冰箱放着三个月前拍完但到现在还没洗的一卷Agfa Vista 200胶卷。这卷胶卷前半卷在广州拍的，那时候我还没毕业；后半卷在台山拍的，我已经换了一个女朋友了。两年多的感情，分手之后其实也蛮感慨的。巧合的是，我跟她分手之后，真的是应验她说的那句“各生欢喜”那样。我们很快就找到各自喜欢的人，在我看来这是一个很好的结局。 跟现任一起已经两个多月了，我们认识七年了，但是现在才一起。我记得之前有朋友问我跟她什么时候认识的，我说我们认识七年了。他几乎不相信自己的耳朵，”七年！如果一起早就一起了！“。有些东西就是这么有趣，就是在这个最艰难的（至少在我看来）时间来到我们身边。我刚毕业，我一无所有，我回到了她不喜欢回去的老家工作。跟她一开始我就要去梅州进行三个月的培训，我们异地了。她说她觉得很虚，我们除了每天在Wechat上说着“我爱你”和偶尔的几通电话，似乎跟以前都没什么区别。我知道，我何尝不是这样的感受。但是，我感到每天我的心都被她填得满满的，这大概是跟以前最大的区别了。 工作之后的恋爱跟校园时期的恋爱是很大的不同：你没读书时候那么自由了，你要去规划未来了，你可能会很忙，你也可能被工作搞得很烦很烦。我听到别人说，走出校园之后的爱情，就会变得很现实了。是的，我觉得是变得很现实。所谓现实，是你会确确实实地为大家的未来而去努力，而不再是夸夸其谈说说而已。出了校园，你校园时期所说的未来离你突然一下子近了，你开始考虑你以前仅放在嘴上说说的未来，你开始规划你的职业，你开始盘算着什么时候存够钱去买房买车。 快国庆了，国庆我们相约去粤东以及福建旅游。我们期待着国庆，就像我们期待我们的未来一样。希望我能一直紧紧握住你的手，就像握住我们手里的每一天。 关于摄影前阵子在闲鱼上收了一个成色极新的Rollei 35T，虽然测光烂了。但还是觉得很值得。手感远比图片好，非常精致。已经喂了一卷廉价的Fuji C200胶卷，期待出片。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[近况]]></title>
    <url>%2F2017%2F03%2F30%2F921%2F</url>
    <content type="text"><![CDATA[近况要走了整天嚷嚷着说要不上班了，结果现在真的不上班了。做完明天，大概我也就是一个“失业”的人了。临走的时候还是要请下组长吃一顿，毕竟我从十月到现在三月这五个月来，组长已经请我们吃了无数次饭，这么好的，技术又牛逼的组长哪里找？！ 关于胶卷很久之前就想要入胶卷的坑了，可是一直都无所行动（主要是因为穷），因为一直想着等大法的a7降价。可是去年一年里，a7 不仅不降价反而还升了几百，这样的垃圾还买来干什么。赶紧入个胶卷机投入全幅的怀抱吧。数码全幅一边去，不等到a72降到6000我是不会入的。 其实仔细算了一下，如果用最屌丝的富士C200，一卷14，冲扫一卷25，算40一卷吧，一个月两卷。80￥/month，其实也不是很贵啦。后期投入是很大，但是想到每一次快门都是钱，拍照应该会认真了很多了。 发觉我是一个不折不扣的器材党，其实自己出片率最高的时候是刚开始买相机的时候。 关于毕设在忙忙碌碌中，毕设已经完成了40%了。也就是最核心的部分已经完成，可以跑起来了。但是效率还是不高，而且要怎么才能让一帮计算机知识不怎么在行的老师看明白我的东西，这才是关键。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[近况]]></title>
    <url>%2F2017%2F03%2F07%2F920%2F</url>
    <content type="text"><![CDATA[无精打采​ 我说人生就像广州的天气——你不知道它什么时候变好，什么时候变坏。昨天还是短袖都嫌热，而今天就穿羽绒都嫌冷。大概是由于气温的飘忽不定，我的精神似乎也因此飘忽不定起来。最近是感觉每天都睡不够，每天都起不来，每天上班都有心无力，大概这是所谓的“辞职前不想工作综合征”？ ​ 每天回来洗完澡就滚上床了，感觉累但是不想睡觉。要不看看书？做下毕业设计？似乎都没心情，只会在那按下手机，也不知道到底干了什么。最后，每天都一两点睡觉，简直不知所谓。 工作​ 很多人问我，为什么不在广州或者深圳工作。每当遇到这样的问题，我都回答“我觉得以我的能力是不能够在广州（深圳）买房。“。说老实，我自己也不知道什么样的工作才是好工作。有前景，福利好，工资高，上班时间短，不累，离家近，决定一份工作是否是”好工作“有太多太多的因素了，而我也就选择了我现在看来的最优解而已。仅仅是在现在。 生活​ 工作很忙，毕设很忙，生活还是老样子。 ​ 博多搞活动，拉面买一送一；五饭依旧不出现；某人搬过来大学城住；小米手环好多坑；想换手机；想买书；没钱；想吃宵夜；想去拍照；没写总结结果没了个优秀；把显示器搬到床上；下个星期我哥结婚摆酒；买的包寄过来了；又想买鞋；下载了很多电影；没时间看电影；想打游戏没时间；想回台山跟朋友喝茶； ​ 。。。 ​]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2F2017%2F02%2F26%2F919%2F</url>
    <content type="text"><![CDATA[入门12345678// 使用淘宝npm源npm install -g cnpm --registry=https://registry.npm.taobao.org// 安装cnpm install -g hexo// 切换到你认为合适的路径，创建博客hexo init// 运行hexo s -p 4040 进阶使用七牛云插件如何配置，hexo-qiniu-sync写得很清楚1cnpm install hexo-qiniu-sync --save 主题直接在把主题clone到hexo的themes文件夹，然后在_config.yml里面指定theme即可。 部署现在Github上面创建一个以你用户名命名的repository。yourname.github.io1234567cnpm install hexo-deployer-git --save// 部署hexo ghexo d -g// 可能会遇到错误，建议先清理一下再generatehexo clean]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近况]]></title>
    <url>%2F2017%2F02%2F26%2F918%2F</url>
    <content type="text"><![CDATA[依旧忙很多懒人喜欢用忙来掩饰自己的懒，我就是其中的一位。懒到旅游计划被搁置，懒到不出去拍照，懒到不更博，甚至懒到出门吃个麻辣烫都不愿意。我跟HR说，要辞了。确实，在一个九月份才成立的创业公司工作，有多辛苦，可想而知。辛苦到下班之后再也不想碰代码，一点也不想碰了。我之前跟鸡哥说过：“当你把你的兴趣变成了工作的时候，你会发现，这并不会是一件好事“。辞掉工作之后应该不会这么忙了，我似乎也终于有时间去好好逛一逛广州了。离毕业仅有三个月，希望可以好好去探索这座我已经生活了四年，以后应该没什么机会再接触的城市。 春招原本盘算着，如果南方电网不录取我的话，我就打算留在现在工作的公司，再不然我就参加春招。现在似乎工作也辞了，春招也不用去了，一切都朝着截然不同的方向发展了。阿柴他拿了南网的offer，但是他不去，他去了中山的一家私企。“觉得有发展前景而已。哈哈”前景。前景。这个虚无缥缈的词。前景会是怎么样的，谁知道呢。年前收到南方电网的录取通知，年后回到学校之后立刻把三方寄出去。我也不知道是什么驱使我，几乎是毫不犹豫地放弃一切的”前景“，回到那个我以前压根没想过回去的地方工作。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python的Signal模块]]></title>
    <url>%2F2017%2F02%2F22%2F913%2F</url>
    <content type="text"><![CDATA[信号进程之间通讯的方式，是一种软件中断。一个进程一旦接收到信号就会打断原来的程序执行流程来处理信号。操作系统规定了进程收到信号以后的默认行为，但是，我们可以通过绑定信号处理函数来修改进程收到信号以后的行为，有两个信号是不可更改的SIGTOP和SIGKILL。 发送信号一般有两种原因 (被动式) 内核检测到一个系统事件.例如子进程退出会像父进程发送SIGCHLD信号.键盘按下control+c会发送SIGINT信号 (主动式) 通过系统调用kill来向指定进程发送信号 几个常用信号: SIGINT 终止进程 中断进程 (control+c) SIGTERM 终止进程 软件终止信号 SIGKILL 终止进程 杀死进程 SIGALRM 闹钟信号 Python中Signal的用法signal包的核心是使用signal.signal()函数来预设(register)信号处理函数 绑定信号处理函数123456789101112131415161718192021import os import signal from time import sleep def onsignal_term(a,b): print '收到SIGTERM信号' #这里是绑定信号处理函数，将SIGTERM绑定在函数onsignal_term上面 signal.signal(signal.SIGTERM,onsignal_term) def onsignal_usr1(a,b): print '收到SIGUSR1信号' #这里是绑定信号处理函数，将SIGUSR1绑定在函数onsignal_term上面 signal.signal(signal.SIGUSR1,onsignal_usr1) while 1: print '我的进程id是',os.getpid() sleep(10) 运行该程序。然后通过另外一个进程来发送信号。import os import signal #发送信号，16175是前面那个绑定信号处理函数的pid，需要自行修改 os.kill(16175,signal.SIGTERM) #发送信号，16175是前面那个绑定信号处理函数的pid，需要自行修改 os.kill(16175,signal.SIGUSR1) signal.alarm()它被用于在一定时间之后，向进程自身发送SIGALRM信号在signal.alarm()执行5秒之后，进程将向自己发出SIGALRM信号，随后，信号处理函数myHandler开始执行。12345678910import signal# Define signal handler functiondef myHandler(signum, frame): print("Now, it's the time") exit()# register signal.SIGALRM's handlersignal.signal(signal.SIGALRM, myHandler)signal.alarm(5)while True: print('not yet')]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python linecache模块读取文件的方法]]></title>
    <url>%2F2017%2F01%2F16%2F909%2F</url>
    <content type="text"><![CDATA[在python中，有个好用的模块linecache，该模块允许从任何文件里得到任何的行，并且使用缓存进行优化，常见的情况是从单个文件读取多行。 linecache.getlines(filename)从名为filename的文件中得到全部内容，输出为列表格式，以文件每行为列表中的一个元素,并以linenum-1为元素在列表中的位置存储linecache.getline(filename,lineno)从名为filename的文件中得到第lineno行。这个函数从不会抛出一个异常–产生错误时它将返回”（换行符将包含在找到的行里）。如果文件没有找到，这个函数将会在sys.path搜索。linecache.clearcache()清除缓存。如果你不再需要先前从getline()中得到的行linecache.checkcache(filename)检查缓存的有效性。如果在缓存中的文件在硬盘上发生了变化，并且你需要更新版本，使用这个函数。如果省略filename，将检查缓存里的所有条目。linecache.updatecache(filename)更新文件名为filename的缓存。如果filename文件更新了，使用这个函数可以更新linecache.getlines(filename)返回的列表。 注意：使用linecache.getlines(‘a.txt’)打开文件的内容之后，如果a.txt文件发生了改变，如果要再次用linecache.getlines获取的内容，不是文件的最新内容，还是之前的内容，此时有两种方法：1、使用linecache.checkcache(filename)来更新文件在硬盘上的缓存，然后在执行linecache.getlines(‘a.txt’)就可以获取到a.txt的最新内容；2、直接使用linecache.updatecache(‘a.txt’)，即可获取最新的a.txt的罪行内容 另外：读取文件之后，不需要使用文件的缓存时，需要在最后清理一下缓存，使linecache.clearcache()清理缓存，释放缓存。此模块使用内存来缓存文件内容，所以需要耗费内存，打开文件的大小和打开速度和你的内存大小有关系。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux日志滚动]]></title>
    <url>%2F2016%2F12%2F28%2F903%2F</url>
    <content type="text"><![CDATA[日志文件包含了关于系统中发生的事件的有用信息，在排障过程中或者系统性能分析时经常被用到。对于忙碌的服务器，日志文件大小会增长极快，服务器会很快消耗磁盘空间，这成了个问题。除此之外，处理一个单个的庞大日志文件也常常是件十分棘手的事。 logrotate是个十分有用的工具，它可以自动对日志进行截断（或轮循）、压缩以及删除旧的日志文件。例如，你可以设置logrotate，让/var/log/foo日志文件每30天轮循，并删除超过6个月的日志。配置完后，logrotate的运作完全自动化，不必进行任何进一步的人为干预。 logrotate的配置文件是/etc/logrotate.conf，通常不需要对它进行修改。日志文件的轮循设置在独立的配置文件中，它（们）放在/etc/logrotate.d/目录下。 一个标准的配置文件123456789101112/var/log/log-file &#123; monthly rotate 5 compress delaycompress missingok notifempty create 644 root root postrotate /usr/bin/killall -HUP rsyslogd endscript&#125; 常用配置项 monthly: 日志文件将按月轮循。其它可用值为‘daily’，‘weekly’或者‘yearly’。 rotate 5: 一次将存储5个归档日志。对于第六个归档，时间最久的归档将被删除。 compress: 在轮循任务完成后，已轮循的归档将使用gzip进行压缩。 delaycompress: 总是与compress选项一起用，delaycompress选项指示logrotate不要将最近的归档压缩，压缩将在下一次轮循周期进行。这在你或任何软件仍然需要读取最新归档时很有用。 missingok: 在日志轮循期间，任何错误将被忽略，例如“文件无法找到”之类的错误。 notifempty: 如果日志文件为空，轮循不会进行。 create 644 root root: 以指定的权限创建全新的日志文件，同时logrotate也会重命名原始日志文件。 postrotate/endscript: 在所有其它指令完成后，postrotate和endscript里面指定的命令将被执行。在这种情况下，rsyslogd 进程将立即再次读取其配置并继续运行。 compress 通过gzip 压缩转储以后的日志 nocompress 不需要压缩时，用这个参数 copytruncate 用于还在打开中的日志文件，把当前日志备份并截断 nocopytruncate 备份日志文件但是不截断 create mode owner group 转储文件，使用指定的文件模式创建新的日志文件 nocreate 不建立新的日志文件 delaycompress 和 compress 一起使用时，转储的日志文件到下一次转储时才压缩 nodelaycompress 覆盖 delaycompress 选项，转储同时压缩。 errors address 专储时的错误信息发送到指定的Email 地址 ifempty 即使是空文件也转储，这个是 logrotate 的缺省选项。 notifempty 如果是空文件的话，不转储 mail address 把转储的日志文件发送到指定的E-mail 地址 nomail 转储时不发送日志文件 olddir directory 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统 noolddir 转储后的日志文件和当前日志文件放在同一个目录下 prerotate/endscript 在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行 postrotate/endscript 在转储以后需要执行的命令可以放入这个对，这两个关键字必须单独成行 daily 指定转储周期为每天 weekly 指定转储周期为每周 monthly 指定转储周期为每月 rotate count 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份 tabootext [+] list 让logrotate 不转储指定扩展名的文件，缺省的扩展名是：.rpm-orig, .rpmsave, v, 和 ~ size size 当日志文件到达指定的大小时才转储，Size 可以指定 bytes (缺省)以及KB (sizek)或者MB (sizem). 要调用为/etc/lograte.d/下配置的所有日志调用logrotate：1# logrotate /etc/logrotate.conf 要为某个特定的配置调用logrotate：1# logrotate /etc/logrotate.d/log-file 调试1# logrotate -d /etc/logrotate.d/log-file logrotate需要的cron任务应该在安装时就自动创建了，我把cron文件的内容贴出来，以供大家参考。12345678910111213# cat /etc/cron.daily/logrotate #!/bin/sh# Clean non existent log file entries from status filecd /var/lib/logrotatetest -e status || touch statushead -1 status &gt; status.cleansed 's/"//g' status | while read logfile datedo [ -e "$logfile" ] &amp;&amp; echo "\"$logfile\" $date"done &gt;&gt; status.cleanmv status.clean statustest -x /usr/sbin/logrotate || exit 0/usr/sbin/logrotate /etc/logrotate.conf]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下更改默认editor]]></title>
    <url>%2F2016%2F12%2F28%2F901%2F</url>
    <content type="text"><![CDATA[Ubuntu 终端下默认的编辑器为 nano。1sudo update-alternatives --config editor 选择合适的就行。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近况]]></title>
    <url>%2F2016%2F12%2F20%2F898%2F</url>
    <content type="text"><![CDATA[忙最近博客少更了，因为找到实习，每天几乎都忙碌在实习更复习南网的面试更笔试之间。本以为上周的南网笔试结束后，忙碌的日子将会告一段落了，可没想到学校居然还因为种种原因给我们加了两门课程。而且是加在考试月里面。这真是坑爹。 实习最近一年都在使用Python，博客大部分内容都是关于Python的。其实刚开始学习Python的时候是因为爬虫。实习，最终还是做了爬虫。很多时候当你把一样你喜欢的东西变成了职业的时候，其实事实上并没有你想象得那么有趣 。Anyway，继续做下去吧。等到南网的录取结果出来了再做打算了。 计划等这段忙绿的事件过去，大概也是2017年了。准备春招吧，如果进不去南网。也许留在现在实习的公司也是一个不错的选择。准备毕设吧，毕竟自己拟题，整了个自己一直想做的东西，既然要做，就要认真做好。好好整理今年拍摄的照片。花多点时间陪陪家人。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Pyspider Deploment(RabbitMQ+MongoDB)]]></title>
    <url>%2F2016%2F11%2F24%2F895%2F</url>
    <content type="text"><![CDATA[123456789101112### config.conf &#123; "taskdb": "mongodb+taskdb://127.0.0.1:27017/taskdb", "projectdb": "mongodb+projectdb://127.0.0.1:27017/projectdb", "resultdb": "mongodb+resultdb://127.0.0.1:27017/resultdb", "message_queue": "amqp://127.0.0.1:5672/%2F", "webui": &#123; "username": "root", "password": "root", "need-auth": true &#125; &#125; 注意，这里的MongoDB跟RabbitMQ都默认没有密码。如需要用户名密码。1&quot;taskdb&quot;: &quot;mongodb+taskdb://username:passwd@127.0.0.1:27017/taskdb&quot;, 运行12345678910# start **only one** scheduler instancepyspider -c config.json scheduler# phantomjspyspider -c config.json phantomjs# start fetcher / processor / result_worker instances as many as your needspyspider -c config.json --phantomjs-proxy="localhost:25555" fetcherpyspider -c config.json processorpyspider -c config.json result_worker# start webui, set `--scheduler-rpc` if scheduler is not running on the same host as webuipyspider -c config.json webui]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Pyspider</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux终端快捷键]]></title>
    <url>%2F2016%2F11%2F24%2F891%2F</url>
    <content type="text"><![CDATA[Shift+Ctrl+T:新建标签页Shift+Ctrl+W:关闭标签页Ctrl+PageUp:前一标签页Ctrl+PageDown:后一标签页Shift+Ctrl+PageUp:标签页左移Shift+Ctrl+PageDown:标签页右移Alt+1:切换到标签页1Alt+2:切换到标签页2Alt+3:切换到标签页3Shift+Ctrl+N:新建窗口Shift+Ctrl+Q:关闭终端终端中的复制／粘贴:Shift+Ctrl+C:复制Shift+Ctrl+V:粘贴]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回车和换行]]></title>
    <url>%2F2016%2F11%2F23%2F888%2F</url>
    <content type="text"><![CDATA[Unix系统里，每行结尾只有”&lt;换行&gt;”，即”\n”；Windows系统里面，每行结尾是”&lt;回车&gt;&lt;换行&gt;”，即”\r\n”；Mac系统里，每行结尾是”&lt;回车&gt;”。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pip 使用豆瓣源和requirements.txt]]></title>
    <url>%2F2016%2F11%2F18%2F883%2F</url>
    <content type="text"><![CDATA[pip install -r requirements.txt -i http://pypi.douban.com/simple --trusted-host pypi.douban.com]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StackEdit 服务器搭建]]></title>
    <url>%2F2016%2F11%2F09%2F878%2F</url>
    <content type="text"><![CDATA[Stackedit是一款很棒的在线Markdown editor。我们现在把它搭建到本地，让其可以离线使用。 安装node.js前往node.js官网安装node.js 下载Stackedit前往github下载 https://github.com/benweet/stackedit 然后解压 安装依赖包1.命令行切换到Stackedit目录，执行npm install2.执行 npm install -g bower3.执行bower install 编写快捷方式保存为后缀名为.bat的文件123e:cd E:\Program Files (x86)\stackeditnode server.js]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说JavaScript里面的面向对象编程]]></title>
    <url>%2F2016%2F10%2F19%2F868%2F</url>
    <content type="text"><![CDATA[创建对象Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。 工厂模式1234567891011121314151617 function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson("Nicholas", 29, "Software Engineer");var person2 = createPerson("Greg", 27, "Doctor");person1.sayName(); //"Nicholas"person2.sayName(); //"Greg"alert(person1 instanceof createPerson) //falsealert(person1 instanceof Object) //truealert(typeof person1) //object 缺点：无法解决对象识别问题 构造函数模式123456789101112131415161718192021222324function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;; &#125; //必须使用new操作符 var person1 = new Person("Nicholas", 29, "Software Engineer"); var person2 = new Person("Greg", 27, "Doctor"); Person("Nicholas", 29, "Software Engineer"); //作为普通函数调用 windows.sayName(); //"Nicholas" var o = new Object() Person.call(o,"Nicholas", 29, "Software Engineer") //在另一个对象的作用域中调用 person1.sayName(); //"Nicholas" person2.sayName(); //"Greg" alert(person1 instanceof Object); //true alert(person1 instanceof Person); //true alert(person2 instanceof Object); //true alert(person2 instanceof Person); //true alert(person1.constructor == Person); //true alert(person2.constructor == Person); //true alert(person1.sayName == person2.sayName); //false 问题：person1与person2的sayName()方法不是同一个Function实例。可以这样解决。123456789function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName; //这是指针，需是全局函数&#125;function sayName()&#123; alert(this.name);&#125; 问题：分开写好麻烦，函数需是全局的。毫无封装性可言 原型模式我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象。而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中12345678910111213function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //"Nicholas"var person2 = new Person();person2.sayName(); //"Nicholas"alert(person1.sayName == person2.sayName); //true 新对象的属性和方法是由所有实例共享的。 理解原型对象无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。就拿前面的例子来说，Person．prototype．constructor指向Person而通过这个构造函数我们还可继续为原型对象添加其他属性和方法。 12345678alert(Person.prototype.isPrototypeOf(person1)); //truealert(Person.prototype.isPrototypeOf(person2)); //true//only works if Object.getPrototypeOf() is available//返回[[Prototype]]if (Object.getPrototypeOf)&#123; alert(Object.getPrototypeOf(person1) == Person.prototype); //true alert(Object.getPrototypeOf(person1).name); //"Nicholas"&#125; 创建了自定义的构造函数之后，其原型对像默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针[[Prototype]]（内部属性），指向构造函数的原型对象。在脚本中没有标准的方式访问[[Prototype]]， Flrefox、Safan和Chrome在每个对象上都支持一个属性proto;而在其他实现中，这个属性对脚本则是完全不可见的。这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 首先寻找实例的属性，然后再寻找原型的属性。12345678910111213function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = "Greg";alert(person1.name); //"Greg" ?from instancealert(person2.name); //"Nicholas" ?from prototype 使用hasOwnProperty()方法检测一个属性是存在实例中，还是存在原型中。in操作符，无论属性存在示例中还是原型中12345678910111213141516171819202122232425function Person()&#123; &#125; Person.prototype.name = "Nicholas"; Person.prototype.age = 29; Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; var person1 = new Person(); var person2 = new Person(); alert(person1.hasOwnProperty("name")); //false alert("name" in person1); //true person1.name = "Greg"; alert(person1.name); //"Greg" ?from instance alert(person1.hasOwnProperty("name")); //true alert("name" in person1); //true alert(person2.name); //"Nicholas" ?from prototype alert(person2.hasOwnProperty("name")); //false alert("name" in person2); //true delete person1.name; alert(person1.name); //"Nicholas" - from the prototype alert(hasPrototypeProperty(person, "name")); //false alert(person1.hasOwnProperty("name")); //false alert(hasPrototypeProperty(person1, "name")); //true alert("name" in person1); //true 在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的(enumerated)属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为false属性）的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的一一只有在IE8及更早版本中外。Object.keys()接受一个对象作为参数，返回一个包含所有可枚举属性的字符串数组12var keys = Object.keys(Person.prototype);alert(keys); //"name,age,job,sayName" Obejct.getOwnProperyNames()取得所有实例属性，无论是否枚举12var keys = Object.getOwnPropertyNames(Person.prototype);alert(keys); //"constructor,name,age,job,sayName" 更简单的原型语法1234567891011function Person()&#123;&#125;Person.prototype = &#123; name : "Nicholas", age : 29, job: "Software Engineer", sayName : function () &#123; alert(this.name); &#125;&#125;;var friend = new Person(); 在上面的代码中我们将person.prototype设置为等于一个以对象字面量形式创建的新对象最终结果相同，但有一个例外:constructor属性不再指向person了。前面曾经介绍过，每创建一个函数，就会同时创建它的prototype对象，这个对象也会自动获得constructor属性。而我们在这里使用的语法，本质上完全重写了默认的prototype对象因此constructor属性也就变成了新对象的constructor属性（指向Object构造函数），不再指向person函数。此时，尽管instanceof操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了1234alert(friend instanceof Object); //truealert(friend instanceof Person); //truealert(friend.constructor == Person); //falsealert(friend.constructor == Object); //true 重设constructor属性会导致他的[[Enumerable]]特性被设为true。默认是false123456789Person.prototype = &#123; constructor : Person, name : "Nicholas", age : 29, job: "Software Engineer", sayName : function () &#123; alert(this.name); &#125;&#125;; 问题：原型中所有属性都是被实例们共享的。对于那些包含基本值的属性还说得过去（通过在实例上添加一个同名属性，可以隐藏原型中对应的属性），然而对于包含引用类型值的属性来说就有问题了123456789101112131415161718function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, name : "Nicholas", age : 29, job : "Software Engineer", friends : ["Shelby", "Court"], sayName : function () &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push("Van");alert(person1.friends); //"Shelby,Court,Van"alert(person2.friends); //"Shelby,Court,Van"alert(person1.friends === person2.friends); //true 组合使用构造函数模式和原型模式构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。12345678910111213141516171819function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = ["Shelby", "Court"];&#125;Person.prototype = &#123; constructor: Person, sayName : function () &#123; alert(this.name); &#125;&#125;;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor");person1.friends.push("Van");alert(person1.friends); //"Shelby,Court,Van"alert(person2.friends); //"Shelby,Court"alert(person1.friends === person2.friends); //falsealert(person1.sayName === person2.sayName); //true 动态原型模式把所有信息息都封装在了构造函数中，而通过在构造数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。1234567891011121314function Person(name, age, job)&#123; //properties this.name = name; this.age = age; this.job = job; //methods if (typeof this.sayName != "function")&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125;&#125;var friend = new Person("Nicholas", 29, "Software Engineer");friend.sayName(); 寄生构造函数模式创建一个函数，该函数的作用仅仅是封装对象的代码，然后返回新创建的对象123456789101112function Person(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var friend = new Person("Nicholas", 29, "Software Engineer");friend.sayName(); //"Nicholas" 这个模式可以在特殊情况下用来为对象创建构造函数。例如，由于不能直接修改Array构造函数，因此可以123456789101112131415function SpecialArray()&#123; //create the array var values = new Array(); //add the values values.push.apply(values, arguments); //assign the method values.toPipedString = function()&#123; return this.join("|"); &#125;; //return it return values; &#125;var colors = new SpecialArray("red", "blue", "green");alert(colors.toPipedString()); //"red|blue|green"alert(colors instanceof SpecialArray);//false 返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。因此，不能用instanceof来确定对象类型。 稳妥构造函数模式所谓稳妥对象，指的是没有公共属性。1234567function Person(name, age, job)&#123; var o = new Object(); o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125; 在以这种模式创建的对象中，除了使用方法之外，没有其他办法访问属性值。在某些情况下使用。 继承通常OO语言都支持两种继承方式：接口继承：只继承方法签名实现继承：继承实际的方法 原型链基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。如此层层递进。 123456789101112131415161718192021222324 function SuperType()&#123; this.property = true; &#125; SuperType.prototype.getSuperValue = function()&#123; return this.property; &#125;; function SubType()&#123; this.subproperty = false; &#125; //inherit from SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function ()&#123; return this.subproperty; &#125;; var instance = new SubType(); alert(instance.getSuperValue()); //true alert(instance.getSubValue()); //false alert(instance instanceof Object); //true alert(instance instanceof SuperType); //true alert(instance instanceof SubType); //true//只要原型链中出现过的原型，都为true alert(Object.prototype.isPrototypeOf(instance)); //true alert(SuperType.prototype.isPrototypeOf(instance)); //true alert(SubType.prototype.isPrototypeOf(instance)); //true 实例的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中。只不过子类中同名属性会覆盖父类中的同名属性。1234567891011121314151617function SuperType()&#123; this.property = true; &#125; SuperType.prototype.getSuperValue = function()&#123; return this.property; &#125;; function SubType()&#123; this.property = false; &#125; //inherit from SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function ()&#123; return this.property; &#125;; var instance = new SubType(); alert(instance.getSuperValue()); //false alert(instance.getSubValue()); //false 所有的函数的默认原型都是Object的实例，因为默认原型都会有一个内部指针，指向Object.prototype。 重写父类的方法1234//override existing methodSubType.prototype.getSuperValue = function ()&#123; return false;&#125;; 使用对象字面量创建原型方法，会重写原型链。12345678910111213141516171819202122function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//inherit from SuperTypeSubType.prototype = new SuperType();//try to add new methods ?this nullifies the previous lineSubType.prototype = &#123; getSubValue : function ()&#123; return this.subproperty; &#125;, someOtherMethod : function ()&#123; return false; &#125;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //error! 原型链的问题 包含引用类型值的原型属性会被所有实例共享 在创建子类型的实例时，不能向父类的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给父类的构造函数传递参数 借用构造函数在子类构造函数的内部调用父类的构造函数。123456789101112131415161718function SuperType(name)&#123; this.name = name; this.sayName = function () &#123; return this.name &#125;&#125;function SubType()&#123; //在新创建的SubType实际的环境下调用了SuperType的构造函数，SubType的每个实例都会有自己的属性副本 SuperType.call(this, "Nicholas"); //instance property this.age = 29;&#125;var instance = new SubType();alert(instance.name); //"Nicholas";alert(instance.age); //29var instance = new SubType();var instance2 = new SubType()alert(instance.sayName === instance2.sayName) //false 问题： 方法都在构造数中定义，因此函数复用就无从谈起了。 在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构函数模式。 组合继承将原型链和借用构造函数的技术组合到一块。最常用的继承12345678910111213141516171819202122232425function SuperType(name)&#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;var instance1 = new SubType("Nicholas", 29);instance1.colors.push("black");alert(instance1.colors); //"red,blue,green,black"instance1.sayName(); //"Nicholas";instance1.sayAge(); //29var instance2 = new SubType("Greg", 27);alert(instance2.colors); //"red,blue,green"instance2.sayName(); //"Greg";instance2.sayAge(); //27alert(instance.sayName === instance2.sayName) //true 原型式继承先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。本质上，object()对传入其中的对象执行了一次浅复制123456789101112131415161718192021222324252627 function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F() &#125; var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"] &#125;; var anotherPerson = object(person); anotherPerson.name = "Greg"; anotherPerson.friends.push("Rob"); var yetAnotherPerson = object(person); yetAnotherPerson.name = "Linda"; yetAnotherPerson.friends.push("Barbie"); alert(person.friends); //"Shelby,Court,Van,Rob,Barbie"Object.create()方法 var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"] &#125;; var anotherPerson = Object.create(person, &#123; name: &#123; value: "Greg" &#125; &#125;); alert(anotherPerson.name); //"Greg" 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下使用。包含引用类型值的属性始终都会共享相应的值 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后像真的是它做了所有工作一样返回对象12345678910111213141516171819// 相当于继承 function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F() &#125; function createAnother(original) &#123; var clone = object(original) clone.sayHi= function () &#123; alert("hi") &#125; return clone &#125; var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"] &#125;; var anotherPerson = createAnother(person) anotherPerson.sayHi() 问题：不能函数复用 寄生组合式继承组合式继承最大的问题就是无论什么情况下，都会调用两次构造函数：一次是在创建子类原型的时候，另一次是在子类构造函数内部。12345678910111213function SuperType(name)&#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;SubType.prototype = new SuperType();//详见组合继承的代码 第一次调用SuperType构造函数时。SubType.prototype会得到两个属性，name和colors；它们是SuperType的实例属性第二次调用SuperType构造函数时。在新对象上创建了实例属性name和colors，这两个属性屏蔽了原型中的两个同名属性 寄生组合式继承：通过借用构造函数的来继承属性，通过原型链的混成形式来继承办法。不必为了指定子类的原型而调用父类的构造函数，我们所需要的无非就是父类原型的一个副本。本质上，使用寄生式继承来继承父类的原型，然后再讲结果指定给子类的原型。 12345678// 用来代替SubType.prototype = new SuperType();// subType.prototype=superType.prototypefunction inheritPrototype(subType,superType)&#123; var prototype=object(superType.prototype)// 弥补因重写原型而失去的默认constructor prototype.constructor=subType subType.prototype=prototype&#125; 只调用一次父类构造函数，原型链保持不变，正常使用instanceof 和isPrototypeOf]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——判断t1树是否包含t2树的全部拓扑结构]]></title>
    <url>%2F2016%2F10%2F19%2F865%2F</url>
    <content type="text"><![CDATA[原理：遍历t1树，然后将其每个子树与t2作比较。最后把所有结果进行或运算即可。复杂度：O(N*M) t1节点数N;t2节点数M 12345678910111213141516171819202122class Node: def __init__(self, value, left=None, right=None): self.left = left self.right = right self.value = valuedef check(h, t2): # t2为None，说明t2已经遍历完了 if t2 == None: return True if h == None or h.value != t2.value: return False # 只有t2左右两边都能完整地遍历，才能说明t1子树h包含t2树的全部拓扑结构 return check(h.left, t2.left) and check(h.right, t2.right)def contains(t1, t2): # 若t1为叶子结点 if t1.left is None or t1.right is None: return check(t1, t2) else: # 前序遍历t2,将他们的返回值进行或运算 return check(t1, t2) or contains(t1.left, t2) or contains(t1.right, t2)t1 = Node(1, Node(2, Node(4, Node(8), Node(9)), Node(5, Node(10))), Node(3, Node(6), Node(7)))t2 = Node(2, Node(4, Node(8)), Node(5))# t2=Node(9)print contains(t1, t2)]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——二叉树的序列化和反序列化]]></title>
    <url>%2F2016%2F10%2F19%2F863%2F</url>
    <content type="text"><![CDATA[二叉树被记录成文件的过程称为二叉树的序列化同通过文件重建二叉树的过程称为二叉树的反序列化方法一：通过先序遍历实现序列化和反序列化建立string，先序遍历二叉树，如果遇到null节点，就在string的末尾加上”#!”,”#”表示这个节点为空，”!”表示一个值的结束。对于不为空的节点，假设3，则为”3!” 123456789101112131415161718192021222324from collections import dequeclass Node:def __init__(self, value, left=None, right=None): self.left = left self.right = right self.value = valuedef serialByPre(head):if head == None: return '#!'string = str(head.value) + '!'string += serialByPre(head.left)string += serialByPre(head.right)return stringdef reconByPreString(string):l = deque(string.split('!'))def reconPreOrder(l): value = l.popleft() if value == '#': return None head = Node(int(value)) head.left = reconPreOrder(l) head.right = reconPreOrder(l) return headreturn reconPreOrder(l) 方法二：通过层次遍历12345678910111213141516171819202122232425262728293031323334353637383940def serialByLevel(head):if head == None: return '#!'string = str(head.value) + '!'queue = deque()queue.append(head)while len(queue) != 0: head = queue.popleft() if head.left is not None: string += str(head.left.value) + '!' queue.append(head.left) else: string += '#!' if head.right is not None: string += str(head.right.value) + '!' queue.append(head.right) else: string += '#!'return stringdef reconByLevelString(levelStr):def generateNodeByString(val): return Node(int(val)) if val != '#' else Nonevalues = levelStr.split('!')queue = deque()index = 0head = Node(values[index])index += 1if head is not None: queue.append(head)while len(queue) != 0: node = queue.popleft() node.left = generateNodeByString(values[index]) index += 1 node.right = generateNodeByString(values[index]) index += 1 if node.left is not None: queue.append(node.left) if node.right is not None: queue.append(node.right)return head]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不用额外变量交换两个整数的值]]></title>
    <url>%2F2016%2F10%2F18%2F861%2F</url>
    <content type="text"><![CDATA[异或a=a^bb=a^ba=a^b]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——最长递增子序列]]></title>
    <url>%2F2016%2F10%2F18%2F859%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728先看复杂度为O(N^2)的简单版本'''复杂度为O(N^2)的方法，算法很简单。dp[i]表示在以arr[i]这个数结尾的情况下，arr[0....i]中的最大递增子序列'''def getdp1(arr): n = len(arr) dp = [0] * n for i in range(n): dp[i] = 1 for j in range(i): if arr[i] &gt; arr[j]: dp[i] = max(dp[i], dp[j] + 1) return dpdef generateLIS(arr, dp): n = max(dp) index = dp.index(n) lis = [0] * n n -= 1 lis[n] = arr[index] # 从右向左 for i in range(index, 0 - 1, -1): # 关键 if arr[i] &lt; arr[index] and dp[i] == dp[index] - 1: n -= 1 lis[n] = arr[i] index = i return lis getdp函数的复杂度太高，我们尝试下将其降到O(NlogN) 我们利用二分查找的思想我们试着用一个数组ends保存，在所有长度为i的递增序列中，最小的结尾数为ends[i-1]初始化一个ends[]和一个int型right，并规定ends[0,…,right]为有效区，否则为无效区遍历arr，假设当前为i，在ends的有效区从最左边开始找，找到大于arr[i]的数，则表示arr[i]结尾的最长递增序列长度=right+1最后还有修改ends对应的值为arr[i]，以便下次遍历 如arr = [2, 1, 5, 3, 6, 4, 8, 9, 7]ends[0]=arr[0]=2right=0i=1,ends有效区=[2]从左开始,ends[0]&gt;arr[1],表示arr[i]结尾的最长递增序列长度=right+1=1,ends[0]=arr[1]=1i=2,ends有效区=[1]从左开始,ends[0]&lt;arr[2],没有发现，最长递增序列长度=right+1=2right++ends[right]=arr[2]i=3,ends有效区=[1,5]从左开始,ends[1]&gt;arr[3],表示arr[i]结尾的最长递增序列长度=right+1=2,ends[0]=arr[3]=3i=4,ends有效区=[1,3]1234567891011121314151617181920def getdp2(arr): n = len(arr) dp, ends = [0] * n, [0] * n ends[0], dp[0] = arr[0], 1 right, l, r, m = 0, 0, 0, 0 for i in range(1, n): l = 0 r = right # 二分查找,若找不到则ends[l或r]是比arr[i]大而又最接近其的数 # 若arr[i]比ends有效区的值都大，则l=right+1 while l &lt;= r: m = (l + r) / 2 if arr[i] &gt; ends[m]: l = m + 1 else: r = m - 1 right = max(right, l) ends[l] = arr[i] dp[i] = l + 1 return dp 别小看了从O(N^2)到O(NlogN)在8000的规模下算法1和算法2的运行时间为8.28299999237和0.0190000534058两者相差436倍！！]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python设计模式——外观模式（门面模式）]]></title>
    <url>%2F2016%2F10%2F18%2F855%2F</url>
    <content type="text"><![CDATA[假设你去买东西，你肯定是问店主，因为店主对这家店的货物分布比你熟悉，然后店主把你需要的东西交给你，就这么简单。 要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用。 It provides a unified interface to a set of interfaces in a subsystem and defines a highlevel interface that helps the client use the subsystem in an easy way. 除了这个接口不允许有任何访问子系统的行为发生。Facade门面角色：客户端可以调用这个角色的方法。次角色知晓子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去，也就是说该角色没有实际的业务逻辑，只是一个委托类。subsystem子系统角色：每一个子系统都不是一个单独的类，而是一个类的集合。子系统不知道门面的存在。对于子系统而言，门面仅仅是另外一个客户端而已。 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# coding:utf-8'''你 向 Manager 询问，Manager回答你，你不用关心里面的细节'''class EventManager(object): def __init__(self): print("Event Manager:: Let me talk to the folks\n") def arrange(self): self.hotelier = Hotelier() self.hotelier.bookHotel() self.florist = Florist() self.florist.setFlowerRequirements() self.caterer = Caterer() self.caterer.setCuisine() self.musician = Musician() self.musician.setMusicType()class Hotelier(object): def __init__(self): print("Arranging the Hotel for Marriage? --") def __isAvailable(self): print("Is the Hotel free for the event on given day?") return True def bookHotel(self): if self.__isAvailable(): print("Registered the Booking\n\n")class Florist(object): def __init__(self): print("Flower Decorations for the Event? --") def setFlowerRequirements(self): print("Carnations, Roses and Lilies would be used for Decorations\n\n")class Caterer(object): def __init__(self): print("Food Arrangements for the Event --") def setCuisine(self): print("Chinese &amp; Continental Cuisine to be served\n\n")class Musician(object): def __init__(self): print("Musical Arrangements for the Marriage --") def setMusicType(self): print("Jazz and Classical will be played\n\n")class You(object): def __init__(self): print("You:: Whoa! Marriage Arrangements??!!!") def askEventManager(self): print("You:: Let's Contact the Event Manager\n\n") em = EventManager() em.arrange() def __del__(self): print("You:: Thanks to Event Manager, all preparations done!Phew!") you = You()you.askEventManager()'''You:: Whoa! Marriage Arrangements??!!!You:: Let's Contact the Event ManagerEvent Manager:: Let me talk to the folksArranging the Hotel for Marriage? --Is the Hotel free for the event on given day?Registered the BookingFlower Decorations for the Event? --Carnations, Roses and Lilies would be used for DecorationsFood Arrangements for the Event --Chinese &amp; Continental Cuisine to be servedMusical Arrangements for the Marriage --Jazz and Classical will be playedYou:: Thanks to Event Manager, all preparations done!Phew!''' 优点 减少了系统的相互依赖。所有的依赖都是对门面对象的依赖，与子系统无关 提高灵活性，不管子系统内部如何变化，只要不影响到门面对象，任你自由活动 提高安全性 缺点 不符合开闭原则，对修改关闭，对扩展开放。唯一能做的就只有修改门面角色的代码。 场景 为一个复杂的模块或子系统提供一个供外界访问的接口 子系统相对独立——外界对子系统的访问只要黑箱操作即可 注意事项 一个子系统可以有多个门面 门面不参与子系统内的业务逻辑 门面只是提供一个访问子系统的一个路径，它不应该也不能参与具体的业务逻辑，否则会产生一个倒依赖的问题：子系统必须依赖门面才能被访问。 门面不能常变，而业务常变 解决方法，可以将具体的业务封装在一个类中，封装完毕后提供给门面对象调用。（试下修改代码中的arrange？）]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python设计模式——工厂方法模式]]></title>
    <url>%2F2016%2F10%2F18%2F850%2F</url>
    <content type="text"><![CDATA[简单工厂模式UML图当Client调用Factory的create_type方法，Factory会根据传递的参数，生产出Product1或Product2 工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 define an interface to create objects, but instead of the factory being responsible for the object creation, the responsibility is deferred to the subclass that decides the class to be instantiated. 抽象产品类Product负责定义产品的共性，实现对事物最抽象的定义；Creator为抽象创造类，也就是抽象工厂，具体如何创建产品类是由具体的实现工厂ConcreteCreator完成的。 UML图 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041class Section(metaclass=ABCMeta): @abstractmethod def describe(self): passclass PersonalSection(Section): def describe(self): print("Personal Section")class AlbumSection(Section): def describe(self): print("Album Section")class PatentSection(Section): def describe(self): print("Patent Section")class PublicationSection(Section): def describe(self): print("Publication Section")class Profile(metaclass=ABCMeta): def __init__(self): self.sections = [] self.createProfile() @abstractmethod def createProfile(self): pass def getSections(self): return self.sections def addSections(self, section): self.sections.append(section)class linkedin(Profile): def createProfile(self): self.addSections(PersonalSection()) self.addSections(PatentSection()) self.addSections(PublicationSection())class facebook(Profile): def createProfile(self): self.addSections(PersonalSection()) self.addSections(AlbumSection())if __name__ == '__main__': profile_type = input("Which Profile you'd like to create? [LinkedIn or FaceBook]\n") profile = eval(profile_type.lower())() print("Creating Profile..", type(profile).__name__) print("Profile has sections --", profile.getSections()) 对比简单工厂模式，你就会发现，两者的不同在于工厂方法模式多了一个抽象工厂类（在此例中为Profile）。所以“定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。” 优点 良好的封装性。一个对象创建时有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或者约束字符串）就可以了。屏蔽了产品类。 扩展性优秀。只要扩展一个工厂类就行。 解耦 工厂方法模式是new一个对象的代替品，但需要考虑其增加代码复杂度的成本。例如设计一个连接邮件服务器的框架，把POP3，IMAP，HTTP三种连接方式作为产品类。定义一个工厂方法，根据不同的传入条件，产生不同的产品类，从而选择不同的连接方式。 抽象工厂模式UML图Product1与Product2是由关联的，而其又分别从两个工厂生产出来的，用户通过使用抽象工厂的接口，指挥具体的工厂生产出产品 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class PizzaFactory(metaclass=ABCMeta): @abstractmethod def createVegPizza(self): pass @abstractmethod def createNonVegPizza(self): passclass IndianPizzaFactory(PizzaFactory): def createVegPizza(self): return DeluxVeggiePizza() def createNonVegPizza(self): return ChickenPizza()class USPizzaFactory(PizzaFactory): def createVegPizza(self): return MexicanVegPizza() def createNonVegPizza(self): return HamPizza()# 素食披萨class VegPizza(metaclass=ABCMeta): @abstractmethod def prepare(self, VegPizza): pass# 非素食披萨class NonVegPizza(metaclass=ABCMeta): @abstractmethod def serve(self, VegPizza): passclass DeluxVeggiePizza(VegPizza): def prepare(self): print("Prepare ", type(self).__name__)class ChickenPizza(NonVegPizza): def serve(self, VegPizza): print(type(self).__name__, " is served with Chicken on ", type(VegPizza).__name__)class MexicanVegPizza(VegPizza): def prepare(self): print("Prepare ", type(self).__name__)class HamPizza(NonVegPizza): def serve(self, VegPizza): print(type(self).__name__, " is served with Ham on ", type(VegPizza).__name__)class PizzaStore: def __init__(self): pass def makePizzas(self): for factory in [IndianPizzaFactory(), USPizzaFactory()]: self.factory = factory self.NonVegPizza = self.factory.createNonVegPizza() self.VegPizza = self.factory.createVegPizza() # NonVegPizza 依赖于 VegPizza self.VegPizza.prepare() self.NonVegPizza.serve(self.VegPizza)pizza = PizzaStore()pizza.makePizzas()'''Prepare DeluxVeggiePizzaChickenPizza is served with Chicken on DeluxVeggiePizzaPrepare MexicanVegPizzaHamPizza is served with Ham on MexicanVegPizza''' 工厂方法和抽象工厂方法的不同 工厂方法 抽象工厂方法 把创造产品的方法暴露给客户 包含一个或多个工厂方法，来创造有关联的产品 子类决定实例化哪一个类 使用合成来委托 工厂方法用来创建一个对象 创造一个有关联的产品族 抽象工厂方法，增加产品族非常难。这要更改AbstractCreator，增加一个createProduct，然后其余的createProduct都要一同更改。但是增加产品还是很方便的，比如我们增加一个海鲜披萨？但涉及跨平台的时候，各个操作系统上的软件功能，应用逻辑，UI都大致相似，我们需要的是使用抽象工厂模式屏蔽掉操作系统对应用的影响，调用不同的工厂方法，由不同的产品类去处理与操作系统交互的信息。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——换零钱的方法数]]></title>
    <url>%2F2016%2F10%2F17%2F844%2F</url>
    <content type="text"><![CDATA[给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，在给定一个整数aim代表要找的钱，求换钱有多少种方法。如arr=[1,5,10,25],aim=0,返回1arr=[1,5,10,25],aim=15,返回6arr=[3,5],aim=2,返回0 暴力递归破解法如果arr=[5,10,25,1],aim=151.用0张5元货币，让[10,25,1]组成剩下的15,最终方法数记为res12.用1张5元货币，让[10,25,1]组成剩下的10,最终方法数记为res23.用2张5元货币，让[10,25,1]组成剩下的5,最终方法数记为res34.用3张5元货币，让[10,25,1]组成剩下的0,最终方法数记为res41234res1:2(0*5+15*1;0*5+1*10+1*5)res2:2(1*5+10*1;1*5+1*10)res3:1(2*5+5*1)res4:1(3*5) 答案就是res1+res2+res3+res4缺点：大量重复计算。规模小的时候还好，一旦规模大了。比如aim=1000，对于05+110和25+010，后续的计算都是一样的，求[25,1]组合剩下的990的方法总数。 复杂度：O(aim^N) 1234567891011121314arr = [5, 10, 25, 1]aim = 15def naive_res_conis(arr, aim): def r(arr, aim, index): res = 0 if index == len(arr): res = 1 if aim == 0 else 0 else: i = 0 while arr[index] * i &lt;= aim: res += r(arr, aim - arr[index] * i, index + 1) i += 1 return res return r(arr, aim, 0) 经过记忆搜索优化的暴力递归又如上面aim=1000的例子。对于0*5+1*10和2*5+0*10，他们调用递归函数时候传入的参数，arr,aim,index都是相同的，也就是说我们可以利用这一性质去除重复的计算。记忆搜索优化是针对暴力递归最初级的优化技巧，分析递归函数的状态可以由那些变量表示，做出相应维度和大小的cache即可。 复杂度:O(N*aim^2) 123456789101112131415161718192021222324252627282930313233343536373839404142from functools import wrapsdef memo(func): cache = &#123;&#125; @wraps(func) def wrap(*args): if args not in cache: cache[args] = func(*args) return cache[args] return wrapdef memo_res_conis(arr, aim): arr = arr @memo def r(aim, index): res = 0 if index == len(arr): res = 1 if aim == 0 else 0 else: i = 0 while arr[index] * i &lt;= aim: res += r(aim - arr[index] * i, index + 1) i += 1 return res return r(aim, 0)# ++++++++++++++++++++TEST++++++++++++++++++++++++++'''import timeaim=500begin=time.time()print memo_res(arr,aim)print time.time()-beginbegin=time.time()print naive_res(arr,aim)print time.time()-begin'''# 结果'''190060.018000125885190061.15899991989'''# ++++++++++++++++++++TEST END+++++++++++++++++++++++ 关于记忆搜索优化，可见记忆体化的装饰器。 动态规划1234567891011121314151617181920dp[i][j]的含义，在可以任意使用arr[0...i]货币的情况下，组成j有多少种方法。dp[...][0]:组成钱为0的方法数，全部置1dp[0][...]:只能使用arr[0]的货币的情况下，组成钱的方法数dp[1][...]:只能使用arr[0]与arr[1]的货币的情况下，组成钱的方法数假设计算到位置(i,j),dp[i][j]的值可能来自下面的情况1.完全不使用当前货币arr[i]的情况,即dp[i-1][j]2.使用1张货币arr[i]的情况,即dp[i-1][j-arr[i]]3.使用2张货币arr[i]的情况,即dp[i-1][j-2*arr[i]]....k+1.使用k张货币arr[i]的情况,即dp[i-1][j-k*arr[i]] (j-k*arr[i]&gt;=0)#### 复杂度：枚举dp[i-1][0...j]上的所有值，dp一共有N*aim个O(N*aim^2)本质上，动态规划等价于记忆化搜索方法。记忆话搜索的方法说白了就是不关心到达某一个递归过程的路径，只是单纯地对计算过的递归过程进行记录，避免重复的递归。动态规划的方法则是规定好每一个递归过程的计算顺序，一次进行计算，后计算的过程严格依赖前面计算的过程。动态规划规定计算顺序，而记忆搜索不用规定。各有各的优势动态规划可以将递归变为迭代。记忆搜索面对某些情况，如arr=[20000,10000,1000],aim=2000000000的情况有优势 123456789101112131415161718192021def dp_coins(arr, aim): n = len(arr) dp = [[0] * (aim + 1) for i in range(n)] # 第一列全部置1 for i in range(n): dp[i][0] = 1 # 初始化第一行 j = 0 while arr[0] * j &lt;= aim: dp[0][arr[0] * j] = 1 j += 1 for i in range(1, n): for j in range(1, aim + 1): num, k = 0, 0 while arr[i] * k &lt;= j: # k=0时,也就是dp[i-1][j],也就是上一个元素 # k=1时,也就是使用一张arr[i]货币的情况 num += dp[i - 1][j - arr[i] * k] k += 1 dp[i][j] = num return dp[-1][-1] 动态规划的优化（什么？还能优化？）我们将目光放在前一个算法的第二个while循环里面。本质上，while里面的枚举可以化简为dp[i][j]=dp[i-1][j]+dp[i][[j-arr[i]] (上边的加上左边的)如，123arr = [5, 10, 25, 1]aim = 25dp[1][25]=dp[0][25](只用5块)+dp[i][[j-arr[i]](用5块跟10块组成j-arr[i]元的方法数) 复杂度:O(N*aim) 12345678910111213141516def dp_coin2(arr, aim): n = len(arr) dp = [[0] * (aim + 1) for i in range(n)] # 第一列全部置1 for i in range(n): dp[i][0] = 1 # 初始化第一行 j = 0 while arr[0] * j &lt;= aim: dp[0][arr[0] * j] = 1 j += 1 for i in range(1, n): for j in range(1, aim + 1): dp[i][j] = dp[i - 1][j] dp[i][j] += dp[i][j - arr[i]] if j - arr[i] &gt;= 0 else 0 return dp[-1][-1] 空间压缩将空间复杂度降为O(aim) 12345678910111213def dp_coin3(arr, aim): n = len(arr) dp = [0 for i in range(aim + 1)] # 初始化第一行 j = 0 while arr[0] * j &lt;= aim: dp[arr[0] * j] = 1 j += 1 for i in range(1, n): for j in range(1, aim + 1): dp[j] += dp[j - arr[i]] if j - arr[i] &gt;= 0 else 0 return dp[-1]print dp_coin3(arr, aim)]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Python撸DSL(领域特定语言)]]></title>
    <url>%2F2016%2F10%2F14%2F841%2F</url>
    <content type="text"><![CDATA[何为DSL：DSL就是一种特定解决领域问题的的迷你语言。如SQL语言，正则表达式 内部与外部指的是实现DSL的方式是否与宿主语言隔离。 内部DSL(Internal DSL)所谓内部DSL，就是用一种提供语言扩展功能的宿主语言来扩充的。如Django中的Model 外部DSL(External DSL)外部DSL则与源语言无关，重头写词法分析器、语法分析器以及解释执行器。 为何要编写DSL举个例子，一个HTML表格12345&lt;form&gt;&lt;label&gt;Name:&lt;/label&gt;&lt;input type=”text” name=”name”/&gt;&lt;label&gt;Email:&lt;/label&gt;&lt;input type=”text” name=”email”/&gt;&lt;label&gt;Password:&lt;/label&gt;&lt;input type=”password” name=”name”/&gt;&lt;/form&gt; 编写这个HTML文档需要编写者具有HTML的知识我们尝试着编写自己的DSL，将语句简化为1234UserFormusername:CharField -&gt; label:Username size:25;email:EmailField -&gt; size:32;password:PasswordField; 下面我们使用pyparsing库，来制作一款属于自己的DSL语言 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899from pyparsing import Word, OneOrMore, Group, Suppress, alphanums, oneOf, alphas, Optional, lineEnddef convert_prop_to_dict(tokens): prop_dict = &#123;&#125; for token in tokens: prop_dict[token[0]] = token[1] return prop_dict# Suppress 表示不捕获newline = Suppress(lineEnd)colon = Suppress(":")arrow = Suppress("-&gt;")semicolon = Suppress(";")word = Word(alphas)key = wordvalue = Word(alphanums)field_type = oneOf("CharField EmailField PasswordField")field_name = wordform_name = word.setResultsName("form_name")field_property = Group(key + colon + value)field = Group(field_name + colon + field_type + Optional(arrow + OneOrMore(field_property) + semicolon).setParseAction( convert_prop_to_dict))form = form_name + newline + OneOrMore(field).setResultsName("form_field")input_form = '''UserFormusername:CharField -&gt; label:Username size:25;email:EmailField -&gt; size:32;password:PasswordField;''''''External DSL'''def get_field_html(field): properties = field[2] label = properties["label"] if "label" in properties else field[0] label_html = "&lt;label&gt;" + label + "&lt;/label&gt;" attributes = &#123;"name": field[0]&#125; attributes.update(properties) if field[1] == "CharField" or field[1] == "EmailField": attributes["type"] = "text" else: attributes["type"] = "password" if "label" in attributes: del attributes["label"] attributes_html = " ".join([name + "='" + value + "'" for name, value in attributes.items()]) field_html = "&lt;input " + attributes_html + "/&gt;" return label_html + field_html + "&lt;br/&gt;"def render(form): fields_html = "".join([get_field_html(field) for field in form.form_field]) return "&lt;form id='" + form.form_name.lower() + "'&gt;" + fields_html + "&lt;/form&gt;"print(render(form.parseString(input_form)))'''Internal DSL'''class HtmlElement(object): default_attributes = &#123;&#125; tag = "unknown_tag" def __init__(self, *args, **kwargs): self.attributes = kwargs self.attributes.update(self.default_attributes) self.children = args def __str__(self): attribute_html = " ".join(["&#123;&#125;='&#123;&#125;'".format(name, value) for name, value in self.attributes.items()]) if not self.children: return "&lt;&#123;&#125; &#123;&#125;/&gt;".format(self.tag, attribute_html) else: children_html = "".join([str(child) for child in self.children]) return "&lt;&#123;&#125; &#123;&#125;&gt;&#123;&#125;&lt;/&#123;&#125;&gt;".format(self.tag, attribute_html, children_html, self.tag)# print(HtmlElement(id="test"))# &lt;unknown_tag id='test'/&gt;# print (HtmlElement(HtmlElement(name="test"), id="id"))# &lt;unknown_tag id='id'&gt;&lt;unknown_tag name='test'/&gt;&lt;/unknown_tag&gt;class InputElement(HtmlElement): tag = "input" def __init__(self, *args, **kwargs): HtmlElement.__init__(self, *args, **kwargs) self.label = self.attributes["label"] if "label" in self.attributes else self.attributes["name"] if "label" in self.attributes: del self.attributes["label"] def __str__(self): label_html = "&lt;label&gt;&#123;&#125;&lt;/label&gt;".format(self.label) return label_html + HtmlElement.__str__(self) + "&lt;br/&gt;"# print(InputElement(name="username"))# &lt;label&gt;username&lt;/label&gt;&lt;input name='username'/&gt;&lt;br/&gt;# print(InputElement(name="username", label="User ID"))# &lt;label&gt;User ID&lt;/label&gt;&lt;input name='username'/&gt;&lt;br/&gt;class Form(HtmlElement): tag = "form"class CharField(InputElement): default_attributes = &#123;"type": "text"&#125;class EmailField(CharField): passclass PasswordField(InputElement): default_attributes = &#123;"type": "password"&#125;def render(form): field_dict = &#123;"CharField": CharField, "EmailField": EmailField, "PasswordField": PasswordField&#125; fields = [field_dict[field[1]](name=field[0], **field[2]) for field in form.form_field] return Form(*fields, id=form.form_name.lower())print(render(form.parseString(input_form)))]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python设计模式——单例模式]]></title>
    <url>%2F2016%2F10%2F13%2F772%2F</url>
    <content type="text"><![CDATA[定义Singleton provides you with a mechanism to have one, and only one, object of a given type and provides a global point of access.单例模式常用与logging或者database operations等。他们都只需要一个实例来操作从而避免冲突 UML 实现代码普通版1234567891011121314151617181920212223242526272829# coding:utf-8class Singleton(object): def __new__(cls): if not hasattr(cls, 'instance'): cls.instance = super(Singleton, cls).__new__(cls) return cls.instances = Singleton()print("Object created", s)s1 = Singleton()print("Object created", s1)Object created &lt;__main__.Singleton object at 0x000001B2A199A630&gt;Object created &lt;__main__.Singleton object at 0x000001B2A199A630&gt;#### Lazy instantiation版class Singleton: __instance = None def __init__(self): if not Singleton.__instance: print(" __init__ method called..") else: print("Instance already created:", self.getInstance()) @classmethod def getInstance(cls): if not cls.__instance: cls.__instance = Singleton() return cls.__instance# s = Singleton.getInstance()# print("Object created", s)# s1 = Singleton.getInstance()# print("Object created", s1) The Monostate Singleton pattern123456789101112131415161718192021222324'''单例模式要求每一个类只有一个实例，通常来说，我们更需要的是所有实例都共享同一个状态Python中使用__dict__去存储对象的所有状态'''class Borg: __shared_state = &#123;"1": "2"&#125; def __init__(self): self.x = 1 self.__dict__ = self.__shared_state pass# 我们也可以在__new__中调整class Borg(object): _shared_state = &#123;&#125; def __new__(cls, *args, **kwargs): obj = super(Borg, cls).__new__(cls, *args, **kwargs) obj.__dict__ = cls._shared_state return obj# b = Borg()# b1 = Borg()# b.x = 4# print("Borg Object 'b': ", b) ## b and b1 are distinct objects# print("Borg Object 'b1': ", b1)# print("Object State 'b':", b.__dict__) ## b and b1 share same state# print("Object State 'b1':", b1.__dict__) 单例模式与元类12345678910111213141516171819202122'''元类是类的类(a class of a class)，这意味着类是元类的实例Python里面万物皆对象。a=5,type(a) 返回 &lt;type 'int'&gt; 意味着 a 是int类型type(int) 返回 &lt;type 'type'&gt; 意味着 int 是type类型我们可以用type生成一个类A = type(name, bases, dict)name：生成的类名bases：基类dict：类的字典，各种属性等'''class MetaSingleton(type): _instances = &#123;&#125; def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(MetaSingleton, cls).__call__(*args, **kwargs) return cls._instances[cls]class Logger(metaclass=MetaSingleton): pass# logger1 = Logger()# logger2 = Logger()# print(logger1, logger2) 关于元类，可以参考关于Python中的元类(metaclass) 实战服务器应用就是一个很好的例子大量的连接只需要一个实例，节省内存防止冲突123456789101112131415161718import sqlite3class MetaSingleton(type): _instances = &#123;&#125; def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(MetaSingleton, cls).__call__(*args, **kwargs) return cls._instances[cls]class Database(metaclass=MetaSingleton): connection = None def connect(self): if self.connection is None: self.connection = sqlite3.connect("db.sqlite3") self.cursorobj = self.connection.cursor() return self.cursorobjdb1 = Database().connect()db2 = Database().connect()print("Database Objects DB1", db1)print("Database Objects DB2", db2) 优点 内存中只有一个实例，减少内存开支（Ensuring that one and only one object of the class gets created） 避免资源的多重占用（Controlling concurrent access to resources that are shared） 可以在系统设置全局的访问点（Providing an access point for an object that is global to the program） 缺点 单例模式一般没有接口，扩展很困难。 所有类都依赖于一个实例耦合紧。 与单一性职责原则冲突。 使用场景 要求生成唯一序列号的环境 在整个项目中需要一个共享访问点或共享数据 创建一个对象需要消耗的资源过多 需要定义大量的静态常量和静态方法的环境 在多线程的情况下，单例模式是线程不安全的。必须进行改进。 在Python中所有的模块都是单例的。 Python中导入import步骤如下 检查是否已经导入 如果已经导入，返回该模块的实例(object for the module)。如果没有，导入并实例化它(imports and instantiates it)]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-3树（Python实现）]]></title>
    <url>%2F2016%2F10%2F12%2F758%2F</url>
    <content type="text"><![CDATA[我们希望该树的高度能够维持在 lgN 左右，这样我们就能保证只需要lgN次比较操作就可以查找到想要的值。不幸的是，每次插入元素之后维持树的平衡状态太昂贵。 其中的每一个结点都具有一个或两个key，两个孩子或三个孩子一个2结点包含一个key和两个孩子（或没有孩子）。要么就有两个，不能只有一个孩子。左子树包含小于较小元素的元素，右子树包含大于较大元素的元素一个3结点包含一小一大两个key和三个孩子（或没有孩子）。要么就有三个，如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素 查找 插入­首先要进行查找，然后将节点挂到未找到的节点上。2-3树之所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。 插入2-node结点如果查找后未找到的节点是一个2-node节点，那么很容易，我们只需要将新的元素放到这个2-node节点里面使其变成一个3-node节点即可。 分割叶节点往一个3-node节点插入一个新的节点可能会遇到很多种不同的情况 关于结点的上移 节点是3-node，父节点是2-node 节点是3-node，父节点也是3-node 根结点分离上移 当根节点到字节点都是3-node节点的时候，这是如果我们要在字节点插入新的元素的时候，会一直查分到跟节点，在最后一步的时候，跟节点变成了一个4-node节点，这个时候，就需要将跟节点查分为两个2-node节点，树的高度加1­完全平衡的2-3查找树如下图，每个根节点到叶子节点的距离是相同的： 2-3树的查找效率与树的高度是息息相关的。•在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN•在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN­距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。下面是2-3查找树的效率： 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119# coding:utf-8class Node(object): def __init__(self, key): self.key1 = key self.key2 = None self.left = None self.middle = None self.right = None def isLeaf(self): return self.left is None and self.middle is None and self.right is None def isFull(self): return self.key2 is not None def hasKey(self, key): if (self.key1 == key) or (self.key2 is not None and self.key2 == key): return True else: return False def getChild(self, key): if key &lt; self.key1: return self.left elif self.key2 is None: return self.middle elif key &lt; self.key2: return self.middle else: return self.rightclass two_three_Tree(object): def __init__(self): self.root = None def get(self, key): if self.root is None: return None else: return self._get(self.root, key) def _get(self, node, key): if node is None: return None elif node.hasKey(key): return node else: child = node.getChild(key) return self._get(child, key) def put(self, key): if self.root is None: self.root = Node(key) else: pKey, pRef = self._put(self.root, key) if pKey is not None: newnode = Node(pKey) newnode.left = self.root newnode.middle = pRef self.root = newnode def _put(self, node, key): # 不重复的key if node.hasKey(key): return None, None # 叶节点，直接插入 elif node.isLeaf(): return self._addtoNode(node, key, None) # 遍历子树，直到遇到叶节点 else: child = node.getChild(key) pKey, pRef = self._put(child, key) # 有 pKey, pRef 表示进行了分割 # pKey 表示往上移的key # pRef 表示newnode # 每次 _addtoNode 到一个 3-Node的时候,肯定会有pKey和pRef(因为需要分割上移) if pKey is None: return None, None else: return self._addtoNode(node, pKey, pRef) def _addtoNode(self, node, key, pRef): # 3-Node，分割 if node.isFull(): return self._splitNode(node, key, pRef) # 2-Node else: # 放入该node的左边 if key &lt; node.key1: node.key2 = node.key1 node.key1 = key # 如果该node有子树 if pRef is not None: node.right = node.middle node.middle = pRef else: node.key2 = key if pRef is not None: node.right = pRef # pKey, pRef return None, None def _splitNode(self, node, key, pRef): # 这是难点,请对照插入的图例,认真学习 newnode = Node(None) if key &lt; node.key1: # x是最小的key，把key1移上去 pKey = node.key1 node.key1 = key newnode.key1 = node.key2 if pRef is not None: newnode.left = node.middle newnode.middle = node.right node.middle = pRef elif key &lt; node.key2: # x是中间的key,把自己移上去 pKey = key newnode.key1 = node.key2 if pRef is not None: newnode.left = pRef newnode.middle = node.right else: # x是最大的key,把key2 pKey = node.key2 newnode.key1 = key if pRef is not None: newnode.left = node.right newnode.middle = pRef node.key2 = None return pKey, newnode]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——换钱的最少货币数]]></title>
    <url>%2F2016%2F10%2F12%2F756%2F</url>
    <content type="text"><![CDATA[换钱的最少货币数问题1：使用数组arr中的值代表一种面值的货币，每种面值的货币可以使用任意张，组成aim值，求使用货币素的最小张数 问题2:问题1的基础上，数组arr中的货币不是无限使用的，用完就没有。arr = [2, 3, 5]aim = 201234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677'''问题1:dp[i][j]的含义，在可以任意使用arr[0...i]货币的情况下，组成j所需的最小张数假设计算到位置(i,j),dp[i][j]的值可能来自下面的情况1.完全不使用当前货币arr[i]的情况下的最少张数,即dp[i-1][j]2.使用1张货币arr[i]的情况下的最少张数,即dp[i-1][j-arr[i]]+13.使用2张货币arr[i]的情况下的最少张数,即dp[i-1][j-2*arr[i]]+24.使用3张货币arr[i]的情况下的最少张数,即dp[i-1][j-3*arr[i]]+3dp[i][j] = min(dp[i-1][j], dp[i][j-arr[i]]+1)位置i,j依赖位置(i-1,j)，即往上跳一下的位置，也依赖位置(i,j-arr[i])，即往左跳一下的位置时间复杂度，空间复杂度O(N*aim)'''def minCoins1(arr, aim): n = len(arr) inf = float('inf') dp = [[0] * (aim + 1) for i in range(n)] # 初始化第一行 for j in range(1, aim + 1): dp[0][j] = inf if j - arr[0] &gt;= 0 and dp[0][j - arr[0]] != inf: dp[0][j] = dp[0][j - arr[0]] + 1 for i in range(1, n): for j in range(1, aim + 1): # j = (j - arr[i]) + arr[i] # 注意到j - arr[i]位置上(j - arr[i]元)，必须不为inf（即，可以用arr[0~i]货币找开) left = dp[i][j - arr[i]] + 1 \ if j - arr[i] &gt;= 0 and dp[i][j - arr[i]] != inf \ else inf # 左边跟上边(用arr[0~i-1]货币找开)比 dp[i][j] = min(left, dp[i - 1][j]) return dp[n - 1][aim] if dp[n - 1][aim] != inf else -1# 空间压缩def minCoins2(arr, aim): n = len(arr) inf = float('inf') dp = [0] * (aim + 1) for j in range(1, aim + 1): dp[j] = inf if j - arr[0] &gt;= 0 and dp[j - arr[0]] != inf: dp[j] = dp[j - arr[0]] + 1 for i in range(1, n): for j in range(1, aim + 1): left = dp[j - arr[i]] + 1 \ if j - arr[i] &gt;= 0 and dp[j - arr[i]] != inf \ else inf # (i,j)的左边(j-arr[i])跟上面(i-1,j)比较 dp[j] = min(left, dp[j]) return dp[aim] if dp[aim] != inf else -1'''问题2dp[i][j]的含义，在可以任意使用arr[0...i]货币的情况下（每个值权代表一张货币），组成j所需的最小张数如，dp[0][0...aim]，表示只能使用一张arr[0]货币的情况下，找某个钱数的最小张数。假设计算到位置(i,j),dp[i][j]的值可能来自下面的情况1.上边，对于dp[i-1][j]表示，任意使用arr[0...i-1]货币的情况下，组成j所需的最小张数，dp[i][j]可能与其相等2.左上边，因为arr[i]只有一张不能重复，我们考虑dp[i-1][j-arr[i]],表示在可以任意使用arr[0...i-1]货币的情况下，组成j-arr[i]所需的最小张数。所以dp[i][j]=dp[i-1][j-arr[i]]+1注意，本题不能像minCoins2那样使用空间压缩。因为在dp[j - arr[i]]的使用，可能已经使用了当前的货币i如，本题的例子在i=2,j=6的时候 dp[6]，其dp[j - arr[i]]=dp[3]=1，已经使用过了货币3。所以无法重复使用。'''def minCoins3(arr, aim): n = len(arr) inf = float('inf') dp = [[0] * (aim + 1) for i in range(n)] # 第0行的初始化，除了使用货币自身(arr[0])，其他都为inf for j in range(1, aim + 1): dp[0][j] = inf if arr[0] &lt;= aim: dp[0][arr[0]] = 1 for i in range(1, n): for j in range(1, aim + 1): leftup = dp[i - 1][j - arr[i]] + 1 \ if j - arr[i] &gt;= 0 and dp[i - 1][j - arr[i]] != inf \ else inf dp[i][j] = min(leftup, dp[i - 1][j]) return dp[n - 1][aim] if dp[n - 1][aim] != inf else -1]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——年终奖（旧题新做）]]></title>
    <url>%2F2016%2F10%2F11%2F751%2F</url>
    <content type="text"><![CDATA[小东所在公司要发年终奖，而小东恰好获得了最高福利，他要在公司年会上参与一个抽奖游戏，游戏在一个6*6的棋盘上进行，上面放着36个价值不等的礼物，每个小的棋盘上面放置着一个礼物，他需要从左上角开始游戏，每次只能向下或者向右移动一步，到达右下角停止，一路上的格子里的礼物小东都能拿到，请设计一个算法使小东拿到价值最高的礼物。给定一个6*6的矩阵board，其中每个元素为对应格子的礼物价值,左上角为[0,0],请返回能获得的最大价值，保证每个礼物价值大于100小于1000。12345678910111213141516171819202122232425# coding:utf-8test = [ [1, 3, 5, 9], [8, 1, 3, 4], [5, 0, 6, 1], [8, 8, 4, 0]]def getMost(border): each_path = [] col = len(border[0]) row = len(border) def most_momey(i=0, j=0, the_sum=0): # 向右走 if j &lt; col - 1: most_momey(i, j + 1, border[i][j] + the_sum) # 向左走 if i &lt; row - 1: most_momey(i + 1, j, border[i][j] + the_sum) # 到达右下角 if i == row - 1 and j == col - 1: each_path.append(the_sum + border[i][j]) else: return most_momey() return max(each_path) 动态规划求解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162'''根据题意，从(0,0)到(i,j)的路径必然经过位置(i-1,j)或(i,j-1)。dp[n][m] = max(dp[n - 1][m], dp[n][m - 1]) + border[n][m]的含义也就是比较从(0,0)位置开始，经过(i-1,j)位置最终到达(i,j)的最大路径和经过(i,j-1)位置最终到达(i,j)的最大路径之间，哪条路径的路径和最大就题目中的例子，我们先生成第一行和第一列的dp，也就是1 4 9 1891422然后从(1,1)开始，计算从(0,0)到自己的最大路径和，计算的时候只是比较上边和左边哪个最大。时间复杂度O(M*N)，空间复杂度O(M*N)'''def getMost_dp(border): col = len(border[0]) row = len(border) # dp标识走到(i,j)位置的最大路径和 dp = [[0] * col for i in range(row)] dp[0][0] = border[0][0] # 求出dp[0][1]-dp[0][col] for i in range(1, col): dp[0][i] = dp[0][i - 1] + border[0][i] # 求出dp[1][0]-dp[row][0] for j in range(1, row): dp[j][0] = dp[j - 1][0] + border[j][0] for n in range(1, row): for m in range(1, col): dp[n][m] = max(dp[n - 1][m], dp[n][m - 1]) + border[n][m] return dp[row - 1][col - 1]# print getMost_dp(test)'''空间压缩上述的代码，空间复杂度为O(M*N)，我们还可以对其进行空间压缩，使复杂度降到O(min&#123;M,N&#125;)就上面的例子，我们先生成一个arr[min(rol,row)]数组。在这个例子里面是arr[4]我们根据row和col的数量进行滚动，row多的话，向下滚动；否则向右滚动。我们这里向下滚动。所以求出arr[i] = arr[i - 1] + border[0][i] = [1,4,9,18]然后我们向下滚动i=1。arr[0] = arr[0] + border[i][0] = 9arr[1] = max(arr[1 - 1], arr[1]) + border[i][1] # arr[1 - 1], arr[1]分别代表border[i][1]的左边和上边arr[2] = max(arr[2 - 1], arr[1]) + border[i][2]....arr[j] = max(arr[j - 1], arr[j]) + border[i][j]没有优化之前，取得某个位置动态规划值的过程是在矩阵中进行两次寻址，优化后，这一过程只需要一次寻址。'''def getMost_dp2(border): col = len(border[0]) row = len(border) more = max(col, row) less = min(col, row) rowmore = bool(more == len(border)) arr = [0] * less arr[0] = border[0][0] # row多的话，向下滚动；否则向右滚动 for i in range(1, less): arr[i] = arr[i - 1] + border[0][i] if rowmore else border[i][0] for i in range(1, more): arr[0] = arr[0] + border[i][0] if rowmore else border[0][i] for j in range(1, less): arr[j] = max(arr[j - 1], arr[j]) + border[i][j] if rowmore else border[j][i] return arr[less-1]]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BST树（Python实现）]]></title>
    <url>%2F2016%2F10%2F10%2F747%2F</url>
    <content type="text"><![CDATA[BST树，又称为二叉排序树Binart Sort Tree○ 若左子树不空，则左子树上所有结点的值均小于它的根结点的值○ 若右子树不空，则右子树上所有结点的值均大于它的根结点的值○ 它的左右子树也为二叉排序树 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# coding:utf-8class BinarySearchTree: def __init__(self): self.root = None self.size = 0 def length(self): return self.size def __len__(self): return self.size def __setitem__(self, k, v): self.put(k, v) def __getitem__(self, key): return self.get(key) def __contains__(self, key): if self._get(key, self.root): return True else: return False def put(self, key, val): if self.root: self._put(key, val, self.root) # 空树 else: self.root = TreeNode(key, val) self.size = self.size + 1 def _put(self, key, val, currentNode): # 左子树 if key &lt; currentNode.key: if currentNode.hasLeftChild(): self._put(key, val, currentNode.leftChild) else: currentNode.leftChild = TreeNode(key, val, parent=currentNode) # 右子树 else: if currentNode.hasRightChild(): self._put(key, val, currentNode.rightChild) else: currentNode.rightChild = TreeNode(key, val, parent=currentNode) def get(self, key): if self.root: res = self._get(key, self.root) if res: return res.payload else: return None else: return None def _get(self, key, currentNode): if not currentNode: return None elif currentNode.key == key: return currentNode elif key &lt; currentNode.key: return self._get(key, currentNode.leftChild) else: return self._get(key, currentNode.rightChild)class TreeNode: def __init__(self, key, val, left=None, right=None, parent=None): self.key = key self.payload = val self.leftChild = left self.rightChild = right self.parent = parent def hasLeftChild(self): return self.leftChild def hasRightChild(self): return self.rightChild def isLeftChild(self): return self.parent and self.parent.leftChild == self def isRightChild(self): return self.parent and self.parent.rightChild == self def isRoot(self): return not self.parent def isLeaf(self): return not (self.rightChild or self.leftChild) def hasAnyChildren(self): return self.rightChild or self.leftChild def hasBothChildren(self): return self.rightChild and self.leftChild def replaceNodeData(self, key, value, lc, rc): self.key = key self.payload = value self.leftChild = lc self.rightChild = rc if self.hasLeftChild(): self.leftChild.parent = self if self.hasRightChild(): self.rightChild.parent = selfif __name__ == '__main__': tree = BinarySearchTree() for k, v in zip(range(ord('a'), ord('a') + 10), [62, 58, 88, 47, 73, 99, 35, 51, 93, 37]): tree.put(v, chr(k)) print tree[88] 复杂度最坏复杂度为O(n),最好为O(1)]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序]]></title>
    <url>%2F2016%2F10%2F10%2F744%2F</url>
    <content type="text"><![CDATA[实现代码123456789101112131415161718192021222324252627282930313233343536373839404142a, b, c, d, e, f, g, h = ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h')G = &#123; a: [b, f], b: [c, d, f], c: [d], d: [e, f], e: [f], f: []&#125;def res_topsort(G, S=None): # S是当前规模各个点的集合 if S is None: S = set(G) if len(S) == 1: return list(S) # 随意出一点 v = S.pop() seq = res_topsort(G, S) min_i = 0 # 找出以v点为出边的是哪一元素，将其插入该元素后，如无，插入开头 # 规模从小到大，每一次return 的 seq都是一个DAG for i, u in enumerate(seq): if v in G[u]: min_i = i + 1 seq.insert(min_i, v) return seqdef topsort(G): count = dict((u, 0) for u in G) for u in G: for v in G[u]: count[v] += 1 Q = [u for u in G if count[u] == 0] S = [] while Q: u = Q.pop() # 将没有入边的节点插入 S.append(u) # 每出一条边 减少 该没有入边的节点指向的节点 的入边 for v in G[u]: count[v] -= 1 if count[v] == 0: Q.append(v) return Sprint res_topsort(G)# ['a', 'b', 'c', 'd', 'e', 'f'] 复杂度求各顶点入度的时间复杂度是O(e)，即边的个数。建零入度顶点栈的时间复杂度是O(n)，即顶点的个数。每个顶点都需要进一次栈，出一次栈，然后把入度减一。执行的总次数也是边的个数。所以时间复杂度是O(n+e)。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈Kruskal与Prim这两种最小生成树算法（Python实现）]]></title>
    <url>%2F2016%2F10%2F10%2F732%2F</url>
    <content type="text"><![CDATA[何为最小生成树建立无导向图，使得这些点可以相互连通，并使得总权值最小。如： Kruskal分析定理：任何不包含最短边的数结构都还可以被做得更小，最小生成树中一定会包含最短边。先对图中的边进行排序，然后着手选取。对于每一条边，我们都会通过遍历来确定其对应的树结构上是否存在着从u到v的路径。如果存在，我们就将其丢弃。然后每次选取最小的边。直到无边可选。根据权值排序 起点 终点 权值 1 2 1 1 3 2 4 6 3 5 6 4 2 3 6 4 5 7 3 4 9 2 4 11 3 5 13 对于2 3 6这条边，如果加上这条边就会形成回路。所以跳过 最后选用3 4 9这条边。我们已经选用了n-1条边，图已连通。 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152G = &#123; 0:&#123;&#125;, 1: &#123;1: 1, 2: 2&#125;, 2: &#123;1: 1, 3: 6, 4: 11&#125;, 3: &#123;1: 2, 2: 6, 4: 9, 5: 13&#125;, 4: &#123;2: 11, 3: 9, 5: 7, 6: 3&#125;, 5: &#123;3: 13, 4: 7, 6: 4&#125;, 6: &#123;4: 3, 5: 4&#125;,&#125;'''Kruskal算法各种变量：C：形如&#123;u1:v1,u2:v2,....&#125;的字典，主要用来寻找代表节点(祖先节点)。初始化，v1=u1,v2=u2....如a-b-c-d &#123;a:a,b:a,c:b,d:c&#125;G：图E：列表，存放着形如(e,u,v)的字典，e：权值，u：源点，v：目标点'''def find(C, u): '''寻找代表节点(祖先节点)这里使用的是路径压缩的方法（path compression）''' if C[u] != u: C[u] = find(C, C[u]) return C[u]def naive_union(C, u, v): '''把较小的指向较大的''' u, v = find(C, u), find(C, v) # u的祖先节点指向v的祖先节点 C[u] = vdef kruskal(G): E = [(G[u][v], u, v) for u, _ in enumerate(G) for v in G[u]] T = set() C = &#123;u: u for u, _ in enumerate(G)&#125; for _, u, v in sorted(E): if find(C, u) != find(C, v): # 边的源点的祖先不等于边的目的祖先（因为相等的话说明该点已经添加过了，否则为默认值） T.add((u, v)) # 添加 naive_union(C, u, v) # 合并，使目标节点变成生成树的一部分（修改其祖先）。 return T,C# ------测试结果---------sum_count = 0T = kruskal(G)for k, v in T: sum_count += G[k][v]print(sum_count)print(sorted([i for i in T], key=lambda x: x[1]))# 结果为19# [(1, 2), (1, 3), (3, 4), (5, 6), (4, 6)]# 以下为完成后的中间变量，便于理解# C=&#123;0: 0, 1: 3, 2: 6, 3: 6, 4: 6, 5: 6, 6: 6&#125; Prim分析从某个起始节点开始对目标图结构进行遍历，并始终将最短的连接边加入到相应的树结构中。说白了Prim算法就是另一种遍历型算法而已，遍历型算法之间的主要区别在于“待定”列表中的顺序。在那些已被发现但没被访问的节点中，究竟哪一个是我们接下来要加入到遍历树种的节点。在Prim算法中，我们将会采用堆结构来实现一个优先级队列。使得每次都pop权值最小的边如果pop出的边的目的点已经在生成树里，便抛弃。否则便加入（注意：每次pop的都是权值最小的边）我们可以任意选取一个顶点，然后看看它的边中哪一个最短的。 先从1开始，1-2=1；1-3=2。选取1-2 连通1,2之后，再从1,2开始找。1-3=2；2-3=6；2-4=11。选取1-3=2。如此类推 12345678910111213141516171819def prim(G, s): P, Q = &#123;&#125;, [(0, None, s)] while Q: w, p, u = heappop(Q) if u in P: continue # 如果目标点在生成树中，跳过 P[u] = p # 记录目标点不在生成树中 for v, w in G[u].items(): heappush(Q, (w, u, v)) # 将u点的出边入堆 return P# T = prim(G, 1)# sum_count = 0# for k, v in T.items():# if v !=None:# sum_count += G[k][v]## print(sum_count)# print(T)# 结果为19# &#123;1: None, 2: 1, 3: 1, 4: 3, 5: 6, 6: 4&#125; Kruskal算法与prim算法两个算法都使用了贪心的策略。 prim 算法是某个起始节点开始对目标图结构进行遍历，将其所有的出边加入到最小堆里面 pop一条出边（每次pop的都是权值最小的边），然后判断这条边的目标点在生成树中 如果是就丢弃 不是就更新生成树Kruskal 算法是将图中的边根据权值进行排序后从小到大遍历 判断边的源点的祖先不等于边的目的祖先 如果是就丢弃 不是就加入 然后更新生成树Kruskal算法与prim算法的结果相反的原因Kruskal算法：[(1, 2), (1, 3), (3, 4), (5, 6), (4, 6)]prim算法：{1: None, 2: 1, 3: 1, 4: 3, 5: 6, 6: 4}Kruskal算法记录的是从开始点到结束点的路径，1-2,1-3-4-6,5-6 关键代码：T.add((u,v))prim算法记录的是从结束点到开始点的路径，5-6-4-3-1,2-1 关键代码：P[u]=p]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[select与epoll]]></title>
    <url>%2F2016%2F10%2F09%2F730%2F</url>
    <content type="text"><![CDATA[select和epoll这两个机制都是多路I/O机制的解决方案，select为POSIX标准中的，而epoll为Linux所特有的。epoll的最大好处是不会随着FD的数目增长而降低效率，在select中采用轮询处理，其中的数据结构类似一个数组的数据结构，而epoll是维护一个队列，直接看队列是不是空就可以了。nginx就是使用epoll来实现I/O复用支持高并发，目前在高并 发的场景下，nginx越来越收到欢迎。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制 epoll:(1)IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数;(2)支持电平触发和边沿触发（只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发）两种方式，理论上边缘触发的性能要更高一些，但是代码实现相当复杂。(3)有着良好的就绪事件通知机制 select:(1)单个进程可监视的fd数量受到了限制，在32位机器上，他所能管理的fd数量最大为1024;(2)对socket进行扫描时是线性扫描，当socket文件描述符数量变多时，大量的时间是被白白浪费掉的。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——树上最长单色路径]]></title>
    <url>%2F2016%2F10%2F08%2F727%2F</url>
    <content type="text"><![CDATA[对于一棵由黑白点组成的二叉树，我们需要找到其中最长的单色简单路径，其中简单路径的定义是从树上的某点开始沿树边走不重复的点到树上的另一点结束而形成的路径，而路径的长度就是经过的点的数量(包括起点和终点)。而这里我们所说的单色路径自然就是只经过一种颜色的点的路径。你需要找到这棵树上最长的单色路径。 给定一棵二叉树的根节点(树的点数小于等于300，请做到O(n)的复杂度)，请返回最长单色路径的长度。这里的节点颜色由点上的权值表示，权值为1的是黑点，为0的是白点。 1234567891011121314151617181920212223242526272829303132class Node: def __init__(self, value=None, left=None, right=None): self.val = value self.left = left self.right = right# TREE = Node(0,# Node(1, Node(1), Node(0)),# Node(0, Node(0), Node(1))# )TREE = Node(0, Node(1, Node(0, Node(1, Node(1))), Node(0)), Node(1, Node(0), Node(0)) )def func(root): B_res, W_res = [], [] def res(root, W, B): if root == None: B_res.append(B) W_res.append(W) return if root.val == 0: W += 1 B_res.append(B) B = 0 elif root.val == 1: B += 1 W_res.append(W) W = 0 res(root.left, W, B) res(root.right, W, B) res(root, 0, 0) return max(max(B_res), max(W_res)) 来自“一战通offer”互联网实习季编程挑战]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——地域划分]]></title>
    <url>%2F2016%2F10%2F08%2F725%2F</url>
    <content type="text"><![CDATA[现在有一块长条形的土地，这个土地我们可以看成是由n块小方格连接而成的(这些小方格我们可以将之编号为1到n)。而我们需要将其划分成两个部分，分别种上不同的作物(即作物A和B)，划分必须在某两个小方格之间进行，或者在土地的最左端或最右端，若划分在第i块到第i+1块间进行，则划分后，第1至第i块地种A，剩下的地种B。现在有一些专家对土地进行了检测，他们每个人评估了每块土地适合种的作物。请你找到一个合适的划分，使得其与所有专家的评估最吻合，也就是说，你划分到A而专家评估为B的次数和你划分到B而专家评估为A的次数之和最小。 输入描述:每组数据给定一个专家评估表land(其中0为评估A，1为评估B)，以及小块数量n(1≤n≤300)，专家评估次数m(1≤m≤300)输出描述:请返回你的划分,即i和i+1。若在最左端，则输出0，1；在最右端则输出n,n+1。若有多解输出最靠左的划分。 输入例子:[[1,1,1,1],[0,0,0,0],[1,0,1,1]],4,3输出例子:[0,1] 12345678def func(land, n, m): l = [0] * n # 求权值 for i in range(n): for j in range(m): l[i] += 1 if land[j][i] == 1 else -1 result = [sum(l[i:]) - sum(l[:i]) for i in range(n + 1)] return result.index(max(result)), result.index(max(result)) + 1 来自“一战通offer”互联网实习季编程挑战]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习OpenCV——Python：人脸检测]]></title>
    <url>%2F2016%2F10%2F06%2F712%2F</url>
    <content type="text"><![CDATA[人脸检测一种主流的方法就是类haar+adaboosting，opencv中也是用的这种方法。这种方法可以推广到刚性物体的检测，前提是要训练好级联分类器(比如说用类haar特征)，一旦训练数据弄好了，直接调用opencv中的类CascadeClassifier，用它的几个简单的成员函数就可以完成检测功能。 Haar分类器的概念以 Haar 特征分类器为基础的对象检测技术是一种非常有效的对象检测技术（2001 年 Paul_Viola 和 Michael_Jones 提出）。它是基于机器学习的， 通过使用大量的正负样本图像训练得到一个 cascade_function，最后再用它 来做对象检测。 现在我们来学习面部检测。开始时，算法需要大量的正样本图像（面部图像）和负样本图像（不含面部的图像）来训练分类器。我们需要从其中提取特 征。下图中的 Haar 特征会被使用。它们就像我们的卷积核。每一个特征是一 个值，这个值等于黑色矩形中的像素值之后减去白色矩形中的像素值之和。 使用所有可能的核来计算足够多的特征。（想象一下这需要多少计算量？仅仅是一个 24x24 的窗口就有 160000 个特征）。对于每一个特征的计算我们 好需要计算白色和黑色矩形内的像素和。为了解决这个问题，作者引入了积分 图像，这可以大大的简化求和运算，对于任何一个区域的像素和只需要对积分 图像上的四个像素操作即可。非常漂亮，它可以使运算速度飞快但是在我们计算得到的所有的这些特征中，大多数是不相关的。如下图所示。上边一行显示了两个好的特征，第一个特征看上去是对眼部周围区域的描述，因为眼睛总是比鼻子黑一些。第二个特征是描述的是眼睛比鼻梁要黑一些。但是如果把这两个窗口放到脸颊的话，就一点都不相关。那么我们怎样从超过 160000+ 个特征中选出最好的特征呢？使用 Adaboost。 为了达到这个目的，我们将每一个特征应用于所有的训练图像。对于每一个特征，我们要找到它能够区分出正样本和负样本的最佳阈值。但是很明显， 这会产生错误或者错误分类。我们要选取错误率最低的特征，这说明它们是检测面部和非面部图像最好的特征。（这个过程其实不像我们说的这么简单。在开始时每一张图像都具有相同的权重，每一次分类之后，被错分的图像的权重会增大。同样的过程会被再做一遍。然后我们又得到新的错误率和新的权重。重复执行这个过程知道到达要求的准确率或者错误率或者要求数目的特征找到）。 最终的分类器是这些弱分类器的加权和。之所以成为弱分类器是应为只是用这些分类器不足以对图像进行分类，但是与其他的分类器联合起来就是一个 很强的分类器了。文章中说 200 个特征就能够提供 95% 的准确度了。他们最 后使用 6000 个特征。（从 160000 减到 6000，效果显著呀！）。 现在你有一幅图像，对每一个 24x24 的窗口使用这 6000 个特征来做检查，看它是不是面部。这是不是很低效很耗时呢？的确如此，但作者有更好的 解决方法。 在一副图像中大多数区域是非面部区域。所以最好有一个简单的方法来证明这个窗口不是面部区域，如果不是就直接抛弃，不用对它再做处理。而不是 集中在研究这个区域是不是面部。按照这种方法我们可以在可能是面部的区域多花点时间。 为了达到这个目的作者提出了级联分类器的概念。不是在一开始就对窗口进行这 6000 个特征测试，将这些特征分成不同组。在不同的分类阶段逐个使 用。（通常前面很少的几个阶段使用较少的特征检测）。如果一个窗口第一阶段 的检测都过不了就可以直接放弃后面的测试了，如果它通过了就进入第二阶段 的检测。如果一个窗口经过了所有的测试，那么这个窗口就被认为是面部区域。 这个计划是不是很帅！！！ 作者将 6000 多个特征分为 38 个阶段，前五个阶段的特征数分别为 1，10，25，25 和 50。（上图中的两个特征其实就是从 Adaboost 获得的最好 特征）。 Haar级联器的数据OpenCV的源码sources\data\haarcascades复制到你的工程 静态图像人脸检测1234567891011121314151617# coding:utf-8import cv2filename = './img/face.jpg'def detect(filename): # 级联分类器 face_cascade = cv2.CascadeClassifier( './cascades/haarcascade_frontalface_default.xml') img = cv2.imread(filename) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = face_cascade.detectMultiScale(gray, 1.3, 5) # 绘制矩形 for (x, y, w, h) in faces: img = cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2) cv2.namedWindow('Vikings Detected!!') cv2.imshow('Vikings Detected!!', img) cv2.imwrite('./img/detect_face.jpg', img) cv2.waitKey(0) scaleFactor:每次图像尺寸减小的比例;minNeighbors每一个目标至少要被检测到n次才算是真的目标(因为周围的像素和不同的窗口大小都可以检测到人脸) Python: cv2.CascadeClassifier.detectMultiScale(image[, scaleFactor[, minNeighbors[, flags[, minSize[, maxSize]]]]]) → objectsParameters: cascade – Haar classifier cascade (OpenCV 1.x API only). It can be loaded from XML or YAML file using Load(). When the cascade is not needed anymore, release it using cvReleaseHaarClassifierCascade(&amp;cascade). image – Matrix of the type CV_8U containing an image where objects are detected. objects – Vector of rectangles where each rectangle contains the detected object. scaleFactor – Parameter specifying how much the image size is reduced at each image scale. minNeighbors – Parameter specifying how many neighbors each candidate rectangle should have to retain it. flags – Parameter with the same meaning for an old cascade as in the function cvHaarDetectObjects. It is not used for a new cascade. minSize – Minimum possible object size. Objects smaller than that are ignored. maxSize – Maximum possible object size. Objects larger than that are ignored.视频中的人脸检测123456789101112131415161718192021222324# coding:utf-8import cv2def detect(): face_cascade = cv2.CascadeClassifier('./cascades/haarcascade_frontalface_default.xml') eye_cascade = cv2.CascadeClassifier('./cascades/haarcascade_eye.xml') camera = cv2.VideoCapture(1) while True: ret, frame = camera.read() gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) faces = face_cascade.detectMultiScale(gray, 1.1, 5) for (x, y, w, h) in faces: img = cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 0), 2) roi_gray = gray[y:y + h, x:x + w] roi_color = img[y:y + h, x:x + w] eyes = eye_cascade.detectMultiScale(roi_gray, 1.3, 6, 0, (40, 40)) for (ex, ey, ew, eh) in eyes: cv2.rectangle(roi_color, (ex, ey), (ex + ew, ey + eh), (255, 255, 255), 2) cv2.imshow("camera", frame) if cv2.waitKey(1000 / 12) &amp; 0xff == ord("q"): break camera.release() cv2.destroyAllWindows()if __name__ == "__main__": detect() 不上图]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 502 upstream sent too big header while reading response header from upstream]]></title>
    <url>%2F2016%2F10%2F06%2F715%2F</url>
    <content type="text"><![CDATA[wordpress某天后台突然不行，查看nginx的log，发现一个error：upstream sent too big header while reading response header from upstream。大意是上游发送的头部太大了。 解决办法： 在nginx的conf里面，关于php的部分加上如下两句，然后reload即可 fastcgi_buffer_size 128k; fastcgi_buffers 32 32k;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——字符串变形]]></title>
    <url>%2F2016%2F10%2F05%2F710%2F</url>
    <content type="text"><![CDATA[对于一个给定的字符串，我们需要在线性(也就是O(n))的时间里对它做一些变形。首先这个字符串中包含着一些空格，就像”Hello World”一样，然后我们要做的是把着个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。比如”Hello World”变形后就变成了”wORLD hELLO”。 输入描述:给定一个字符串s以及它的长度n(1≤n≤500)输出描述:请返回变形后的字符串。题目保证给定的字符串均由大小写字母和空格构成。 输入例子:“This is a sample”,16输出例子:“SAMPLE A IS tHIS” 1234567891011121314def transform(s): return ''.join([i.lower() if i.isupper() else i.upper() for i in s])def func(cstring): c_list = cstring.split() for i in range(len(c_list) / 2): c_list[i], c_list[-i - 1] = c_list[-i - 1], c_list[i] return ' '.join(transform(j) for j in c_list)if __name__ == '__main__': while True: try: strings, _ = raw_input().split(',') print func(eval(strings)) except: break 来自“一战通offer”互联网实习季编程挑战]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i++在两个线程里边分别执行100次，能得到的最大值和最小值分别是多少？]]></title>
    <url>%2F2016%2F10%2F04%2F708%2F</url>
    <content type="text"><![CDATA[前提i++不是原子操作，也就是说，它不是单独一条指令，而是3条指令：1、从内存中把i的值取出来放到CPU的寄存器中2、CPU寄存器的值+13、把CPU寄存器的值写回内存 分析 假设两个线程的执行步骤如下：1234567线程A执行第一次i++，取出内存中的i，值为0，存放到寄存器后执行加1，此时CPU1的寄存器中值为1，内存中为0；线程B执行第一次i++，取出内存中的i，值为0，存放到寄存器后执行加1，此时CPU2的寄存器中值为1，内存中为0；线程A继续执行完成第99次i++，并把值放回内存，此时CPU1中寄存器的值为99，内存中为99；线程B继续执行第一次i++，将其值放回内存，此时CPU2中的寄存器值为1，内存中为1；线程A执行第100次i++，将内存中的值取回CPU1的寄存器，并执行加1，此时CPU1的寄存器中的值为2，内存中为1；线程B执行完所有操作，并将其放回内存，此时CPU2的寄存器值为100，内存中为100；线程A执行100次操作的最后一部分，将CPU1中的寄存器值放回内存，内存中值为2； 结果多核cpu，最小值2，最大值200单核cpu，最小值100，最大值200]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——最大映射]]></title>
    <url>%2F2016%2F10%2F04%2F706%2F</url>
    <content type="text"><![CDATA[有 n 个字符串，每个字符串都是由 A-J 的大写字符构成。现在你将每个字符映射为一个 0-9 的数字，不同字符映射为不同的数字。这样每个字符串就可以看做一个整数，唯一的要求是这些整数必须是正整数且它们的字符串不能有前导零。现在问你怎样映射字符才能使得这些字符串表示的整数之和最大？ 输入描述:每组测试用例仅包含一组数据，每组数据第一行为一个正整数 n ， 接下来有 n 行，每行一个长度不超过 12 且仅包含大写字母 A-J 的字符串。 n 不大于 50，且至少存在一个字符不是任何字符串的首字母。输出描述:输出一个数，表示最大和是多少。 输入例子:2ABCBCA输出例子:1875 1234567891011121314151617181920212223242526272829303132def func(strings_list): the_all_big = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J') D = &#123;i: &#123;j: 0 for j in the_all_big&#125; for i in range(1, 12 + 1)&#125; G = &#123;i: 0 for i in the_all_big&#125; # 结果；集合去重 result, h = 0, set(i[0] for i in strings_list) # 计算个数 for each_string in strings_list: for i, a in enumerate(reversed(each_string), 1): D[i][a] += 1 # 计算权值 for i in range(1, 12 + 1): for a, j in D[i].items(): if i 0: G[a] += j * 10 ** (i - 1) sorted_result = sorted(G.iteritems(), key=lambda k: k[1]) for i in range(0, 10): # 开头不能为0 if i == 0: for j in range(0, 10): if sorted_result[j][0] not in h: sorted_result.pop(j) break else: result += i * sorted_result[i - 1][1] return resultif __name__ == '__main__': while True: try: strings_list = [raw_input() for i in range(int(raw_input()))] print func(strings_list) except: break 来自今日头条2017后端工程师实习生笔试题]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习OpenCV-Python——检测]]></title>
    <url>%2F2016%2F10%2F02%2F682%2F</url>
    <content type="text"><![CDATA[用Canny进行边缘检测Canny 边缘检测是一种非常流行的边缘检测算法，是 John F.Canny 在1986 年提出的。1234567import cv2import numpy as npimg = cv2.imread("../lena.bmp", 0)cv2.imwrite("canny.jpg", cv2.Canny(img, 200, 300))cv2.imshow("canny", cv2.imread("canny.jpg"))cv2.waitKey()cv2.destroyAllWindows() 可见边缘检测的结果非常棒Canny的工作原理略复杂，这里简单述说- 高斯滤波器降噪（Gaussian filter）由于边缘检测很容易受到噪声影响，所以第一步是使用 5x5 的高斯滤波器 去除噪声，这个前面我们已经学过了。- 计算梯度（calculates gradients）对平滑后的图像使用 Sobel 算子计算水平方向和竖直方向的一阶导数（图像梯度）（Gx 和 Gy）。根据得到的这两幅梯度图（Gx 和 Gy）找到边界的梯 度和方向，公式如下 梯度的方向一般总是与边界垂直。梯度方向被归为四类：垂直，水平，和两个对角线。 非极大值抑制（Non-maximum suppression）在获得梯度的方向和大小之后，应该对整幅图像做一个扫描，去除那些非边界上的点。对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯 度方向的点中最大的。如下图所示： 现在你得到的是一个包含“窄边界”的二值图像。 双阀值的边缘检测防止误判（ a double threshold on all the detected edges to eliminate false positives）现在要确定那些边界才是真正的边界。这时我们需要设置两个阈值：minVal 和 maxVal。当图像的灰度梯度高于 maxVal 时被认为是真的边界， 那些低于 minVal 的边界会被抛弃。如果介于两者之间的话，就要看这个点是 否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是 就抛弃。如下图： 分析所有边和和他们相连的边，去掉虚边，保留实边轮廓检测 轮廓可以简单认为成将连续的点（连着边界）连在一起的曲线，具有相同的颜色或者灰度。轮廓在形状分析和物体的检测和识别中很有用。 为了更加准确，要使用二值化图像。在寻找轮廓之前，要进行阈值化处理或者 Canny 边界检测。 查找轮廓的函数会修改原始图像。如果你在找到轮廓之后还想使用原始图像的话，你应该将原始图像存储到其他变量中。 在 OpenCV 中，查找轮廓就像在黑色背景中超白色物体。你应该记住，要找的物体应该是白色而背景应该是黑色。12345678910111213141516# coding:utf-8import cv2import numpy as npimg = np.zeros((200, 200), dtype=np.uint8)# 一个白色正方形img[50:150, 50:150] = 255# 阀值过滤ret, thresh = cv2.threshold(img, 127, 255, 0)cv2.imshow("img", img)image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)# 转换色彩空间color = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)img = cv2.drawContours(color, contours, -1, (0, 255, 0), 2)cv2.imshow("contours", color)cv2.waitKey()cv2.destroyAllWindows() cv2.threshold：作用：阀值处理；参数：输入1.图像；2.用来对像素值进行分类的阈值；3.当像素值高于（有时是小于）阈值时应该被赋予的新的像素值；4.阀值方法 cv2.THRESH_BINARY cv2.THRESH_BINARY_INV cv2.THRESH_TRUNC cv2.THRESH_TOZERO cv2.THRESH_TOZERO_INV 输出：retVal结果图像 cv2.findContours作用：寻找轮廓参数：输入：输入图像（会修改图像，可以使用img.copy()拷贝）层次结构类型（hierarchy type）轮廓近似方法（contour approximation method）输出：修改后的图像轮廓（contours）轮廓的层次结构轮廓（第二个返回值）是一个 Python 列表，其中存储这图像中的所有轮廓。每一个轮廓都是一个 Numpy 数组，包含对象边界点（x，y）的坐标。层次结构类型hierarchy type cv2.RETR_TREE 检索整个层次结构图像的轮廓,使您能够建立轮廓之间的“关系”。在你想完全消除两个相同轮廓的时候很有用。（在绝大多数情况下,你不需要检测一个物体在另一个具有相同类型的对象的里面） CV_RETR_EXTERNAL 只检测出最外轮廓即c0。 CV_RETR_LIST 检测出所有的轮廓并将他们保存到表(list)中 CV_RETR_COMP 检测出所有的轮廓并将他们组织成双层的结构 CV_RETR_TREE 检测出所有轮廓并且重新建立网状的轮廓结构 轮廓近似方法（contour approximation method） CHAIN_CODE 用freeman链码输出轮廓，其他方法输出多边形(顶点的序列)。 CHAIN_APPROX_NONE将链码编码中的所有点转换为点。也就是参数contours中的每个轮廓是用构成该轮廓的所有像素点表示的。 CHAIN_APPROX_SIMPLE压缩水平，垂直或斜的部分，只保存最后一个点。也就是说参数contours中的每个轮廓是用该轮廓的所有顶点表示的。 CHAIN_APPROX_TC89_L1，CV_CHAIN_QPPROX_TC89_KCOS使用Teh-Chin链逼近算法中的一个。 LINK_RUNS与上述的算法完全不同，连接所有的水平层次的轮廓。 cv2.drawContours image,//要绘制轮廓的图像 contours,//所有输入的轮廓，每个轮廓被保存成一个point向量 ontourIdx,//指定要绘制轮廓的编号，如果是负数，则绘制所有的轮廓 color,//绘制轮廓所用的颜色 thickness=None //绘制轮廓的线的粗细，如果是负数，则轮廓内部被填充 lineType=None, /绘制轮廓的线的连通性 hierarchy=None,//关于层级的可选参数，只有绘制部分轮廓时才会用到 maxLevel=None//绘制轮廓的最高级别，这个参数只有hierarchy有效的时候才有效 //maxLevel=0，绘制与输入轮廓属于同一等级的所有轮廓即输入轮廓和与其相邻的轮廓 //maxLevel=1, 绘制与输入轮廓同一等级的所有轮廓与其子节点。 //maxLevel=2，绘制与输入轮廓同一等级的所有轮廓与其子节点以及子节点的子节点 offset=None 轮廓 –边界框,最小矩形区域和最小封闭圆1234567891011121314151617181920212223242526272829303132333435363738# 我们先把图像转换成灰度图，然后使用cv2.threshold将图像二值化，处理完毕之后，绘制在原图上。# coding:utf-8import cv2import numpy as np# 读取图像，降低分辨率img = cv2.pyrDown(cv2.imread("hammer.jpg", cv2.IMREAD_UNCHANGED))# 转换成灰度图，进行简单阀值处理# 这个本来不是80，而是127的，不过考虑到实际。还是将阀值降低，不然效果不好。ret, thresh = cv2.threshold(cv2.cvtColor(img.copy(), cv2.COLOR_BGR2GRAY) , 80, 255, cv2.THRESH_BINARY)# 识别轮廓image, contours, hier = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)for c in contours: # 边界框坐标 # 坐标x,y；宽度高度w,h x,y,w,h = cv2.boundingRect(c) # 绘制矩形（绿色 cv2.rectangle(img, (x,y), (x+w, y+h), (0, 255, 0), 2) # 找出最小区域（OpenCV没有直接求出最小区域坐标的函数，我们需要转换） rect = cv2.minAreaRect(c) # 计算最小矩形区域的坐标（结果为float） box = cv2.boxPoints(rect) # 正常化坐标。将其化成整数 box = np.int0(box) # 绘制轮廓（红色；第三个参数，数组索引0开始 cv2.drawContours(img, [box], 0, (0,0, 255), 3) # 计算最小封闭圆的中心与半径（绿 (x,y),radius = cv2.minEnclosingCircle(c) # 转换成int center = (int(x),int(y)) radius = int(radius) # 绘制圆形 img = cv2.circle(img,center,radius,(0,255,0),2)cv2.drawContours(img, contours, -1, (255, 0, 0), 1)cv2.imshow("contours", img)cv2.waitKey()cv2.destroyAllWindows() 轮廓——凸轮廓线（convex contours）和道格拉斯·皮克雷算法（Douglas-Peucker algorithm）将轮廓形状近似到另外一种由更少点组成的轮廓形状，新轮廓的点的数目 由我们设定的准确度来决定。使用的Douglas-Peucker算法。OpenCV里面检测近似边界多边形（approximate bounding polygon of a shape）的函数cv2.approxPolyDP参数：输入：轮廓一个ε值，代表原图跟近似多边形的最大差值（值越低，近似的值就约接近原来的轮廓）一个布尔值，表示多边形是否是封闭的为什么需要一个近似边界多边形，特别是当我们有一个精确的轮廓的时候。答案是，多边是是一组直线的集合，多边形在计算机视觉处理里面十分重要12345678910111213141516171819202122232425# coding:utf-8import cv2import numpy as np# 读取图像，降低分辨率img = cv2.pyrDown(cv2.imread("hammer.jpg", cv2.IMREAD_UNCHANGED))# 转换成灰度图，进行简单阀值处理# 这个本来不是80，而是127的，不过考虑到实际。还是将阀值降低，不然效果不好。ret, thresh = cv2.threshold(cv2.cvtColor(img.copy(), cv2.COLOR_BGR2GRAY) , 80, 255, cv2.THRESH_BINARY)# 识别轮廓image, contours, hier = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)cnt = contours[0]img = np.zeros((img.shape[0], img.shape[1],3), dtype=np.uint8)# 求周长，True表示闭合epsilon = 0.01 * cv2.arcLength(cnt, True)# 近似多边形，True表示闭合approx = cv2.approxPolyDP(cnt, epsilon, True)# 直接使用轮廓，制作凸型（convex shapes）hull = cv2.convexHull(cnt)cv2.drawContours(img, [approx], 0, (0,0, 255), 2)cv2.drawContours(img, [hull], 0, (0,255, 0), 2)cv2.drawContours(img, contours, -1, (255, 255, 255), 1)cv2.imshow("done", img)cv2.waitKey() 线与圆形检测线条和形状检测有其背后的理论基础在一种叫做Hough变换的技术，由Richard Duda 和 Peter Hart发明。 线段检测HoughLines和HoughLinesP一个使用标准霍夫变换，另一个使用概率霍夫变换。通常，后者速度更快原理霍夫变换在检测各种形状的的技术中非常流行，如果你要检测的形状可以 用数学表达式写出，你就可以是使用霍夫变换检测它。及时要检测的形状存在一点破坏或者扭曲也可以使用。我们下面就看看如何使用霍夫变换检测直线。 一条直线可以用数学表达式 y = mx + c 或者 ρ = xcos θ + y sin θ 表示。ρ 是从原点到直线的垂直距离，θ 是直线的垂线与横轴顺时针方向的夹角（如 果你使用的坐标系不同方向也可能不同，我是按 OpenCV 使用的坐标系描述 的）。如下图所 所以如果一条线在原点下方经过，ρ 的值就应该大于 0，角度小于 180。 但是如果从原点上方经过的话，角度不是大于 180，也是小于 180，但 ρ 的值 小于 0。垂直的线角度为 0 度，水平线的角度为 90 度。 让我们来看看霍夫变换是如何工作的。每一条直线都可以用 (ρ, θ) 表示。 所以首先创建一个 2D 数组（累加器），初始化累加器，所有的值都为 0。行表 示 ρ，列表示 θ。这个数组的大小决定了最后结果的准确性。如果你希望角度精 确到 1 度，你就需要 180 列。对于 ρ，最大值为图片对角线的距离。所以如果 精确度要达到一个像素的级别，行数就应该与图像对角线的距离相等。 想象一下我们有一个大小为 100x100 的直线位于图像的中央。取直线上 的第一个点，我们知道此处的（x，y）值。把 x 和 y 带入上边的方程组，然后 遍历 θ 的取值：0，1，2，3，. . .，180。分别求出与其对应的 ρ 的值，这样我 们就得到一系列（ρ, θ）的数值对，如果这个数值对在累加器中也存在相应的位 置，就在这个位置上加 1。所以现在累加器中的（50，90）=1。（一个点可能 存在与多条直线中，所以对于直线上的每一个点可能是累加器中的多个值同时 加 1）。 现在取直线上的第二个点。重复上边的过程。更新累加器中的值。现在累加器中（50,90）的值为 2。你每次做的就是更新累加器中的值。对直线上的 每个点都执行上边的操作，每次操作完成之后，累加器中的值就加 1，但其他地方有时会加 1, 有时不会。按照这种方式下去，到最后累加器中（50,90）的 值肯定是最大的。如果你搜索累加器中的最大值，并找到其位置（50,90），这 就说明图像中有一条直线，这条直线到原点的距离为 50，它的垂线与横轴的 夹角为 90 度。12345678910111213141516171819202122232425262728293031# coding:utf-8import cv2import numpy as npimg = cv2.imread('line.jpg')gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)edges = cv2.Canny(gray, 50, 150, apertureSize=3)minLineLength = 3maxLineGap = 200# lines = cv2.HoughLinesP(edges, 1, np.pi / 180, 200)# for line in lines:# for x1, y1, x2, y2 in line:# cv2.line(img, (x1, y1), (x2, y2), (0, 255, 0), 2)# 第一个参数是一个二值化图像（所以在进行霍夫变换之前要首先进行二值化，或者进行 Canny 边缘检测。）# 第二三个参数分别代表 ρ 和 θ 的精确度# 第四个参数是阈值，只有累加其中的值高于阈值时才被认为是一条直lines = cv2.HoughLines(edges, 1, np.pi / 180, 200)for line in lines: for rho, theta in line: a = np.cos(theta) b = np.sin(theta) x0 = a * rho y0 = b * rho x1 = int(x0 + 1000 * (-b)) y1 = int(y0 + 1000 * (a)) x2 = int(x0 - 1000 * (-b)) y2 = int(y0 - 1000 * (a)) cv2.line(img, (x1, y1), (x2, y2), (0, 0, 255), 2)cv2.imshow("edges", edges)cv2.imshow("lines", img)cv2.waitKey()cv2.destroyAllWindows() 圆形检测使用霍夫变换在图像中找圆形（环）。12345678910111213141516171819202122232425262728# coding:utf-8import cv2import numpy as npplanets = cv2.imread('planet_glow.jpg')gray_img = cv2.cvtColor(planets, cv2.COLOR_BGR2GRAY)# 模糊img = cv2.medianBlur(gray_img, 5)cimg = cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)'''cv2.HoughCircles(image, method, dp, minDist, circles, param1, param2, minRadius, maxRadius)method:用于检测的方法，现在只有HOUGH_GRADIENTdp:累加器分辨率：dp=1跟原图有同样的分辨率，dp=2分辨率是原图的一般minDist：圆心到圆的最短距离param1:First method-specific parameter。在HOUGH_GRADIENT里面，是Canny边缘检测较大的那个参数param2:累加器在检测时候圆心的阀值。约小约容易检测到假圆'''cv2.imshow("Blur", img)circles = cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,1,60, param1=130, param2=30,minRadius=0,maxRadius=0)circles = np.uint16(np.around(circles))for i in circles[0,:]: # 圆 cv2.circle(planets,(i[0],i[1]),i[2],(0,255,0),2) # 中心点 cv2.circle(planets,(i[0],i[1]),2,(0,0,255),3)cv2.imwrite("planets_circles.jpg", planets)cv2.imshow("HoughCirlces", planets)cv2.waitKey]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种网络IO模型]]></title>
    <url>%2F2016%2F10%2F01%2F673%2F</url>
    <content type="text"><![CDATA[阻塞式模型（blocking IO）当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。 非阻塞IO（non-blocking IO）当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。在循环调用非阻塞IO的时候，将大幅度占用CPU，所以一般使用select等来检测”是否可以操作。 多路复用IO（IO multiplexing）（事件驱动IO(event driven IO)）基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。因此select()与非阻塞IO类似。用select的优势在于一个线程它可以同时处理多个connection。select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄。很多操作系统提供了更为高效的接口，如linux提供了epoll，BSD提供了kqueue。目前有很多开源的异步IO库，例如libevent、libev、libuv。事件驱动I/O的缺点是没有真正的同步机制。 如果任何事件处理器方法阻塞或执行一个耗时计算，它会阻塞所有的处理进程。 异步IO（Asynchronous IO）用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。异步IO是真正非阻塞的，它不会对请求进程产生任何的阻塞。non-blocking IO在执行recvfrom这个系统调用的时候，如果kernel的数据没有准备好，这时候不会block进程。但是当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内进程是被block的。而asynchronous IO则不一样，当进程发起IO操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——字符移位]]></title>
    <url>%2F2016%2F10%2F01%2F670%2F</url>
    <content type="text"><![CDATA[小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？ 输入描述:输入数据有多组，每组包含一个字符串s，且保证:1&lt;=s.length&lt;=1000.输出描述:对于每组数据，输出移位后的字符串。 输入例子:AkleBiCeilD输出例子:kleieilABCD 12345678910111213141516def func(string): i, k, L = 0, 0, list(string) while k &lt; len(L): if L[i] &lt;= 'Z' and L[i] &gt;= 'A': for j in range(i, len(string) - 1): L[j + 1], L[j] = L[j], L[j + 1] else: i += 1 k += 1 return ''.join(L)if __name__ == '__main__': while True: try: print func(raw_input().strip()) except: break 来自腾讯2017暑期实习生]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——跳石板]]></title>
    <url>%2F2016%2F09%2F29%2F668%2F</url>
    <content type="text"><![CDATA[小易来到了一条石板路前，每块石板上从1挨着编号为：1、2、3……. 这条石板路要根据特殊的规则才能前进：对于小易当前所在的编号为K的 石板，小易单次只能往前跳K的一个约数(不含1和K)步，即跳到K+X(X为K的一个非1和本身的约数)的位置。 小易当前处在编号为N的石板，他想跳到编号恰好为M的石板去，小易想知道最少需要跳跃几次可以到达。 例如：N = 4，M = 24：4-&gt;6-&gt;8-&gt;12-&gt;18-&gt;24于是小易最少需要跳跃5次，就可以从4号石板跳到24号石板 输入描述:输入为一行，有两个整数N，M，以空格隔开。(4 ≤ N ≤ 100000)(N ≤ M ≤ 100000) 输出描述:输出小易最少需要跳跃的步数,如果不能到达输出-1 输入例子:4 24 输出例子:5 1234567891011121314151617181920212223from math import sqrt# 求约数def divisor(i): l = [] for j in range(2, int(sqrt(i)) + 1): if i % j == 0: l.append(j) if i / j != j: l.append(i / j) return lnf = 99999def func(N, M): dp = [inf] * (M + 1) if N == M: return 0 dp[N] = 0 for i in xrange(N, M + 1): if dp[i] == inf: continue divisors = divisor(i) for j in divisors: if i + j &lt;= M: # 保留最小步数 dp[i + j] = min(dp[i + j], dp[i] + 1) return -1 if dp[M] == inf else dp[M] 来自网易2017秋招]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种新奇的线程队列轮询方法]]></title>
    <url>%2F2016%2F09%2F29%2F666%2F</url>
    <content type="text"><![CDATA[利用隐藏的环回（loopback）网络连接1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import queueimport socketimport osclass PollableQueue(queue.Queue): # 定义一种新的Queue，底层有一对互联的socket def __init__(self): super().__init__() if os.name == 'posix': self._putsocket, self._getsocket = socket.socketpair() else: # non-POSIX 系统 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind(('127.0.0.1', 0)) server.listen(1) # 创建一个服务器socket，之后立刻创建客户端socket并连接到服务器上 self._putsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self._putsocket.connect(server.getsockname()) self._getsocket, _ = server.accept() server.close() def fileno(self): # 返回套接字的文件描述符 return self._getsocket.fileno() def put(self, item): super().put(item) self._putsocket.send(b'x') def get(self): self._getsocket.recv(1) return super().get()if __name__ == '__main__': import select import threading import time def consumer(queues): while True: # 使用select轮询 can_read, _, _ = select.select(queues,[],[]) for r in can_read: item = r.get() print('Got:', item) q1 = PollableQueue() q2 = PollableQueue() q3 = PollableQueue() t = threading.Thread(target=consumer, args=([q1,q2,q3],)) t.daemon = True t.start() q1.put(1) q2.put(10) q3.put('hello') q2.put(15) time.sleep(1) 尽管底层的IO会带来一点点负载。但是如果不采用这样的socket技术，另一个选择就是遍历所有的队列，分辨每个队列是否为空，还要用上定时器。但是这样不仅麻烦，如果跟其他轮询对象比如socket一起使用的话。不能在同一地位上。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——优雅的点]]></title>
    <url>%2F2016%2F09%2F28%2F662%2F</url>
    <content type="text"><![CDATA[小易有一个圆心在坐标原点的圆，小易知道圆的半径的平方。小易认为在圆上的点而且横纵坐标都是整数的点是优雅的，小易现在想寻找一个算法计算出优雅的点的个数，请你来帮帮他。例如：半径的平方如果为25优雅的点就有：(+/-3, +/-4), (+/-4, +/-3), (0, +/-5) (+/-5, 0)，一共12个点。 输入描述:输入为一个整数，即为圆半径的平方,范围在32位int范围内。输出描述:输出为一个整数，即为优雅的点的个数 输入例子:25输出例子:1212345678from math import sqrtdef func(r2): count,r=0,sqrt(r2) for i in range(int(r)+1): t_=sqrt(r2-i**2) if round(t_)==t_: count+=2 if i==0 or i==r else 4 return count 来自网易2017秋招]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Python中的描述符(Descriptor)]]></title>
    <url>%2F2016%2F09%2F27%2F660%2F</url>
    <content type="text"><![CDATA[简单点12345678class Descriptor: def __get__(self, instance, owner): print('__get__ called. '）class foo: t = Descriptor()if __name__ == '__main__': c = foo() c.t #print __get__ called. 详细点123456789101112131415161718192021222324252627282930313233343536373839404142434445import typesclass Descriptor: def __call__(self, *args, **kwargs): print('Descriptor called') def __get__(self, instance, owner): if instance is not None: print('__get__ called. ' + 'instance is ' + str(instance) + '; owner is ' + str(owner)) return types.MethodType(self, instance) else: print('__get__ called. ' + 'instance is ' + str(instance) + '; owner is ' + str(owner)) return self def __set__(self, instance, value): print('set ' + str(instance) + ';value: ' + str(value))class foo: t = Descriptor()class bar: def __init__(self): self.t=Descriptor()if __name__ == '__main__': c = foo() print('test 1') # 相当于foo.__dict__['t'].__get__(None, foo) foo.t print('test 2') # 相当于foo.__dict__['t'].__get__(t, foo) c.t print('test 3') c.t() print('test 4') c.t = 1 print('test 5') d=bar() d.t'''test 1__get__ called. instance is None; owner is &lt;class '__main__.foo'&gt;test 2__get__ called. instance is &lt;__main__.foo object at 0x00000273839F4320&gt;; owner is &lt;class '__main__.foo'&gt;test 3__get__ called. instance is &lt;__main__.foo object at 0x00000273839F4320&gt;; owner is &lt;class '__main__.foo'&gt;Descriptor calledtest 4set &lt;__main__.foo object at 0x00000273839F4320&gt;;value: 1test 5''' 有什么用如果想创建一个新形式的实例属性，可以以描述符类的形式定义其功能12345678910111213141516171819202122232425262728class Integer: def __init__(self, name): self.name = name def __get__(self, instance, cls): if instance is None: return self else: return instance.__dict__[self.name] def __set__(self, instance, value): if not isinstance(value, int): raise TypeError('Expected an int') instance.__dict__[self.name] = value def __delete__(self, instance): del instance.__dict__[self.name]class Point: x = Integer('x') y = Integer('y') def __init__(self, x, y): self.x = x self.y = yif __name__ == '__main__': p = Point(2, 3) print(p.x) # calls Point.x.__get__(p,Point) p.y = 5 try: p.x = 2.3 except TypeError as e: print(e) 如果仅仅是像访问某个特定类中的一个属性，并对此做定制化处理，直接用property更加简单。在需要大量重用代码的情况下，描述符更加有用。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Python中的元类实现缓存实例（cached instance）]]></title>
    <url>%2F2016%2F09%2F27%2F657%2F</url>
    <content type="text"><![CDATA[关于缓存实例（cached instance），可以参考Python中的弱引用123456789101112131415161718192021222324import weakrefclass Cached(type): def __init__(self, *args, **kwargs): super(Cached, self).__init__(*args, **kwargs) # 建立一个value为弱引用的对象 self.__cache = weakref.WeakValueDictionary() def __call__(self, *args): if args in self.__cache: return self.__cache[args] else: # 注意，这里的self为Spam.Spam已经通过元类创建了__cache对象 obj = super(Cached, self).__call__(*args) self.__cache[args] = obj return objclass Spam(metaclass=Cached): def __init__(self, name): print('Creating Spam(&#123;!r&#125;)'.format(name)) self.name = nameif __name__ == '__main__': a = Spam('foo') b = Spam('bar') print('a is b:', a is b) c = Spam('foo') print('a is c:', a is c)]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Python中的元类实现单例模式]]></title>
    <url>%2F2016%2F09%2F27%2F655%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021class Singleton(type): def __init__(self, *args, **kwargs): self.__instance = None # 如果是Python2 # super(Singleton,self).__init__(*args, **kwargs) super().__init__(*args, **kwargs) def __call__(self, *args, **kwargs): if self.__instance is None: self.__instance = super().__call__(*args, **kwargs) return self.__instance else: return self.__instanceclass Spam(metaclass=Singleton): # 如果是Python2 # __metaclass__=Singleton def __init__(self): print('Creating Spam')if __name__ == '__main__': a = Spam() b = Spam() print(a is b)]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的弱引用]]></title>
    <url>%2F2016%2F09%2F26%2F653%2F</url>
    <content type="text"><![CDATA[weakref模块具有的方法class weakref.ref(object[, callback])创建一个弱引用对象，object是被引用的对象，callback是回调函数（当被引用对象被删除时的，会调用改函数）。 weakref.proxy(object[, callback])创建一个用弱引用实现的代理对象，参数同上。 weakref.getweakrefcount(object)获取对象object关联的弱引用对象数 weakref.getweakrefs(object)获取object关联的弱引用对象列表 class weakref.WeakKeyDictionary([dict])创建key为弱引用对象的字典 class weakref.WeakValueDictionary([dict])创建value为弱引用对象的字典 class weakref.WeakSet([elements])创建成员为弱引用对象的集合对象 12345678910111213141516171819202122### 创建弱引用&gt;&gt;&gt; from socket import *&gt;&gt;&gt; import weakref&gt;&gt;&gt; s=socket(AF_INET,SOCK_STREAM)&gt;&gt;&gt; ref=weakref.ref(s)&gt;&gt;&gt; s&lt;socket._socketobject instance at 007B4A94&gt;&gt;&gt;&gt; ref&lt;weakref at 0x81195c; to 'instance' at 0x7b4a94&gt; &gt;&gt;&gt; ref() #调用它来访问被引用的对象&lt;socket.socketobject instance at 007B4A94&gt;一旦没有了对这个对象的其它的引用，调用弱引用将返回None，因为Python已经销毁了这个对象。 注意：大部分的对象不能通过弱引用来访问。### 创建代理对象&gt;&gt;&gt; from socket import*&gt;&gt;&gt; import weakref&gt;&gt;&gt; s=socket(AF_INET,SOCK_STREAM)&gt;&gt;&gt; ref=weakref.proxy(s)&gt;&gt;&gt; s&lt;socket._socketobject instance at 007E4874&gt;&gt;&gt;&gt; ref &lt;socket._socketobject instance at 007E4874&gt;&gt;&gt;&gt; ref.close() #对象的方法同样工作 例子创建缓存实例当创建类实例时，我们想反悔一个缓存引用，让其指向上一个用同样参数（如果有的话）创建出的类实例123456789101112131415161718192021222324252627282930313233import sysclass Spam: def __init__(self, name): self.name = nameimport weakref_spam_cache = weakref.WeakValueDictionary()def get_spam(name): if name not in _spam_cache: s = Spam(name) _spam_cache[name] = s else: s = _spam_cache[name] return sif __name__ == '__main__': a = get_spam('foo') b = get_spam('bar') print(sys.getrefcount(a)) print('a is b:', a is b) c = get_spam('foo') print(sys.getrefcount(a)) print('a is c:', a is c) # 2 # a is b: False # 3 # a is c: True print(list(_spam_cache)) del a print(list(_spam_cache)) del c print(list(_spam_cache)) # ['foo', 'bar'] # ['foo', 'bar'] # ['bar'] 封装1234567891011121314151617181920212223import weakrefclass CachedSpamManager: def __init__(self): self._cache = weakref.WeakValueDictionary() def get_spam(self, name): if name not in self._cache: s = Spam(name) self._cache[name] = s else: s = self._cache[name] return sclass Spam: def __init__(self, name): self.name = nameSpam.manager = CachedSpamManager()def get_spam(name): return Spam.manager.get_spam(name)if __name__ == '__main__': a = get_spam('foo') b = get_spam('bar') print('a is b:', a is b) c = get_spam('foo') print('a is c:', a is c)]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现带有状态的对象]]></title>
    <url>%2F2016%2F09%2F24%2F649%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920# 一个naive的例子class Connection: def __init__(self): self.state = 'CLOSED' def read(self): if self.state != 'OPEN': raise RuntimeError('Not open') print('reading') def write(self): if self.state != 'OPEN': raise RuntimeError('Not open') print('writing') def open(self): if self.state == 'OPEN': raise RuntimeError('Already open') self.state = 'OPEN' def close(self): if self.state == 'CLOSED': raise RuntimeError('Already CLOSED')self.state = 'CLOSED' 这样很不优雅，而且包含了大量重复的代码。我们的目的是进行状态判断，那么我们本就可以把OPEN跟CLOSE状态各自封装成一个类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Connection state 的基类class ConnectionState: @staticmethod def read(conn): raise NotImplementedError() @staticmethod def write(conn, data): raise NotImplementedError() @staticmethod def open(conn): raise NotImplementedError() @staticmethod def close(conn): raise NotImplementedError()# 不同状态class ClosedConnectionState(ConnectionState): @staticmethod def read(conn): raise RuntimeError('Not open') @staticmethod def write(conn, data): raise RuntimeError('Not open') @staticmethod def open(conn): conn.new_state(OpenConnectionState) @staticmethod def close(conn): raise RuntimeError('Already closed')class OpenConnectionState(ConnectionState): @staticmethod def read(conn): print('reading') @staticmethod def write(conn, data): print('writing') @staticmethod def open(conn): raise RuntimeError('Already open') @staticmethod def close(conn): conn.new_state(ClosedConnectionState)class Connection: def __init__(self): self.new_state(ClosedConnectionState) def new_state(self, newstate): self._state = newstate def read(self): return self._state.read(self) def write(self, data): return self._state.write(self, data) def open(self): return self._state.open(self) def close(self): return self._state.close(self)if __name__ == '__main__': c = Connection() print(c) try: c.read() except RuntimeError as e: print(e) c.open() print(c) c.read() c.close() print(c) 这里的每种状态都用类和静态方法来实现，在每个静态方法中都把Connection类的实例作为第一个参数。这是因为我们在不同的状态类中不保存任何实例数据，所有的实例数据都应该保存在Connection实例中。再看看第二种方法，直接修改实例的class属性这里不再将Connection和COnnectionState作为单独的类来实现，现在我们将他们合并在一起。随着状态的改变，实例也会修改自己的类型。12345678910111213141516171819202122232425262728293031323334353637383940414243class Connection: def __init__(self): self.new_state(ClosedConnection) def new_state(self, state): self.__class__ = state def read(self): raise NotImplementedError() def write(self, data): raise NotImplementedError() def open(self): raise NotImplementedError() def close(self): raise NotImplementedError()class ClosedConnection(Connection): def read(self): raise RuntimeError('Not open') def write(self, data): raise RuntimeError('Not open') def open(self): self.new_state(OpenConnection) def close(self): raise RuntimeError('Already closed')class OpenConnection(Connection): def read(self): print('reading') def write(self, data): print('writing') def open(self): raise RuntimeError('Already open') def close(self): self.new_state(ClosedConnection)if __name__ == '__main__': c = Connection() print(c) try: c.read() except RuntimeError as e: print(e) c.open() print(c) c.read() c.close() print(c) 聪明的同学可能会看出，这TM就是设计模式中的状态模式嘛。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在回调函数中携带额外的状态]]></title>
    <url>%2F2016%2F09%2F23%2F637%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def apply_async(func, args, *, callback): # 执行函数 result = func(*args) # 回调函数介入 callback(result)# 例子def add(x, y): return x + y# (a) 一个简单的回调函数例子print('# --- Simple Example')def print_result(result): print("Got:", result)apply_async(add, (2, 3), callback=print_result)apply_async(add, ('hello', 'world'), callback=print_result)# (b) 使用绑定方法 （bound method）print('# --- Using a bound-method')class ResultHandler: def __init__(self): self.sequence = 0 def handler(self, result): self.sequence += 1 print('[&#123;&#125;] Got: &#123;&#125;'.format(self.sequence, result))r = ResultHandler()apply_async(add, (2, 3), callback=r.handler)apply_async(add, ('hello', 'world'), callback=r.handler)# (c) 使用闭包print('# --- Using a closure')def make_handler(): sequence = 0 def handler(result): # python3里面的nonlocal nonlocal sequence sequence += 1 print('[&#123;&#125;] Got: &#123;&#125;'.format(sequence, result)) return handlerhandler = make_handler()apply_async(add, (2, 3), callback=handler)apply_async(add, ('hello', 'world'), callback=handler)# (d) 使用协程print('# --- Using a coroutine')def make_handler(): sequence = 0 while True: result = yield sequence += 1 print('[&#123;&#125;] Got: &#123;&#125;'.format(sequence, result))handler = make_handler()next(handler) # 初始化apply_async(add, (2, 3), callback=handler.send)apply_async(add, ('hello', 'world'), callback=handler.send)# (e) 使用partialprint('# --- Using partial')class SequenceNo: def __init__(self): self.sequence = 0def handler(result, seq): seq.sequence += 1 print('[&#123;&#125;] Got: &#123;&#125;'.format(seq.sequence, result))seq = SequenceNo()from functools import partialapply_async(add, (2, 3), callback=partial(handler, seq=seq))apply_async(add, ('hello', 'world'), callback=partial(handler, seq=seq))]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python闭包的奇技淫巧]]></title>
    <url>%2F2016%2F09%2F23%2F635%2F</url>
    <content type="text"><![CDATA[这种奇技淫巧，很怪异。相比一个真正的类，像继承，属性，描述符，或者类方法这样的特性在这种方法中是无法使用的。从全局的角度考虑， 为闭包增加方法可能会有更多的实际用途，比如我们想重置内部状态，刷新缓冲区，清除缓存或者实现某种形式的反馈机制。123456789101112131415161718192021222324252627282930313233# coding:utf-8import sysclass ClosureInstance: def __init__(self, locals=None): if locals is None: # 获得上一层 locals = sys._getframe(1).f_locals # 遇到可调用的（函数），更新实例的字典。 self.__dict__.update((key, value) for key, value in locals.items() if callable(value)) print self.__dict__ # 重定向len方法 def __len__(self): return self.__dict__['__len__']()def Stack(): items = [] def push(item): items.append(item) def pop(): return items.pop() def __len__(): return len(items) return ClosureInstance()if __name__ == '__main__': s = Stack() print(s) s.push(10) s.push(20) s.push('Hello') print(len(s)) print(s.pop()) print(s.pop()) print(s.pop()]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习OpenCV——Python：用OpenCV处理图像]]></title>
    <url>%2F2016%2F09%2F23%2F626%2F</url>
    <content type="text"><![CDATA[高通滤波器（HPF）突出一个像素跟周边像素的差异，突出一个图像1234567891011121314151617181920212223242526272829# coding:utf-8import cv2import numpy as npfrom scipy import ndimagekernel_3x3 = np.array( [[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])kernel_5x5 = np.array( [[-1, -1, -1, -1, -1], [-1, 1, 2, 1, -1], [-1, 2, 4, 2, -1], [-1, 1, 2, 1, -1], [-1, -1, -1, -1, -1]])# 灰度图img = cv2.imread("0.jpg", 0)# “convolve”大概翻译为卷积的意思吧# 通过scipy的ndimage实现k3 = ndimage.convolve(img, kernel_3x3)k5 = ndimage.convolve(img, kernel_5x5)blurred = cv2.GaussianBlur(img, (11,11), 0)g_hpf = img - blurredcv2.imshow("3x3", k3)cv2.imshow("5x5", k5)cv2.imshow("gw('img',img)_hpf", g_hpf)cv2.waitKey()cv2.destroyAllWindows() 可见g_hpf效果最好### 低通滤波器（LPF）smoothen一个像素，如果它比某个阀值低。这在降噪跟模糊中很有用。如高斯模糊就是一个减弱高频信号的低通滤波器123456789101112131415161718192021222324252627import cv2import numpy as np'''边缘检测OpenCV内置的边缘检测：Laplacian(), Sobel(), and Scharr()当然，边缘检测很容易把噪声当做边缘。所以我们在进行边缘检测之前先进行降噪模糊。OpenCV内置的模糊函数blur() (simple average), medianBlur(), and GaussianBlur()下面我们使用medianBlur()，这对于彩色图像的降噪帮助很大。对于边缘检测，我们使用拉普拉斯算子Laplacian()在降噪之后，我们把色彩空间从BGR转换成灰阶'''def strokeEdges(src, dst, blurKsize=7, edgeKsize=5): if blurKsize &gt;= 3: # 7*7的模板 blurredSrc = cv2.medianBlur(src, blurKsize) # BGR to GRAY graySrc = cv2.cvtColor(blurredSrc, cv2.COLOR_BGR2GRAY) else: graySrc = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY) # 边缘检测 cv2.Laplacian(graySrc, cv2.CV_8U, graySrc, ksize=edgeKsize) # 归一化 normalizedInverseAlpha = (1.0 / 255) * (255 - graySrc) # 分割合并 channels = cv2.split(src) for channel in channels: channel[:] = channel * normalizedInverseAlpha cv2.merge(channels, dst) 自定义模板OpenCV提供了一个filter2D()函数，供我们自定义模板我们再来看看模板，它是一个有奇数行跟列的二维数组。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import cv2import numpy'''边缘检测OpenCV内置的边缘检测：Laplacian(), Sobel(), and Scharr()当然，边缘检测很容易把噪声当做边缘。所以我们在进行边缘检测之前先进行降噪模糊。OpenCV内置的模糊函数blur() (simple average), medianBlur(), and GaussianBlur()下面我们使用medianBlur()，这对于彩色图像的降噪帮助很大。对于边缘检测，我们使用拉普拉斯算子Laplacian()在降噪之后，我们把色彩空间从BGR转换成灰阶'''def strokeEdges(src, dst, blurKsize=7, edgeKsize=5): if blurKsize &gt;= 3: # 7*7的模板 blurredSrc = cv2.medianBlur(src, blurKsize) # BGR to GRAY graySrc = cv2.cvtColor(blurredSrc, cv2.COLOR_BGR2GRAY) else: graySrc = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY) # 边缘检测 cv2.Laplacian(graySrc, cv2.CV_8U, graySrc, ksize=edgeKsize) # 归一化 normalizedInverseAlpha = (1.0 / 255) * (255 - graySrc) # 分割合并 channels = cv2.split(src) for channel in channels: channel[:] = channel * normalizedInverseAlpha cv2.merge(channels, dst)class VConvolutionFilter(object): def __init__(self, kernel): self._kernel = kernel def apply(self, src, dst): """应用滤波器""" # 第二个参数 -1，指的是目标图跟原图具有同样的通道深度（per-channel depth） cv2.filter2D(src, -1, self._kernel, dst)class SharpenFilter(VConvolutionFilter): """锐化""" def __init__(self): # 注意到模板权重总和为1。这种情况下，图像的总体亮度不变。 kernel = numpy.array( [[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]] ) VConvolutionFilter.__init__(self, kernel)class FindEdgesFilter(VConvolutionFilter): """边缘检测""" def __init__(self): # 权重总和0，边缘白色，不是边缘黑色 kernel = numpy.array( [[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]] ) VConvolutionFilter.__init__(self, kernel)class BlurFilter(VConvolutionFilter): """模糊""" def __init__(self): # 权重总和为1 kernel = numpy.array( [[0.04, 0.04, 0.04, 0.04, 0.04], [0.04, 0.04, 0.04, 0.04, 0.04], [0.04, 0.04, 0.04, 0.04, 0.04], [0.04, 0.04, 0.04, 0.04, 0.04], [0.04, 0.04, 0.04, 0.04, 0.04]] ) VConvolutionFilter.__init__(self, kernel)class EmbossFilter(VConvolutionFilter): """浮雕""" def __init__(self): # 绝大多数模板都是对称的，若一边模糊（取正），一边锐化（取负），将会有奇异的效果（浮雕） kernel = numpy.array( [[-2, -1, 0], [-1, 1, 1], [0, 1, 2]] ) VConvolutionFilter.__init__(self, kernel) SharpenFilter##### FindEdgesFilter##### BlurFilter##### EmbossFilter### 实战还记得我们之前的那个调用摄像头的实战吗？这次我们在前一次的基础上，加上滤波器看看。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677filter.pyimport cv2import numpy'''边缘检测OpenCV内置的边缘检测：Laplacian(), Sobel(), and Scharr()当然，边缘检测很容易把噪声当做边缘。所以我们在进行边缘检测之前先进行降噪模糊。OpenCV内置的模糊函数blur() (simple average), medianBlur(), and GaussianBlur()下面我们使用medianBlur()，这对于彩色图像的降噪帮助很大。对于边缘检测，我们使用拉普拉斯算子Laplacian()在降噪之后，我们把色彩空间从BGR转换成灰阶'''def strokeEdges(src, dst, blurKsize=7, edgeKsize=5): if blurKsize &gt;= 3: # 7*7的模板 blurredSrc = cv2.medianBlur(src, blurKsize) # BGR to GRAY graySrc = cv2.cvtColor(blurredSrc, cv2.COLOR_BGR2GRAY) else: graySrc = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY) # 边缘检测 cv2.Laplacian(graySrc, cv2.CV_8U, graySrc, ksize=edgeKsize) # 归一化 normalizedInverseAlpha = (1.0 / 255) * (255 - graySrc) # 分割合并 channels = cv2.split(src) for channel in channels: channel[:] = channel * normalizedInverseAlpha cv2.merge(channels, dst)class VConvolutionFilter(object): def __init__(self, kernel): self._kernel = kernel def apply(self, src, dst): """应用滤波器""" # 第二个参数 -1，指的是目标图跟原图具有同样的通道深度（per-channel depth） cv2.filter2D(src, -1, self._kernel, dst)class SharpenFilter(VConvolutionFilter): """锐化""" def __init__(self): # 注意到模板权重总和为1。这种情况下，图像的总体亮度不变。 kernel = numpy.array( [[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]] ) VConvolutionFilter.__init__(self, kernel)class FindEdgesFilter(VConvolutionFilter): """边缘检测""" def __init__(self): # 权重总和0，边缘白色，不是边缘黑色 kernel = numpy.array( [[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]] ) VConvolutionFilter.__init__(self, kernel)class BlurFilter(VConvolutionFilter): """模糊""" def __init__(self): # 权重总和为1 kernel = numpy.array( [[0.04, 0.04, 0.04, 0.04, 0.04], [0.04, 0.04, 0.04, 0.04, 0.04], [0.04, 0.04, 0.04, 0.04, 0.04], [0.04, 0.04, 0.04, 0.04, 0.04], [0.04, 0.04, 0.04, 0.04, 0.04]] ) VConvolutionFilter.__init__(self, kernel)class EmbossFilter(VConvolutionFilter): """浮雕""" def __init__(self): # 绝大多数模板都是对称的，若一边模糊（取正），一边锐化（取负），将会有奇异的效果（浮雕） kernel = numpy.array( [[-2, -1, 0], [-1, 1, 1], [0, 1, 2]] ) VConvolutionFilter.__init__(self, kernel)#### cameo.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159# coding:utf-8import timeimport cv2import numpyimport filtersclass CaptureManager(object): def __init__(self, capture, previewWindowManager=None, shouldMirrorPreview=False): # 绘制窗口，bool self.previewWindowManager = previewWindowManager # 镜像旋转（在窗口中问不是在文件中），bool self.shouldMirrorPreview = shouldMirrorPreview self._capture = capture # 频道 self._channel = 0 self._enteredFrame = False self._frame = None # 写入图像 self._imageFilename = None self._videoFilename = None self._videoEncoding = None self._videoWriter = None self._startTime = None # 从开始到现在帧数 self._framesElapsed = long(0) # OpenCV没办法获取FPS，如果需要可以用time.time()计算 self._fpsEstimate = None @property def channel(self): return self._channel @channel.setter def channel(self, value): if self._channel != value: self._channel = value self._frame = None @property def frame(self): if self._enteredFrame and self._frame is None: _, self._frame = self._capture.retrieve() return self._frame @property def isWritingImage(self): return self._imageFilename is not None @property def isWritingVideo(self): return self._videoFilename is not None def enterFrame(self): """捕获下一帧，如果有的话""" assert not self._enteredFrame, \ 'previous enterFrame() had no matching exitFrame()' if self._capture is not None: self._enteredFrame = self._capture.grab() def exitFrame(self): """绘制窗口. 写入文件. 释放.""" if self.frame is None: self._enteredFrame = False return # 获取FPS if self._framesElapsed == 0: self._startTime = time.time() else: timeElapsed = time.time() - self._startTime self._fpsEstimate = self._framesElapsed / timeElapsed self._framesElapsed += 1 # 绘制窗口 if self.previewWindowManager is not None: if self.shouldMirrorPreview: mirroredFrame = numpy.fliplr(self._frame).copy() self.previewWindowManager.show(mirroredFrame) else: self.previewWindowManager.show(self._frame) # 写入图像 if self.isWritingImage: cv2.imwrite(self._imageFilename, self._frame) self._imageFilename = None # 写入视频 self._writeVideoFrame() # 释放 self._frame = None self._enteredFrame = False def writeImage(self, filename): """写入一帧到图像""" self._imageFilename = filename def startWritingVideo(self, filename, encoding=cv2.VideoWriter_fourcc('I', '4', '2', '0')): """开始准备写入视频""" self._videoFilename = filename self._videoEncoding = encoding def stopWritingVideo(self): """停止写入视频""" self._videoFilename = None self._videoEncoding = None self._videoWriter = None def _writeVideoFrame(self): if not self.isWritingVideo: return if self._videoWriter is None: fps = self._capture.get(cv2.CAP_PROP_FPS) if fps == 0.0: # 不能捕获帧数就用之前自己测量的 if self._framesElapsed &lt; 20: # 等待帧数稳定下来 return else: fps = self._fpsEstimate size = (int(self._capture.get(cv2.CAP_PROP_FRAME_WIDTH)), int(self._capture.get(cv2.CAP_PROP_FRAME_HEIGHT))) self._videoWriter = cv2.VideoWriter(self._videoFilename, self._videoEncoding, fps, size) self._videoWriter.write(self._frame)class WindowManager(object): def __init__(self, windowName, keypressCallback=None): self.keypressCallback = keypressCallback self._windowName = windowName self._isWindowCreated = False @property def isWindowCreated(self): return self._isWindowCreated def createWindow(self): cv2.namedWindow(self._windowName) self._isWindowCreated = True def show(self, frame): cv2.imshow(self._windowName, frame) def destroyWindow(self): cv2.destroyWindow(self._windowName) self._isWindowCreated = False def processEvents(self): keycode = cv2.waitKey(1) if self.keypressCallback is not None and keycode != -1: keycode &amp;= 0xFF self.keypressCallback(keycode)class Cameo(object): def __init__(self): self._windowManager = WindowManager('Cameo', self.onKeypress) self._captureManager = CaptureManager(cv2.VideoCapture(1), self._windowManager, True) self._curveFilter = filters.EmbossFilter() def run(self): """开始循环""" self._windowManager.createWindow() while self._windowManager.isWindowCreated: self._captureManager.enterFrame() frame = self._captureManager.frame self._curveFilter.apply(frame, frame) self._captureManager.exitFrame() self._windowManager.processEvents() def onKeypress(self, keycode): """ 处理案件 space -&gt; 截屏 tab -&gt; 开始/停止录像 escape -&gt; 退出 """ if keycode == 32: # space self._captureManager.writeImage('screenshot.png') elif keycode == 9: # tab if not self._captureManager.isWritingVideo: self._captureManager.startWritingVideo('screencast.avi') else: self._captureManager.stopWritingVideo() elif keycode == 27: # escape self._windowManager.destroyWindow()if __name__ == "__main__": Cameo().run()]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习OpenCV-Python——处理文件，摄像头，跟图形界面]]></title>
    <url>%2F2016%2F09%2F22%2F624%2F</url>
    <content type="text"><![CDATA[读写图像文件1234567891011121314151617181920212223242526272829303132333435import numpy,cv2# 我们尝试创建一张3*3的全黑的图，每个像素都是8bit的整数（0~255）&gt;&gt;&gt; img = numpy.zeros((3,3), dtype=numpy.uint8)&gt;&gt;&gt; imgarray([[0, 0, 0], [0, 0, 0], [0, 0, 0]], dtype=uint8)# 现在我们开始创建BGR图# 现在每个像素都被三个数组所表示，分别表示BGR# 注：BGR和RGB是同一颜色空间，只不过reversed而已&gt;&gt;&gt; img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)&gt;&gt;&gt; imgarray([[[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]]], dtype=uint8)&gt;&gt;&gt; img.shape(3,3,3)# 把PNG转换为JPG# imread()返回的是BGR格式，即使这个图像是灰度图# 如果你是在Python IDLE中运行的。当前目录为Python的安装路径image = cv2.imread('MyPic.png') cv2.imwrite('MyPic.jpg', image)# 我们可以自定义imread()，有如下枚举成员# IMREAD_ANYCOLOR = 4# IMREAD_ANYDEPTH = 2# IMREAD_COLOR = 1# IMREAD_GRAYSCALE = 0# IMREAD_LOAD_GDAL = 8# IMREAD_UNCHANGED = -1grayImage = cv2.imread('MyPic.png', cv2.IMREAD_GRAYSCALE) cv2.imwrite('MyPicGray.png', grayImage) 转换1234567891011121314151617181920212223242526'''一个byte的整数（0~255）。现在很多图像应用都用一个byte代表一个channel,OpenCV图像是2D或者3D的数组（.array type）。一个8bit的灰度图是二维数组的，一个24bitBGR图是三维数组的。一个8bit左上角像素是白色的灰度图，image[0, 0] 是 255。一个24bit左上角像素是蓝色的BGR图，image[0, 0] 是 [255, 0, 0]。image.item((0, 0)) 或 image.setitem((0, 0), 128) 比 image[0, 0] 或 image[0, 0] = 128 有效率'''# 可以把每个channel 8bit 的图像转换为pyhton的内置对象byteArraybyteArray = bytearray(image)# 我们可以通过 reshape 函数得到numpy数组# 注意对于BGR图，height*width*3必须与原图相等；对于灰度图height*width必须与原图相等grayImage = numpy.array(grayByteArray).reshape(height, width)bgrImage = numpy.array(bgrByteArray).reshape(height, width, 3)# 下面的例子随机生成一幅图像import cv2import numpyimport os# 随机生成 120,000 bytes 的数组.randomByteArray = bytearray(os.urandom(120000))flatNumpyArray = numpy.array(randomByteArray)# 转换数组为 400x300 的灰度图 image.grayImage = flatNumpyArray.reshape(300, 400)cv2.imwrite('RandomGray.png', grayImage)# 转换数组为 400x100 BGR图. bgrImage = flatNumpyArray.reshape(100, 400, 3)cv2.imwrite('RandomColor.png', bgrImage) 通过numpy.array访问图像123456789101112131415161718import cv2import numpy as npimg = cv2.imread('MyPic.png')img[0,0] = [255, 255, 255]img[:, :, 1] = 0 #设置G维的值全部为0# 前两个参数为x，y坐标。最后一个参数0,1,2分别代表BGRprint img.item(150, 120, 0)img.itemset( (150, 120, 0), 255)# prints 255print img.item(150, 120, 0)&gt;&gt;&gt; print img.shape(149, 320, 3)#图像所有的像素数量&gt;&gt;&gt; print img.size143040#8 bit 无符号&gt;&gt;&gt; print img.dtypeuint8 读写视频文件123456789101112# OpenCV只支持avi的格式，而且生成的视频文件不能大于2GB，而且不能添加音频。# 读取的每一帧都为BGR格式import cv2videoCapture = cv2.VideoCapture('MyInputVid.avi')fps = videoCapture.get(cv2.CAP_PROP_FPS)size=(int(videoCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),int(videoCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))videoWriter = cv2.VideoWriter( 'MyOutputVid.avi',cv2.VideoWriter_fourcc('I','4','2','0'), fps, size)success, frame = videoCapture.read()while success: videoWriter.write(frame) success, frame = videoCapture.read() 支持的格式 cv2.VideoWriter_fourcc(‘I’,’4’,’2’,’0’): This option is an uncompressed YUV encoding, 4:2:0 chroma subsampled. This encoding is widely compatible but produces large files. The file extension should be .avi. cv2.VideoWriter_fourcc(‘P’,’I’,’M’,’1’): This option is MPEG-1 The file extension should be .avi. cv2.VideoWriter_fourcc(‘X’,’V’,’I’,’D’): This option is MPEG-4 and a preferred option if you want the resulting video size to be average. The file extension should be .avi. cv2.VideoWriter_fourcc(‘T’,’H’,’E’,’O’): This option is Ogg Vorbis. The file extension should be .ogv. cv2.VideoWriter_fourcc(‘F’,’L’,’V’,’1’): This option is a Flash video. The file extension should be .flv. cv2.VideoWriter_fourcc(‘U’,’2’,’6’,’3’): H263 codec cv2.VideoWriter_fourcc(‘I’,’2’,’6’,’3’): H263I codec cv2.VideoWriter_fourcc(‘D’,’I’,’V’,’X’): MPEG-4 codec cv2.VideoWriter_fourcc(‘M’,’P’,’4’,’2’): MPEG-4.2 codec cv2.VideoWriter_fourcc(‘D’,’I’,’V’,’3’): MPEG-4.3 codec 使用摄像头12345678910111213141516171819202122import cv2cameraCapture = cv2.VideoCapture(0)fps = 30 # an assumptionsize = (int(cameraCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),int(cameraCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))videoWriter = cv2.VideoWriter( 'MyOutputVid.avi', cv2.VideoWriter_fourcc('I','4','2','0'), fps, size)success, frame = cameraCapture.read()numFramesRemaining = 10 * fps - 1while success and numFramesRemaining &gt; 0: videoWriter.write(frame) success, frame = cameraCapture.read() numFramesRemaining -= 1cameraCapture.release()'''在这里videoCapture的get方法不会返回fps，而是总会返回0。官方文档解释：“When querying a property that is not supported by the backend used by the VideoCapture class, value 0 is returned.”'''# 我们也可以用grab() 和 retrieve()success0 = cameraCapture0.grab()success1 = cameraCapture1.grab()if success0 and success1: frame0 = cameraCapture0.retrieve() frame1 = cameraCapture1.retrieve() 在窗口中显示图像1234567import cv2import numpy as npimg = cv2.imread('MyPic.jpg')cv2.imshow('my image', img)cv2.waitKey()# 销毁所有OpenCV创建的窗口cv2.destroyAllWindows() 实战将上面所学的知识，自己将OpenCV的API利用OOP的思想封装成更高层。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156# coding:utf-8import timeimport cv2import numpyclass CaptureManager(object): def __init__(self, capture, previewWindowManager=None, shouldMirrorPreview=False): # 绘制窗口，bool self.previewWindowManager = previewWindowManager # 镜像旋转（在窗口中问不是在文件中），bool self.shouldMirrorPreview = shouldMirrorPreview self._capture = capture # 频道 self._channel = 0 self._enteredFrame = False self._frame = None # 写入图像 self._imageFilename = None self._videoFilename = None self._videoEncoding = None self._videoWriter = None self._startTime = None # 从开始到现在帧数 self._framesElapsed = long(0) # OpenCV没办法获取FPS，如果需要可以用time.time()计算 self._fpsEstimate = None @property def channel(self): return self._channel @channel.setter def channel(self, value): if self._channel != value: self._channel = value self._frame = None @property def frame(self): if self._enteredFrame and self._frame is None: _, self._frame = self._capture.retrieve() return self._frame @property def isWritingImage(self): return self._imageFilename is not None @property def isWritingVideo(self): return self._videoFilename is not None def enterFrame(self): """捕获下一帧，如果有的话""" assert not self._enteredFrame, \ 'previous enterFrame() had no matching exitFrame()' if self._capture is not None: self._enteredFrame = self._capture.grab() def exitFrame(self): """绘制窗口. 写入文件. 释放.""" if self.frame is None: self._enteredFrame = False return # 获取FPS if self._framesElapsed == 0: self._startTime = time.time() else: timeElapsed = time.time() - self._startTime self._fpsEstimate = self._framesElapsed / timeElapsed self._framesElapsed += 1 # 绘制窗口 if self.previewWindowManager is not None: if self.shouldMirrorPreview: mirroredFrame = numpy.fliplr(self._frame).copy() self.previewWindowManager.show(mirroredFrame) else: self.previewWindowManager.show(self._frame) # 写入图像 if self.isWritingImage: cv2.imwrite(self._imageFilename, self._frame) self._imageFilename = None # 写入视频 self._writeVideoFrame() # 释放 self._frame = None self._enteredFrame = False def writeImage(self, filename): """写入一帧到图像""" self._imageFilename = filename def startWritingVideo(self, filename, encoding=cv2.VideoWriter_fourcc('I', '4', '2', '0')): """开始准备写入视频""" self._videoFilename = filename self._videoEncoding = encoding def stopWritingVideo(self): """停止写入视频""" self._videoFilename = None self._videoEncoding = None self._videoWriter = None def _writeVideoFrame(self): if not self.isWritingVideo: return if self._videoWriter is None: fps = self._capture.get(cv2.CAP_PROP_FPS) if fps == 0.0: # 不能捕获帧数就用之前自己测量的 if self._framesElapsed &lt; 20: # 等待帧数稳定下来 return else: fps = self._fpsEstimate size = (int(self._capture.get(cv2.CAP_PROP_FRAME_WIDTH)), int(self._capture.get(cv2.CAP_PROP_FRAME_HEIGHT))) self._videoWriter = cv2.VideoWriter(self._videoFilename, self._videoEncoding, fps, size) self._videoWriter.write(self._frame)class WindowManager(object): def __init__(self, windowName, keypressCallback=None): self.keypressCallback = keypressCallback self._windowName = windowName self._isWindowCreated = False @property def isWindowCreated(self): return self._isWindowCreated def createWindow(self): cv2.namedWindow(self._windowName) self._isWindowCreated = True def show(self, frame): cv2.imshow(self._windowName, frame) def destroyWindow(self): cv2.destroyWindow(self._windowName) self._isWindowCreated = False def processEvents(self): keycode = cv2.waitKey(1) if self.keypressCallback is not None and keycode != -1: keycode &amp;= 0xFF self.keypressCallback(keycode)class Cameo(object): def __init__(self): self._windowManager = WindowManager('Cameo', self.onKeypress) self._captureManager = CaptureManager(cv2.VideoCapture(0), self._windowManager, True) def run(self): """开始循环""" self._windowManager.createWindow() while self._windowManager.isWindowCreated: self._captureManager.enterFrame() frame = self._captureManager.frame self._captureManager.exitFrame() self._windowManager.processEvents() def onKeypress(self, keycode): """ 处理案件 space -&gt; 截屏 tab -&gt; 开始/停止录像 escape -&gt; 退出 """ if keycode == 32: # space self._captureManager.writeImage('screenshot.png') elif keycode == 9: # tab if not self._captureManager.isWritingVideo: self._captureManager.startWritingVideo('screencast.avi') else: self._captureManager.stopWritingVideo() elif keycode == 27: # escape self._windowManager.destroyWindow()if __name__ == "__main__": Cameo().run()]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习OpenCV-Python——安装]]></title>
    <url>%2F2016%2F09%2F22%2F621%2F</url>
    <content type="text"><![CDATA[所需库NumPySciPy在windows上OpenCV 2 对python 32bit的支持比64bit好 安装编译好的版本(no support for depth cameras)官网下载后。复制 \opencv\build\python\2.7\cv2.pyd 到 Python安装目录\Lib\site-packages 自己编译略。如有需要再写。 samplesC:\opencv\sources\samples 下一个例子]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Secret Symphony》]]></title>
    <url>%2F2016%2F09%2F21%2F614%2F</url>
    <content type="text"><![CDATA[爱尔兰的民谣风再加点爵士味的编曲。对比前几张专辑，感觉有些逊色。但曲风蛮适合秋日午后的。舒适而慵懒的感觉。 Katie Melua 8岁时移居到北爱尔兰的贝尔法斯特（BELFAST），5年前又举家迁移到英国，1年前在表演艺术学校BRIT SCHOOL上课的KATIE被知名制作人MIKE BATT挖掘（这位资深制作人近期的作品包括棒辣妹和陈美的专辑），于是和独立厂牌/经纪公司DRAMATICO签下5张唱片合约。小时梦想从政或是朝历史学家方向发展的KATIE，原先并没对写歌和音乐怀有远大志向。她15岁那年参加电视歌唱比赛，演唱MARIAH CAREY的《WHITOUT YOU》，获得冠军；在这之前，她只想象自己是能带给世界和平的人。2年前，KATIE开始写歌，她自称在音乐方面受到皇后合唱团（QUEEN）、琼妮·米歇尔（JONI MITCHELL）、鲍勃·迪伦（BOB DYLAN）、埃拉·菲茨杰拉德（ELLA FITZGERALD）和印度音乐以及爱尔兰民谣等多类乐风的影响。在这锋芒初露的实力派新人KATIE MELUA身上，我们可以看到即将燃烧的无限可能。]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Jazz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说东野圭吾的一些作品及个人见解]]></title>
    <url>%2F2016%2F09%2F17%2F599%2F</url>
    <content type="text"><![CDATA[话说东野圭吾，大概是50年代开始兴起的本格派推理小说最出名的作家（至少在国内）。东野的书算是看了不少，对我来说可算是日系推理小说入门的领路人了。今天就来说说东野。 东野本是一个工科男（毕业于大阪府立大学电气工学专业），偶尔写写小说。后来在85年的时候凭借《放学后》获得第31回江户川乱步奖。从此走上职业作家的不归路。 推荐下东野的几部个人觉得可以一看的作品 《白夜行》临近千禧年的作品，东野的代表作。以“泡沫经济”时的日本为背景，小说时间跨度非常大，场面宏大，人物刻画有血有肉，笔法看似白描，实则充满张力，十分老练，实在是上乘之作。社会派的著名代表作之一，合上书本之后，回想在脑海中不是各种trick，各种动机什么的，而是各种关于人性关于社会的种种。就算脱去推理小说的外衣，这本书依旧是一本超级棒的小说。值得两看。 《嫌疑人X的献身》《嫌疑人X的献身》首版于零五年，也算是东野偏后期的作品了。个人觉得东野的巅峰在《白夜行》，之后的几年都一直没什么出名的作品。零四年出了个《白夜行》的姊妹篇《幻夜》个人觉得实在一般，大概是因为有《白夜行》在先的缘故吧。而《嫌疑人X的献身》的出版，仿佛让人觉得旧日巅峰的东野回来了。巅峰时的东野的作品是怎么的？就是给你一种看完了合上书本，心里的震撼久久不能平息的感觉。 《解忧杂货店》这本书最近好火啊，大概是最近东野最出名的作品了。其实看完这本小说，我甚至怀疑不是出自东野之手。因为，这根本就是一本鸡汤版的故事会。我觉得文青或者小孩看看还可以，但是如果真的想看推理小说的话，我推荐还是不要买这本书好（ 毕竟被誉为，奇幻温情小说）。不过，如果你缺少一本鸡汤版的故事会，这本书还是值得一看的。 《恶意》虽说推理小说不到最后都不知道结局怎么样，但是如果太过刻意制造这种感觉就有点不像样了，这本书就是一个例子。一开始就告诉读者凶手是谁，然后一直在找动机，过了三分之二又告诉读者，“事情可不是你想的那么简单哦。”。读到最后没《嫌疑人X的献身》有那种抽丝剥茧，豁然开朗的感觉。当然，铁杆粉可以一读。下面是个人不推荐，铁杆粉可一读的书 《放学后》开头说了东野凭借《放学后》获得第31回江户川乱步奖，从此走上职业作家的不归路。这是一本东野早期的作品，文笔相对于巅峰时期的东野，显得很稚嫩。无论密室，trick，动机，还是最后的结局，都是一本一般般的作品。密室有点让人汗颜，trick平凡，动机扯蛋，结局我勒个去。当然，如果你是东野的铁杆饭，我还是建议你去看看。毕竟这本书又不厚。（逃 《秘密》这本书不如看电影好，书写得一般，电影个人觉得还不错啦。 《幻夜》因为是《白夜行》的姊妹篇也是其续篇。《白夜行》给100分的话，《幻夜》最多60分。另外，东野是有多喜欢恶女啊。。。。 《流星之绊》又一温情鸡汤故事会。 《宿命》简介还说这本是东野的代表作之一，这话怎么说得出口啊。 《神探伽利略》看电视剧啊，汤川帅。书真心垃圾。]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>推理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2014年索尼世界摄影奖 公开组获奖作品]]></title>
    <url>%2F2016%2F09%2F17%2F587%2F</url>
    <content type="text"><![CDATA[索尼世界摄影奖，现在已经成为世界最顶级的摄影活动之一。该比赛由索尼赞助，分为公开组、专业组、青少年组以及专业学生组4个组别，摄影题材涉及方方面面，是专业摄影人士以及摄影爱好者用自己的镜头记录这个世界的盛会。 索尼世界摄影奖比赛内容包括专业组：15个类别，组图作品进行评奖公开组：10个类别，单幅作品进行评奖青少年组：3个类别，单幅作品进行评奖（针对20岁以下年轻摄影师）专学生业组：针对18到30岁接受高等摄影教育的在校学生 公开组获奖名单建筑：Holger Schmidtke，德国艺术与人文：Valerie Prudon，澳大利亚后期制作：Kylli Sparre，爱沙尼亚弱光：Vlad Eftenie，罗马尼亚自然与动物：Gert van den Bosch，荷兰全景拍摄：Ivan Pedretti，意大利人物拍摄：Arup Ghosh，印度笑容：Alpay Erdem，土耳其瞬间影像：Hairul Azizi Harun，马来西亚旅游：陈利，中国]]></content>
      <categories>
        <category>Photograph</category>
      </categories>
      <tags>
        <tag>影廊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步 异步 阻塞与非阻塞]]></title>
    <url>%2F2016%2F09%2F14%2F582%2F</url>
    <content type="text"><![CDATA[同步所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit 等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT值返回给调用者。 异步异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以 CAsycSocket类为例（注意，CSocket从CAsyncSocket派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程立刻可以朝下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。这里提到执行部件和调用者通过三种途径返回结果：状态、通知和回调。可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。 阻塞阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在CSocket中调用Receive函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。socket接收数据的另外一个函数recv则是一个阻塞调用的例子。当socket工作在阻塞模式的时候，如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。 非阻塞非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。对象的阻塞模式和阻塞函数调用对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。 转自互联网]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql备份与恢复]]></title>
    <url>%2F2016%2F09%2F13%2F568%2F</url>
    <content type="text"><![CDATA[12345678备份一个数据库mysqldump -u username -p dbname table1 table2 ...-&gt; BackupName.sql备份多个数据库mysqldump -u username -p --databases dbname2 dbname2 &gt; Backup.sql备份所有数据库mysqldump -u username -p -all-databases &gt; BackupName.sql还原使用mysqldump命令备份的数据库mysql -u root -p [dbname] &lt; backup.sq]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记忆体化的装饰器]]></title>
    <url>%2F2016%2F09%2F12%2F498%2F</url>
    <content type="text"><![CDATA[我们先看一个斐波那契数列12345678910111213141516171819def fib(i): if i&lt;2:return 1 return fib(i-1)+fib(i-2)print(fib(10)) #没问题print(fib(100)) #似乎挂掉了我们再看看加了记忆体化的装饰器的版本from functools import wrapsdef memo(func): cache=&#123;&#125; @wraps(func) def wrap(*args): if args not in cache: cache[args]=func(*args) return cache[args] return wrap@memodef fib(i): if i&lt;2:return 1 return fib(i-1)+fib(i-2) 试着再运行一次？没问题了吧？那么这个装饰器函数有什么用？我们举个例子，我们执行fib(6)的时候，普通情况下函数的调用是这样的 其实思路很简单，就是把递归调用的函数用一个空间存储起来。从而函数的调用变成了如下：]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——构造回文]]></title>
    <url>%2F2016%2F09%2F12%2F494%2F</url>
    <content type="text"><![CDATA[给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？输出需要删除的字符个数。 输入描述:输入数据有多组，每组包含一个字符串s，且保证:1&lt;=s.length&lt;=1000.输出描述:对于每组数据，输出一个整数，代表最少需要删除的字符个数。 输入例子:abcdagoogle输出例子:22 其实就是一个最长公用子序列（LCS）问题。先看看LCS的算法吧（关于装饰器memo，详情请看记忆体化的装饰器）123456789101112131415'''递归版'''def rec_lcs(a, b): ''' 思路：从字符串的末尾开始，逐个匹配，不符合的砍掉。 ''' @memo def L(i, j): if min(i, j) &lt; 0: return 0 # 越界 if a[i] == b[j]: return 1 + L(i - 1, j - 1) # match得到的,左右各-1，结果+1，继续递归 return max(L(i - 1, j), L(i, j - 1)) # 不符合的砍掉。砍掉左边或右边 return L(len(a) - 1, len(b) - 1)print rec_lcs('spock', 'asoka')# 3 运行过程如图所示 123456789101112131415161718'''迭代版'''def lcs(a, b): ''' cur[i-1]对应递归版本的L(i-1,j) pre[i],pre[i-1]对应递归版本的L(i,j-1)与L(i-1,j-1) ''' n, m = len(a), len(b) pre, cur = [0] * (n + 1), [0] * (n + 1) for j in range(1, m + 1): pre, cur = cur, pre for i in range(1, n + 1): if a[i - 1] == b[j - 1]: cur[i] = pre[i - 1] + 1 else: cur[i] = max(pre[i], cur[i - 1]) return cur[n] 运行过程如图所示 原题解：1234567891011121314151617181920212223def lcs(a, b): ''' cur[i-1]对应递归版本的L(i-1,j) pre[i],pre[i-1]对应递归版本的L(i,j-1)与L(i-1,j-1) ''' n, m = len(a), len(b) pre, cur = [0] * (n + 1), [0] * (n + 1) for j in range(1, m + 1): pre, cur = cur, pre for i in range(1, n + 1): if a[i - 1] == b[j - 1]: cur[i] = pre[i - 1] + 1 else: cur[i] = max(pre[i], cur[i - 1]) return cur[n]if __name__=='__main__': while True: try: a=raw_input() A = [i for i in a.strip()] print len(A)-lcs(A,list(reversed(A))) except: break 来自腾讯2017暑期实习生编程题]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——年终奖]]></title>
    <url>%2F2016%2F09%2F09%2F490%2F</url>
    <content type="text"><![CDATA[小东所在公司要发年终奖，而小东恰好获得了最高福利，他要在公司年会上参与一个抽奖游戏，游戏在一个66的棋盘上进行，上面放着36个价值不等的礼物，每个小的棋盘上面放置着一个礼物，他需要从左上角开始游戏，每次只能向下或者向右移动一步，到达右下角停止，一路上的格子里的礼物小东都能拿到，请设计一个算法使小东拿到价值最高的礼物。给定一个66的矩阵board，其中每个元素为对应格子的礼物价值,左上角为[0,0],请返回能获得的最大价值，保证每个礼物价值大于100小于1000。 123456789101112131415def getMost(border): each_path = [] col = len(border[0]) raw = len(border) def most_momey(i=0, j=0, the_sum=0): if j &lt; col - 1: most_momey(i, j + 1, border[i][j] + the_sum) if i &lt; raw - 1: most_momey(i + 1, j, border[i][j] + the_sum) if i == raw - 1 and j == col - 1: each_path.append(the_sum + border[i][j]) else: return most_momey() return max(each_path) 来自京东2016研发工程师编程题P.s：某日坐86号公交去玩耍的时候想起之前柏雄大神说过的这道题，然后在公交上写写画画理清大概思路，然后今晚回来才把它写出来。拖延症啊。。。（逃]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP涉及数据库操作时响应很慢的神奇解决方法]]></title>
    <url>%2F2016%2F09%2F08%2F485%2F</url>
    <content type="text"><![CDATA[症状：通过浏览器调试查看瀑布图发现PHP页面加载很慢的原因在Waiting(TTFB)上。后发现当不涉及数据库操作时，速度正常。结果，原因是hosts中没有配置localhost。。。。。。。。。。。。。。。。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前缀、中缀、后缀表达式]]></title>
    <url>%2F2016%2F09%2F08%2F482%2F</url>
    <content type="text"><![CDATA[举例：(3 + 4) × 5 - 6 就是中缀表达式 - × + 3 4 5 6 前缀表达式 3 4 + 5 × 6 - 后缀表达式 栗子：中缀表达式 a+bc-(d+e) 转化为前缀 与 后缀第一步：按照运算符的优先级对所有的运算单位加括号~式子变成拉：((a+(bc))-(d+e))第二步：转换前缀与后缀表达式前缀：把运算符号移动到对应的括号前面则变成拉：-( +(a (bc)) +(de))把括号去掉：-+abc+de 前缀式子出现后缀：把运算符号移动到对应的括号后面则变成拉：((a(bc) )+ (de)+ )-把括号去掉：abc+de+- 后缀式子出现 习题：某表达式的前缀形式为”+-*^ABCD/E/F+GH”,它的中缀形式为() 从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果。根据从右至左扫描计算过程如下: 题目中的前缀形式为：+-^ABCD/E/F+GH1) 首先扫描 H,是数字 入栈 ，栈中为: H2) 扫描 G 为数字 入栈 ,栈中为:G,H3)扫描+ 为运算符 ,依次弹出G ,H ,得到 G+H 的结果 入栈，栈中为： G+H(在这里方便讲解 标记为 G+H)4)扫描 F 为数字 ,入栈 ，栈中为 F, G+H5)扫描 / 为运算符, 依次弹出 F,G+H ，计算F/(G+H) 的结果入栈 ，栈中为 F/(G+H)6)扫描 E 为数字,入栈，栈中为 E, F/(G+H)7) 扫描 / 为运算符, 依次弹出E, F/(G+H) ，计算 E/(F/(G+H))8)扫描 D 为数字,入栈 栈中为:D, E/(F/(G+H))9) 扫描 C 为数字,入栈 栈中为:C,D, E/(F/(G+H))10) 扫描 B 为数字,入栈 栈中为:B,C,D, E/(F/(G+H))11) 扫描 A 为数字,入栈 栈中为:A,B,C,D, E/(F/(G+H))12) 扫描^ 为数字,依次弹出 A,B 计算 A^B的结果入栈, 栈中为：A^B ,C,D, E/(F/(G+H))13) 扫描为数字,依次弹出 A^B,C 计算 A^BC的结果入栈, 栈中为：A^B C,D, E/(F/(G+H))14) 扫描-为数字,依次弹出 A^BC,D 计算 A^BC-D的结果入栈, 栈中为：A^B C-D, E/(F/(G+H))15) 扫描+为数字,依次弹出 A^BC-D, E/(F/(G+H)) 计算 A^BC-D+ E/(F/(G+H)) 的到结果最后得到的表达式为： A^B C-D+ E/(F/(G+H))]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一道编程题——洗牌]]></title>
    <url>%2F2016%2F09%2F08%2F480%2F</url>
    <content type="text"><![CDATA[洗牌在生活中十分常见，现在需要写一个程序模拟洗牌的过程。 现在需要洗2n张牌，从上到下依次是第1张，第2张，第3张一直到第2n张。首先，我们把这2n张牌分成两堆，左手拿着第1张到第n张（上半堆），右手拿着第n+1张到第2n张（下半堆）。接着就开始洗牌的过程，先放下右手的最后一张牌，再放下左手的最后一张牌，接着放下右手的倒数第二张牌，再放下左手的倒数第二张牌，直到最后放下左手的第一张牌。接着把牌合并起来就可以了。 例如有6张牌，最开始牌的序列是1,2,3,4,5,6。首先分成两组，左手拿着1,2,3；右手拿着4,5,6。在洗牌过程中按顺序放下了6,3,5,2,4,1。把这六张牌再次合成一组牌之后，我们按照从上往下的顺序看这组牌，就变成了序列1,4,2,5,3,6。 现在给出一个原始牌组，请输出这副牌洗牌k次之后从上往下的序列。 输入描述:第一行一个数T(T ≤ 100)，表示数据组数。对于每组数据，第一行两个数n,k(1 ≤ n,k ≤ 100)，接下来一行有2n个数a1,a2,…,a2n(1 ≤ ai ≤ 1000000000)。表示原始牌组从上到下的序列。输出描述:对于每组数据，输出一行，最终的序列。数字之间用空格隔开，不要在行末输出多余的空格。 输入例子:33 11 2 3 4 5 63 21 2 3 4 5 62 21 1 1 1输出例子:1 4 2 5 3 61 5 4 3 2 61 1 1 1 1234567891011def wash_card(card_list, repeat, length): if repeat &lt; 1: return card_list left = card_list[:length] right = card_list[length:] new_card_list = [] for i in range(length - 1, -1, -1): new_card_list.append(right[i]) new_card_list.append(left[i]) new_card_list.reverse() return wash_card(new_card_list, repeat - 1, length) 来自 网易有道2017内推编程题]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构与算法</tag>
        <tag>每天一道编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django获取用户IP地址]]></title>
    <url>%2F2016%2F09%2F07%2F475%2F</url>
    <content type="text"><![CDATA[前言经过反向代理后，由于在客户端和Web服务器之间增加了中间层，因此Web服务器无法直接拿到客户端的IP。由于使用反向代理的缘故，Django中HttpRequest.META[‘REMOTE_ADDR’]是得到localhost的地址。 X-Forwarded-For变量，这是一个squid开发的，用于识别通过HTTP代理或负载平衡器原始IP一个连接到Web服务器的客户机地址的非rfc标准，如果有做X-Forwarded-For设置的话,每次经过proxy转发都会有记录,格式就是client1, proxy1, proxy2,以逗号隔开各个地址，由于他是非rfc标准，所以默认是没有的，需要强制添加，在默认情况下经过proxy转发的请求，在后端看来远程地址都是proxy端的ip 。 步骤在Nginx配置文件中的server里加入1proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 然后再Django中访问HttpRequest的META[‘HTTP_X_FORWARDED_FOR’]就可以得到正确的IP地址。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux设置iptables防火墙]]></title>
    <url>%2F2016%2F09%2F06%2F470%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930//建议设置的时候快照一下，万一22端口莫名被墙就惨了//推荐设置iptables -L //查看规则iptables -D INPUT 4 //删除一条规则，例如第4行规则iptables -F //清空所有规矩iptables -A INPUT -s 127.0.0.1 -j ACCEPT //允许本机内部所有网络通信iptables -A INPUT -p tcp --dport 22 -j ACCEPT //开放22端口iptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A INPUT -p tcp --dport 443 -j ACCEPTiptables -A INPUT -p tcp --dport 25 -j ACCEPTiptables -A INPUT -p tcp --dport 465 -j ACCEPTiptables -A INPUT -p tcp --dport 110 -j ACCEPTiptables -A INPUT -p tcp --dport 995 -j ACCEPTiptables -A INPUT -p tcp --dport 143 -j ACCEPTiptables -A INPUT -p tcp --dport 993 -j ACCEPTiptables -A INPUT -p tcp --dport 20 -j ACCEPTiptables -A INPUT -p tcp --dport 21 -j ACCEPT//-A（–append):该命令会把一条规则附件到chain的末尾。//-D（–delete)用来删除某个规则。//-F（–flush)如果指定了chain,删除该chain中的所有规则，如果未指定chain,则删除所有chain中的所有规则。iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT //允许所有从服务器端发起的连接返回的数据//默认规则iptables -P INPUT DROPiptables -P OUTPUT ACCEPTiptables -P FORWARD DROPservice iptables save //保存规矩service iptables restart//其他设置iptables -A -p udp -j DROP //禁止所有udp端口iptables -A INPUT -s 192.168.1.0/24 -j DROP //禁止ip段]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Merry Christmas Mr. Lawrence》]]></title>
    <url>%2F2016%2F09%2F05%2F468%2F</url>
    <content type="text"><![CDATA[多媒体老师点名，一个班只来了不到十个人，确实有点寒酸。该实习的去实习，该找工作的去找工作，剩下像我这样无所事事到来上课的已没几个人了。 本来眼看初秋将至，何奈最近两天的气温清楚地告诉我这是一种错觉。每年都是如此，反反复复来来回回。 校园处处可见新生的身影，校园各地洋溢着欢乐祥和的气息——就像三年之前一样。记得我三年前曾在一篇文章里说到，“九月，是起点，更是终点。”四年的大学生活，感觉三年便已经过完了。 最近脑里总是单曲循环这首歌。 星座跟我一样的坂田龙一，是我挺喜欢的一个日本艺人。说艺人其实也说不上了，他出演的都是不起眼的小角色，《Merry Christmas Mr. Lawrence 》里的日军营长，《The Last Emperor》里的甘粕正彦满映理事长。他给别人留下深刻影响大概都是因为那些深刻的电影配乐。 日本的很多音乐似乎都透着一种压抑，一种隐隐约约的压抑。亦或并非如此，实是言者无心，听者有意罢了。]]></content>
      <categories>
        <category>Music</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[八大排序算法及其性能（Python实现）]]></title>
    <url>%2F2016%2F09%2F02%2F461%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179import timeimport randomimport copydef bubble_sort(list): ''' 冒泡排序 ''' length = len(list) # 第一级遍历 for index in range(1, length): # 第二级遍历 for j in range(1, length - index): if list[j] &gt; list[j + 1]: # 交换两者数据，这里没用temp是因为python 特性元组。 list[j + 1], list[j] = list[j], list[j + 1] return listdef bubble_sort_flag(list): ''' 带标记的冒泡排序 ''' length = len(list) flag = True for index in range(1, length): if not flag: # 没有发生交换，直接返回list return list flag = False for j in range(1, length - index): if list[j] &gt; list[j + 1]: list[j + 1], list[j] = list[j], list[j + 1] flag = True return listdef selection_sort(list): ''' 选择排序 ''' n = len(list) for i in range(1, n): min = i for j in range(i + 1, n): if list[j] &lt; list[min]: min = j if i != min: list[min], list[i] = list[i], list[min] return listdef insert_sort(list): ''' 插入排序 ''' n = len(list) for i in range(2, n): # 后一个元素和前一个元素比较 # 如果比前一个小 if list[i] &lt; list[i - 1]: list[0] = list[i] j = i - 1 while list[j] &gt; list[0]: list[j + 1] = list[j] j -= 1 list[j + 1] = list[0] return listdef shell_sort(list): ''' 希尔排序 ''' length = len(list) # 初始步长 increment = length while increment &gt; 1: increment = increment // 3 + 1; for i in range(increment + 1, length): if list[i] &lt; list[i - increment]: list[0] = list[i] j = i while j &gt;= increment and list[j - increment] &gt; list[0]: list[j] = list[j - increment] j -= increment list[j] = list[0] return listdef merge_sort(list): ''' 归并排序 ''' # 认为长度不大于1的数列是有序的 if len(list) &lt;= 1: return list # 二分列表 middle = len(list) // 2 left = merge_sort(list[:middle]) right = merge_sort(list[middle:]) # 最后一次合并 return merge(left, right)# 合并def merge(left, right): l, r = 0, 0 result = [] while l &lt; len(left) and r &lt; len(right): if left[l] &lt; right[r]: result.append(left[l]) l += 1 else: result.append(right[r]) r += 1 result += left[l:] result += right[r:] return resultdef quick_sort(list): ''' 快速排序 ''' if len(list) &lt;= 1: return list else: pivot = list[0] return quick_sort([x for x in list[1:] if x &lt; pivot]) + [pivot] + quick_sort([x for x in list[1:] if x &gt;= pivot])def shiftDown(arr, index, length): # 自顶向下堆化，从k开始堆化 N = length - 1 while 2 * index &lt;= N: j = 2 * index if j &lt; N and arr[j] &lt; arr[j + 1]: # 选出左右孩子节点中更大的那个 j += 1 if arr[index] &lt; arr[j]: arr[index], arr[j] = arr[j], arr[index] index = j else: breakdef heap_Sort(l): ''' 堆排序 ''' n = len(l) - 1 for i in range(n // 2, 0, -1): shiftDown(l, i, len(l)) while n &gt; 1: l[1], l[n] = l[n], l[1] shiftDown(l, 1, n) n -= 1def count_sort(list): ''' 计数排序 ''' # 取得最大值和最小值 max_ = max(list) min_ = min(list) # 创建数组C length = max_ - min_ + 1 count = [0] * length # 统计每项出现的次数 for index in list: if index &gt; 0: count[index] += 1 # 负数放在最大数后面 if index &lt; 0: count[max_ + abs(index)] += 1 index = 1 # 填值 for a in range(length - 1, max_, -1): for c in range(1, count[a] + 1): list[index] = -a + max_ index += 1 for a in range(max_ + 1): for c in range(1, count[a] + 1): list[index] = a index += 1 return listdef test(func, random_list): l = copy.deepcopy(random_list) print(func.__doc__) s = time.time() func(l) print(time.time() - s)func = [bubble_sort, bubble_sort_flag, selection_sort, insert_sort, merge_sort, shell_sort, quick_sort, count_sort, heap_Sort]for i in range(3): print('-----------------') random_list = [random.randint(1, 10000) for i in range(40)] random_list[0] = 0 last = [] for each_func in func: test(each_func, random_list)]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序表的几种查找]]></title>
    <url>%2F2016%2F08%2F31%2F447%2F</url>
    <content type="text"><![CDATA[顺序查找123456789101112131415161718192021int Sequential_search(int* a,int n,int key)&#123; int i; for (i = 1; i &lt;=n; i++) &#123; if(a[i]==key) return i; &#125; return 0;&#125;// 有哨兵版// 时间复杂度O(n)int Sequential_search(int* a,int n,int key)&#123; int i; a[0]=key; i=n; while(a[i]!=key) i--; return i;&#125; 折半查找（二分查找）二分检索算法的每一步，搜索空间总会减半，因此保证了运行时间。在数组中查找一个特定元素，可以保证在 O(log(n))时间内完成，而且如果找的正好是中间元素就更快了。也就是说，要从81,920,000个元素的数组中找某个元素的位置，只需要27个甚至更少的迭代。由于二分检索的随机跳跃性，该算法并非缓存友好的，因此只要搜索空间小于特定值（64或者更少），一些微调的二分检索算法就会切换回线性检索继续查找。然而，这个最终的空间值是极其架构相关的，因此大部分框架都没有做这个优化。123456789101112131415161718// 时间复杂度O(logn)int Binary_Search(int* a,int n,int key)&#123; int low,high,mid; low=1; high=n; while(low&lt;=high) &#123; mid=(low+high)/2; //折半 if(a[mid]&gt;key) high=mid-1; else if(a[mid]&lt;key) low=mid+1; else //a[mid]==key return mid; &#125; return 0;&#125; 插值查找类似于人类使用电话簿的方法，它试图通过假设元素在数组中均匀分布，来猜测元素的位置。首先，它抽样选择出搜索空间的开头和结尾，然后猜测元素的位置。算法一直重复这个步骤，直到找到元素。如果猜测是准确的，比较的次数大概是O(log(log(n))，运行时间大概是O(log(n))；但如果猜测的不对，运行时间就会是O(n)了。对于分布比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多 123456789101112131415161718// 插值查找int Insert_Search(int* a,int n,int key)&#123; int low,high,mid; low=1; high=n; while(low&lt;=high) &#123; mid=low+(high-low)*(key-a[low])/(a[high]-a[low]); //插值 if(a[mid]&gt;key) high=mid-1; else if(a[mid]&lt;key) low=mid+1; else //a[mid]==key return mid; &#125; return 0;&#125;# 斐波那契查找在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n&gt;=2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）。波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。斐波那契查找的时间复杂度还是O(log2n)，但是 与折半查找相比，斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定。12345678910111213141516171819202122232425262728293031323334353637// 斐波那契查找// 斐波那契数列：// 0 1 2 3 4 5 6 ....// 0 1 1 2 3 5 8 ....int Fibonacci_Search(int* a,int n,int key)&#123; int low,hgih,mid,i,k; low=1; high=n; k=0; while(n&lt;F[k]-1) //计算n位于斐波那契数列的位置 k++; for(i=n;i&lt;F[k]-1;i++) //对不满的数值补全，防止数组越界 a[i]=a[n]; while(low&lt;=high) &#123; mid=low+F[k-1]-1; if(a[mid]&gt;key) &#123; high=mid-1; k=k-1; &#125; else if(a[mid]&lt;key) &#123; low=mid+1; k=k-2; &#125; else &#123; if(mid&lt;n) return mid; else return n; //mid&gt;n说明是最后一个，返回n &#125; &#125; return 0;&#125;要点：1. 当key=a[mid]时，查找成功2. 当keya[mid]时，新范围是第mid+1个到第high个，此时范围个数为F[k-2]-1个]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim 操作集合]]></title>
    <url>%2F2016%2F08%2F31%2F444%2F</url>
    <content type="text"><![CDATA[打开文件vim 打开 Vim 欢迎页面vim filename 打开文件，文件名不存在是创建文件vim foldername 打开文件夹:open file 当前窗口打开文件:split file 新窗口打开文件:bn 下一个文件:bp 上一个文件 模式切换正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空插入模式（按i键进入） 左下角显示–INSERT–可视模式（按v进入） 左下角显示–VISUAL– 插入命令i 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行 查找命令/text 查找text，按n健查找下一个，按N健查找前一个。?text 查找text，反向查找，按n健查找下一个，按N健查找前一个。光标移动到该词上，按或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索vim中有一些特殊字符转义 .[]^%/?~$ 替换命令s/old/new/ old替换new，替换当前行的第一个匹配s/old/new/g old替换new，替换当前行的所有匹配%s/old/new/ old替换new，替换所有行的第一个匹配%s/old/new/g old替换new，替换整个文件的所有匹配 移动命令h 左移一个字符l 右移一个字符k 上移一个字符j 下移一个字符以上命令可以与数字组合，如先按2再按j就是向下移动两个字符w 向前移动一个单词,光标停留在行首，如果已到行尾，则转至下一行行首。b 向后移动一个单词e 同w，光标停在单词尾部ge 同b，光标停在单词尾部gg 移动到文件头G 移动到文件尾^ 移动到本行第一个非空白字符上0 移动到本行第一个字符上:200 跳转到行数Ctrl + e 向下滚动一行Ctrl + y 向上滚动一行Ctrl + d 向下滚动半屏Ctrl + u 向上滚动半屏Ctrl + f 向下滚动一屏Ctrl + b 向上滚动一屏 撤销操作u 撤销（Undo）U 撤销对整行的操作Ctrl + r 重做，相当于 Windows 里用的 Ctrl Y 删除操作x 删除光标后字符3x 删除当前光标开始向后三个字符X 删除当前字符的前一个字符dd 删除当前行10d 删除当前行开始的10行。D 删除当前字符至行尾:1,10d 删除1-10行 复制粘贴剪切进入可视模式，hljk移动光标，选中部分高亮y 复制高亮部分d 剪切 普通模式yy 拷贝当前行nyy 拷贝当前后开始的n行p 在当前光标后粘贴P 在当前行前粘贴ddp 交换当前行和其下一行xp 交换当前字符和其后一个字符 全局命令:wq 保存并退出:q! 强制退出并忽略所有更改:e! 放弃所有修改，并打开原来文件Ctrl+ww 移动到下一个窗口Ctrl+wj 移动到下方的窗口Ctrl+wk 移动到上方的窗口:close 最后一个窗口不能使用此命令 注释命令1,10 s/^/#/g 注释第1-10行1,10 s/^#//g 解除1-10行的注释 执行:!command 执行shell命令 其他:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。:help ‘number’ Vim选项的帮助用单引号括起:help 特殊键的帮助用&lt;&gt;扩起 转自：AppleHater]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四月份挖的拉勾网数据]]></title>
    <url>%2F2016%2F08%2F30%2F431%2F</url>
    <content type="text"><![CDATA[一共近10W条职位信息]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《什么值得买》的推送服务]]></title>
    <url>%2F2016%2F08%2F30%2F422%2F</url>
    <content type="text"><![CDATA[前言：什么值得买是一个很好玩的网站，但是因为用的人多，其优惠信息发布不久便已经失效。作者编写这个软件就是为了能及时将自己感兴趣的商品推送至微信。 其实什么值得买app也有推送功能，不过在iOS上面，其推送功能似乎有点问题（亦或是作者手机的问题？）。而且其推送功能限制较多，比如不能根据评论数量推送，不能根据商品价格推送。 这个推送服务，可以根据您自己的需要添加以下一条或多条过滤条件 根据标题过滤（关键词） 根据评论数量过滤（大于） 根据分类过滤（关键词） 根据商城过滤（关键词） 根据价格过滤（大于） 根据价格过滤（小于） 根据值过滤（大于） 根据不值过滤（小于） 根据值的百分比过滤（大于） 根据收藏数量过滤（大于） 根据价格过滤（关键词） 效果：在微信端显示效果 网页端显示效果 开始推送注册现在只支持QQ邮箱注册，用户名就是您的QQ号码。 注册完成后，进到您的邮箱里面验证。注意：可能本邮件会被标识为垃圾邮件。请仔细查找。 添加推送您可以添加多条过滤条件-（关键词）：表示可以是数字或文字-（大于），（小于）：只能为数字 根据标题过滤（关键词） 根据评论数量过滤（大于） 根据分类过滤（关键词） 根据商城过滤（关键词） 根据价格过滤（大于） 根据价格过滤（小于） 根据值过滤（大于） 根据不值过滤（小于） 根据值的百分比过滤（大于） 根据收藏数量过滤（大于） 根据价格过滤（关键词） 比如，我需要：阿迪达斯牌子的大于200元的在京东买的商品。您可以这样添加。 您可以添加任意多条推送 最后，在您的微信——我——设置——通用——功能——QQ邮箱提醒 ，打开邮箱提醒，就能在微信接受到推送了。直达链接]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git拾遗]]></title>
    <url>%2F2016%2F08%2F30%2F402%2F</url>
    <content type="text"><![CDATA[把Git Bash要记忆的东西整理了下设置用户名邮箱123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;创建版本库$ git init把文件添加到版本库$ git add readme.txt$ git commit -m &quot;wrote a readme file&quot;查看不同$ git diff readme.txt 当前状态$ git status查看commit$ git log回退上一个版本$ git reset --hard HEAD^退回上上一个版本$ git reset --hard HEAD^^退回上一百个版本$ git reset --hard HEAD~100使用版本号（只需要前几位）$ git reset --hard 3628164记录你的每一次命令$ git reflog丢弃工作区的修改让这个文件回到最近一次git commit或git add时的状态$ git checkout -- file 把暂存区的修改撤销掉（unstage），重新放回工作区$ git reset HEAD file从版本库中删除该文件$ git rm $ git commit创建SSH Key。$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;把本地仓库的内容推送到GitHub仓库$ git remote add origin https://github.com/username/project.git推送到远程$ git push origin master从远程库克隆$ git clone https://github.com/username/project.git创建dev分支，然后切换到dev分支：$ git checkout -b dev相当于$ git branch dev$ git checkout dev列出所有分支$ git branch我们把dev分支的工作成果合并到当前分支上$ git merge dev删除dev分支$ git branch -d dev禁用Fast forward的合并$ git merge --no-ff -m &quot;merge with no-ff&quot; dev把当前工作现场“储藏”起来$ git stash查看$ git stash list打标签$ git tag v.xxxx查看标签$ git show v.xxxx创建带有说明的标签，用-a指定标签名，-m指定说明文字：$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164删除$ git tag -d v0.1]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的闭包]]></title>
    <url>%2F2016%2F08%2F30%2F398%2F</url>
    <content type="text"><![CDATA[将组成函数的语句和这些语句的执行环境打包在一起时，得到的对象就是闭包。我们看一个例子foo.py12345678910111213141516171819202122232425x=44def callf(func): return func()import foodef bar(): x=13 def hello(): return "hello %s" %x foo.callf(hello)得到结果为 hello 13在编写惰性求值的代码的时候，闭包是一个很好的选择from urllib import urlopen def page (url) : def get() : return urlopen (url).read() return get &gt;&gt;&gt;python=page("http://www.python.org") &gt;&gt;&gt;jython=page( "http://www.jython.org") &gt;&gt;&gt;python &lt;function get at 0x9735f0&gt;&gt;&gt;&gt;jython &lt;function get at 0x9737f0&gt;&gt;&gt;&gt;pydata=python() &gt;&gt;&gt;jydata=jython() page() 函数实际上是不执行任何有意义的计算，它只是创建和返回函数get()如果需要在一个函数中保持某个状态，使用闭包是一种非常高效的行为。1234567891011def countdown(n): def next(): nonlocal n r=n n-=1 return r return nextnext=countdown(10)while True: v=next() if not v:break]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的生成器，协程与yield]]></title>
    <url>%2F2016%2F08%2F30%2F394%2F</url>
    <content type="text"><![CDATA[生成器与yield123456def countdown(n): print("Counting down from %d"%n) while n&gt;0: yield n n-=1 return 语句yield使得函数返回一个生成器，每次调用next()时。生成器函数将不断执行语句，直至遇到yield语句。1234567891011121314151617181920&gt;&gt;&gt;c=countdown(10)&gt;&gt;&gt;c.next()Counting down from 10&gt;&gt;&gt;c.next()Counting down from 9# 协程与yielddef receiver(): print("Ready to receive") while True: n=(yield) print("got %s"%n)&gt;&gt;&gt;r=receiver()&gt;&gt;&gt;r.next()Ready to receive&gt;&gt;&gt;r.send(1)got 1&gt;&gt;&gt;r.send(2)got 2&gt;&gt;&gt;r.send("Hello")got Hello 这种使用yield语句的函数成为协程，它的执行是为了响应发送给它的值。每次开始的next()函数时必不可少的可以编写一个装饰器123456789101112def coroutine(func): def start(*args,**kwargs): g=func(*args,**kwargs) g.next() return g return start@coroutinedef receiver(): print("Ready to receive") while True: n=(yield) print("got %s"%n) 可用.close()关闭。关闭后如果继续调用.send()就会引发StopIteration异常1&gt;&gt;&gt;r.close() 可以使用throw(exctype[,value[,tb]])方法在协程内部引发异常。exctype是指异常类型value是指异常的值tb是指跟踪对象1&gt;&gt;&gt;r.throw(RuntimeError,"You're hosed!") 协程还可以同时接受和发出返回值12345678910111213141516171819202122232425262728293031323334353637383940def line_splitter(delimiter=None): print("Ready to splite") result=None while True: line=(yield result) result=line.splite(delimiter)&gt;&gt;&gt;s=line_splitter(",")&gt;&gt;&gt;s.next()Ready to splite&gt;&gt;&gt;s.send("A,B,C")['A','B','C']# 应用import os import fnmatch def find_files (topdir, pattern): for path, dirname, filelist in os.walk(topdir): for name in filelist: if fnmatch.frunatch(name,pattern): yield os.path.join(path,name) import gzip, bz2 def opener (filenames): for name in filenames: if name.endswith( ".gz"):f=gzip.open(name) elif name.endswith(".bz2" ):f=bz2.BZ2File(name) else: f=open(name) yield fdef cat (filelist): for f in filelist: for line in f: yield linedef grep (pattern, lines) : for line in lines: if pattern in line: yield linewwwlogs=find_files("www","access-log*")files=opener(wwwlogs)lines=cat(files)pylines=grep("python",lines)for line in pylines: print line 在这个例子中，程序要处理的是顶级目录“www”的所有子目录中的所有“access-log”文件中的所有行。程序将测试每个”access-log”文件的文件压缩情况，然后使用正确的文件打开器打开它们。程序将各行连接在一起，并通过查找子字符串”python”的过滤器进行处理。整个程序是由位于最后的for语句驱动的。该循环的每次迭代都会通过管道获得一个新值并使用之。此外，这种实现占用内存极少，因为它无需创建任何临时列表或其他大型的数据结构1234567891011121314151617181920212223242526272829303132333435363738import os import fnmatch @coroutine def find_files(target): while True: topdir, pattern=(yield) for path, dirname, filelist in os.walk(topdir): for name in filelist: if fn.rnatch. fn.match (name, pattern): target.send(os.path.join(path, name)) import gzip, bz2 @coroutine def opener(target): while True: name=(yield) if name.endswith(".gz"):f=gzip.open(name) elif name.endswith(".bz2"):f=bz2.BZ2File(name) else:f=open(name) target.send( f) @coroutine def cat(target) : while True : f=(yield) for line in f: target.send(line) @coroutine def grep(pattern, target): while True: line=(yield) if pattern in line: target.send(line) @coroutine def printer(): while True: line=(yield) print(line)finder=find_files(opener(cat(grep("python",printer()))))finder.send(("www","access-log")) 在这个例子中每个协程都发送数据给在它们的target参数中指定的另一个协程。和生成器的例子不同，执行完全由將数据发送到第一个协程find_files()中来驱动。接下来，这个协程将数据转人下一阶段。这个例子有一个关键的地方，即协程管道永远保持活动状态，直到它显式调用close()方法为止。为此，只要需要，程序可以不断地给协程中注人数据。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Supervisor：监控服务进程的工具]]></title>
    <url>%2F2016%2F08%2F28%2F391%2F</url>
    <content type="text"><![CDATA[安装1pip install supervisor conf文件123456789101112131415161718192021222324[inet_http_server] ; inet (TCP) server disabled by defaultport=127.0.0.1:9001 ; (ip_address:port specifier, *:port for all iface)[supervisord]logfile=/tmp/supervisord.log ; (main log file;default $CWD/supervisord.log)logfile_maxbytes=50MB ; (max main logfile bytes b4 rotation;default 50MB)logfile_backups=10 ; (num of main logfile rotation backups;default 10)loglevel=info ; (log level;default info; others: debug,warn,trace)pidfile=/tmp/supervisord.pid ; (supervisord pidfile;default supervisord.pid)nodaemon=false ; (start in foreground if true;default false)minfds=1024 ; (min. avail startup file descriptors;default 1024)minprocs=200 ; (min. avail process descriptors;default 200)[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface[supervisorctl]serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket;[include];files = relative/directory/*.ini[program:superlist]**command=/home/vincent/sites/superlists-localhost/virtualenv/bin/gunicorn --pythonpath /home/vincent/sites/superlists-localhost/source/superlists superlists.wsgi:application**startsecs=3redirect_stderr = truestdout_logfile_maxbytes = 50MBstdout_logfile_backups = 10stdout_logfile = /home/vincent/sites/superlists-localhost/log/supervisor.log 启动12supervisord -c /etc/supervisor/supervisord.confsupervisorctl -c /etc/supervisor/supervisord.conf shutdown superlist]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Python中的元类(metaclass)]]></title>
    <url>%2F2016%2F08%2F28%2F389%2F</url>
    <content type="text"><![CDATA[类也是对象先明确一点，在Python中类（是类Class，不是对象或实例Object）同样也是一种对象。123456&gt;&gt;&gt; class ObjectCreator(): pass &gt;&gt;&gt; ObjectCreator&lt;class __main__.ObjectCreatorat 0x02D878F0&gt;&gt;&gt;&gt; ObjectCreator()&lt;__main__.ObjectCreator object at 0x02E87EE0&gt; 只要你使用关键字class，Python解释器在执行的时候就在内存中创建一个对象，名字就是ObjectCreator。这个对象（类）自身拥有创建对象（类实例）的能力，而这就是为什么它是一个类的原因。类的本质是一个对象，这就意味着你能对它作如下操作：1) 你可以将它赋值给一个变量2) 你可以拷贝它3) 你可以为它增加属性4) 你可以将它作为函数参数进行传递1234567891011121314151617&gt;&gt;&gt; print ObjectCreator # 你可以打印一个类，因为它其实也是一个对象&lt;class '__main__.ObjectCreator'&gt;&gt;&gt;&gt; def echo(o):… print o…&gt;&gt;&gt; echo(ObjectCreator) # 你可以将类做为参数传给函数&lt;class '__main__.ObjectCreator'&gt;&gt;&gt;&gt; print hasattr(ObjectCreator, 'new_attribute')Fasle&gt;&gt;&gt; ObjectCreator.new_attribute = 'foo' # 你可以为类增加属性&gt;&gt;&gt; print hasattr(ObjectCreator, 'new_attribute')True&gt;&gt;&gt; print ObjectCreator.new_attributefoo&gt;&gt;&gt; ObjectCreatorMirror = ObjectCreator # 你可以将类赋值给一个变量&gt;&gt;&gt; print ObjectCreatorMirror()&lt;__main__.ObjectCreator object at 动态创建类因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。123456789101112131415&gt;&gt;&gt; def choose_class(name):… if name == 'foo':… class Foo(object):… pass… return Foo # 返回的是类，不是类的实例… else:… class Bar(object):… pass… return Bar…&gt;&gt;&gt; MyClass = choose_class('foo')&gt;&gt;&gt; print MyClass # 函数返回的是类，不是类的实例&lt;class '__main__'.Foo&gt;&gt;&gt;&gt; print MyClass() # 你可以通过这个类创建类实例，也就是对象&lt;__main__.Foo object at at 0x89c6d4c&gt; class定义新类的执行过程使用class语句定义新类时，将会发生很多事情。首先，类主体将作为其自己的私有字典内的一系列语句来执行。语句的执行与正常代码中的执行过程相同，只是增加了会在私有成员（名称以_开头）上发生的名称变形。最后，类的名称、基类列表和字典将传递给元类的解构函数，以创建相应的类对象。下面的例子演示了这一过程：123456789class_name="Foo"class_parents=(object,)class_body="""def __init__(self,x): self.x=x"""class_dict=&#123;&#125;exec(class_body,globals(),class_dict)Foo=type(class_name,class_parents,class_dict) 强大的type函数type函数能够让你知道一个对象的类型是什么。但是type函数还有一种完全不同的能力，它也能动态的创建类。type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)12345678910111213141516171819202122232425262728&gt;&gt;&gt; class MyShinyClass(object):… pass&gt;&gt;&gt; MyShinyClass_new = type('MyShinyClass', (), &#123;&#125;) # 返回一个类对象&gt;&gt;&gt; print MyShinyClass_new&lt;class '__main__.MyShinyClass'&gt;&gt;&gt;&gt; print MyShinyClass_new() # 创建一个该类的实例&lt;__main__.MyShinyClass object at 0x8997cec&gt;&gt;&gt;&gt; class Foo(object):… bar = True&gt;&gt;&gt; Foo_new = type('Foo', (), &#123;'bar2':False&#125;)&gt;&gt;&gt; print Foo_new&lt;class '__main__.Foo'&gt;&gt;&gt;&gt; print Foo_new.barTrue&gt;&gt;&gt; print Foo_new.bar2False&gt;&gt;&gt; f = Foo_new()&gt;&gt;&gt; print f&lt;__main__.Foo object at 0x8a9b84c&gt;&gt;&gt;&gt; print f.barTrue&gt;&gt;&gt; print f.bar2False&gt;&gt;&gt; FooChild = type('FooChild', (Foo,),&#123;&#125;)&gt;&gt;&gt; print FooChild&lt;class '__main__.FooChild'&gt;&gt;&gt;&gt; print FooChild.bar # bar属性是由Foo继承而来True 回到主题，什么是元类元类就是用来创建类的“东西”。我们已经学习到了Python中的类也是对象。好吧，元类就是用来创建这些类（对象）的，元类就是类的类。函数type实际上是一个元类1234567891011121314151617181920212223242526MyClass = MetaClass()MyObject = MyClass()MyClass = type('MyClass', (), &#123;&#125;)我们知道通过实例的__class__属性，可以知道这个实例是由哪一个类生成的&gt;&gt;&gt; age = 35&gt;&gt;&gt; age.__class__&lt;type 'int'&gt;&gt;&gt;&gt; name = 'bob'&gt;&gt;&gt; name.__class__&lt;type 'str'&gt;&gt;&gt;&gt; def foo(): pass&gt;&gt;&gt;foo.__class__&lt;type 'function'&gt;&gt;&gt;&gt; class Bar(object): pass&gt;&gt;&gt; b = Bar()&gt;&gt;&gt; b.__class__&lt;class '__main__.Bar'&gt;但如果是__class__的__class__呢？这下就明白了，type就是Python在背后用来创建所有类的类（元类）。&gt;&gt;&gt; a.__class__.__class__&lt;type ''&gt;&gt;&gt;&gt; age.__class__.__class__&lt;type 'type'&gt;&gt;&gt;&gt; foo.__class__.__class__&lt;type 'type'&gt;&gt;&gt;&gt; b.__class__.__class__&lt;type 'type'&gt; metaclass属性那么，怎么样才能让python用元类来生成类呢。你可以在写一个类的时候为其添加metaclass属性。123class Foo(object): __metaclass__ = something…[…] 在Python中，创建Foo类的时候。Python会找Foo中有metaclass这个属性吗？如果是，Python会在内存中通过metaclass创建一个名字为Foo的类对象。如果Python没有找到metaclass，它会继续在父类中寻找metaclass属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到metaclass，它就会在模块层次中去寻找metaclass，并尝试做同样的操作。如果还是找不到metaclass,Python就会用内置的type来创建这个类对象。 自定义元类问题是，我们可以在metaclass中放置些什么代码呢。答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。 请记住，’type’实际上是一个类，就像’str’和’int’一样所以，你可以从type继承1234567891011121314151617181920212223242526272829class UpperAttrMetaclass(type): def __new__(cls, name, bases, dict): # __new__ 是在__init__之前被调用的特殊方法 # upperattr_metaclass。类方法的第一个参数总是表示当前的实例，就像在普通的类方法中的self参数一样。 # __new__是用来创建对象并返回之的方法 # 而__init__只是用来将传入的参数初始化给对象 # 你很少用到__new__，除非你希望能够控制对象的创建 # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__ # 如果你希望的话，你也可以在__init__中做些事情 # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用 attrs = ((name, value) for name, value in dct.items() if not name.startswith('__')) uppercase_attr = dict((name.upper(), value) for name, value in attrs) return super(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)__metaclass__ = UpperAttrMetaclass # 这会作用到这个模块中的所有类class Foo(object): # 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中 bar = 'bip'print hasattr(Foo, 'bar')# 输出: Falseprint hasattr(Foo, 'BAR')我们也可以class Upper: __metaclass__ = UpperAttrMetaclassclass Foo(Upper): # 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中 bar = 'bip'print hasattr(Foo, 'bar')# 输出: Falseprint hasattr(Foo, 'BAR') 究竟为什么要使用元类？现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它：元类的主要用途是创建API。一个典型的例子是Django ORM。它允许你像这样定义：12345class Person(models.Model): name = models.CharField(max_length=30) age = models.IntegerField()guy = Person(name='bob', age='35')print guy.age 这并不会返回一个IntegerField对象，而是会返回一个int，甚至可以直接从数据库中取出数据。这是有可能的，因为models.Model定义了metaclass， 并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。 阅读自爆栈网的一篇文章后有感做的笔记原文：What is a metaclass in Python]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chez Tools]]></title>
    <url>%2F2016%2F08%2F28%2F385%2F</url>
    <content type="text"><![CDATA[今年夏天真不平静，厄尔尼诺现象带来了令人措手不及的洪涝。电视机上充斥着里约奥运与湖北洪水的消息。更想不到的是，刚回到宿舍就下起了大雨，看着大雨的阵势，仿佛要下一个星期。学校老旧的排水系统，使得暴雨不仅没有起到冲刷大地的作用，反而使得学校水漫金山起来。 舍友陆续回来，续而就是宵夜。没有长谈，也仅仅是寒暄几句。除了迷茫，还是迷茫。 儿时心情总是随着上学的到来而变坏，这种“习惯”直到今天还没有消失。雨天由甚。 我想大概没有比下着暴雨的仲夏夜更适合爵士的时候了。Toots Thielemans的一曲《Old Friend》似乎比欢快的Swing Jazz更适合这个夜晚。《Chez Tools》这张French味专辑里面最不French的曲，《Old Friend》让我好像看到了一年后身边朋友各奔东西的唏嘘场景。 回忆是美好，但是还没到来便开始起了回忆，似乎就有那么一点讽刺了。 就在写这篇文章的前几天，Toots Thielemans在家乡布鲁塞尔的一个医院里平静离世。享年94岁。]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Jazz</tag>
        <tag>90s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Putty配色]]></title>
    <url>%2F2016%2F08%2F27%2F381%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY\Sessions\Default%20Settings]&quot;Colour0&quot;=&quot;255,255,255&quot;&quot;Colour1&quot;=&quot;255,255,255&quot;&quot;Colour2&quot;=&quot;51,51,51&quot;&quot;Colour3&quot;=&quot;85,85,85&quot;&quot;Colour4&quot;=&quot;0,0,0&quot;&quot;Colour5&quot;=&quot;0,255,0&quot;&quot;Colour6&quot;=&quot;77,77,77&quot;&quot;Colour7&quot;=&quot;85,85,85&quot;&quot;Colour8&quot;=&quot;187,0,0&quot;&quot;Colour9&quot;=&quot;255,85,85&quot;&quot;Colour10&quot;=&quot;152,251,152&quot;&quot;Colour11&quot;=&quot;85,255,85&quot;&quot;Colour12&quot;=&quot;240,230,140&quot;&quot;Colour13&quot;=&quot;255,255,85&quot;&quot;Colour14&quot;=&quot;205,133,63&quot;&quot;Colour15&quot;=&quot;135,206,235&quot;&quot;Colour16&quot;=&quot;255,222,173&quot;&quot;Colour17&quot;=&quot;255,85,255&quot;&quot;Colour18&quot;=&quot;255,160,160&quot;&quot;Colour19&quot;=&quot;255,215,0&quot;&quot;Colour20&quot;=&quot;245,222,179&quot;&quot;Colour21&quot;=&quot;255,255,255&quot;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nigux PHP7 安装与配置]]></title>
    <url>%2F2016%2F08%2F27%2F379%2F</url>
    <content type="text"><![CDATA[PHP7编译安装与配置123$ yum -y install gcc gcc-c++ autoconf automake libtool make cmake $ yum -y install zlib zlib-devel openssl openssl-devel pcre-devel libxml2-devel curl-devel libmcrypt-devel$wget http://cn2.php.net/get/php-7.0.10.tar.gz/from/this/mirror 解压后123$ ./configure --prefix=/usr/local/php7 \ --with-config-file-path=/usr/local/php7/etc \ --with-config-file-scan-dir=/usr/local/php7/etc/php.d \ --with-mcrypt=/usr/include \ --enable-mysqlnd \ --with-mysqli \ --with-pdo-mysql \ --enable-fpm \ --with-fpm-user=nginx \ --with-fpm-group=nginx \ --with-gd \ --with-iconv \ --with-zlib \ --enable-xml \ --enable-shmop \ --enable-sysvsem \ --enable-inline-optimization \ --enable-mbregex \ --enable-mbstring \ --enable-ftp \ --enable-gd-native-ttf \ --with-openssl \ --enable-pcntl \ --enable-sockets \ --with-xmlrpc \ --enable-zip \ --enable-soap \ --without-pear \ --with-gettext \ --enable-session \ --with-curl \ --with-jpeg-dir \ --with-freetype-dir \ --enable-opcachemakemake install 查看ini的位置。然后看看是否存在ini。如果没有去编译好的源码里面复制一个1cd /usr/local/php7/bin/php --ini 1234php.ini pid = run/php-fpm.pid error_log = log/php-fpm.log log_level = notice 也把php-fpm配置文件复制12$ cp php-fpm.conf.default php-fpm.conf $ cp php-fpm.d/www.conf.defualt php-fpm.d/www.conf 1234567891011121314php-fpm.conf listen = 127.0.0.1:9000 listen.allowed_clients = 127.0.0.1 pm = dynamic pm.max_children = 50 pm.start_servers = 5 pm.min_spare_servers = 5 pm.max_spare_servers = 35 pm.max_requests = 500 env[HOSTNAME] = $HOSTNAME env[PATH] = /usr/local/bin:/usr/bin:/bin env[TMP] = /tmp env[TMPDIR] = /tmp env[TEMP] = /tmp 运行php-fpm12/usr/local/php7/sbin/php-fpmnetstat -antpl (如果看到9000端口，PHP-FPM配置成功) Nginx安装与配置123456yum install libbz2yum install readline-develyum install sqlite-develyum install zlib-develyum install openssl-develyum install nginx nginx.conf配置文件123456789101112131415161718192021222324252627282930313233343536373839404142nginx.conf# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes 1;error_log /var/log/nginx/error.log;#error_log /var/log/nginx/error.log notice;#error_log /var/log/nginx/error.log info;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; # Load config files from the /etc/nginx/conf.d directory # The default server is in conf.d/default.conf #include /etc/nginx/conf.d/*.conf; server &#123; listen 80; root html/wordpress; location /&#123; index index.php; &#125; location ~\.php.*$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /$document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125;&#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 下对Wordpress的权限管理]]></title>
    <url>%2F2016%2F08%2F27%2F376%2F</url>
    <content type="text"><![CDATA[查看进程的权限12345678910ps -ef | grep nginx nginx 15095 15094 0 14:00 ? 00:00:01 php-fpm: pool wwwnginx 15096 15094 0 14:00 ? 00:00:01 php-fpm: pool wwwnginx 15097 15094 0 14:00 ? 00:00:01 php-fpm: pool wwwnginx 15098 15094 0 14:00 ? 00:00:01 php-fpm: pool wwwnginx 15099 15094 0 14:00 ? 00:00:01 php-fpm: pool wwwroot 22719 1 0 17:22 ? 00:00:00 gedit /etc/nginx/nginx.confroot 22811 1 0 17:25 ? 00:00:00 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.confnginx 22813 22811 0 17:25 ? 00:00:00 nginx: worker process root 22845 22824 0 18:05 pts/1 00:00:00 grep nginx 可以看到 使用nginx用户。下面我们来设置nginx用户各个文件夹的具体权限123[root@VM_94_158_centos html]# lltotal 4drwxr-xr-x 5 root root 4096 Aug 21 12:16 wordpress 可见文件owner是root我们把文件owner改为nginx1[root@VM_94_158_centos html]# chown -R nginx ./wordpress/ 对于linux中的权限 7 4 4 用户 组 任何人 r+w+x r r 4+2+1 4+0+0 4+0+0 1[root@VM_94_158_centos html]# chmod -R 555 ./wordpress/ 对于以下目录，要具有7的权限多媒体上传的目录：/wp-content/uploads/缓存目录：/.htaccess/wp-content/cache/1[root@VM_94_158_centos html]# chmod -R 755 ./wordpress/wp-content/uploads/]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下的Python升级]]></title>
    <url>%2F2016%2F08%2F27%2F374%2F</url>
    <content type="text"><![CDATA[1234567891011wget http://www.python.org/ftp/python/2.7.3/Python-2.7.3.tgztar -xf Python-2.7.3.tgzcd Python-2.7.3mkdir /usr/local/python27./configure --prefix=/usr/local/python27makemake install//备份旧的pythonmv /usr/bin/python /usr/bin/python_old//新建linkln -s /usr/local/python27/bin/python2.7 /usr/bin/python]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法的最小堆优化]]></title>
    <url>%2F2016%2F08%2F17%2F359%2F</url>
    <content type="text"><![CDATA[关于Dijkstra算法的具体步骤可以参考关于最短路径的几个算法Dijkstra算法里面每次找出离源点最近之点，使用了两个嵌套的循环语句。导致时间复杂度为O(N^2)。本例通过最小堆，优化这两个嵌套的循环语句。令算法整体复杂度降为O(NlogN)。 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;stdio.h&gt;// book记录那些顶点已经放入生成树中int dis[8];// h用来保存堆，pos用来存储每个顶点再堆中的位置，size为堆的大小int h[7], pos[7], size;int n=6, m=9,k;int inf = 99999999;int i, j;int u[10], v[10], w[10];int first[7], next[10];void swap(int x, int y)&#123; int t; t = h[x]; h[x] = h[y]; h[y] = t; t = pos[h[x]]; pos[h[x]] = pos[h[y]]; pos[h[y]] = t;&#125;//传入一个需要向下调整的顶点编号void siftdown(int i)&#123; int t, flag = 0; while (i * 2 &lt;= size&amp;&amp;flag == 0) &#123; // 首先判断左儿子 if (dis[h[i]] &gt; dis[h[i * 2]]) t = i * 2; else t = i; // 判断右儿子 if (i * 2 + 1 &lt;= size) &#123; // 如果右儿子的值更小 if (dis[h[t]]&gt;dis[h[i * 2 + 1]]) t = i * 2 + 1; &#125; // 若无须交换，也就是子树满足最小堆 if (t != i) &#123; swap(t, i); i = t; &#125; else flag = 1; &#125;&#125;void siftup(int i)&#123; int flag = 0; if (i == 1) return; while (i != 1 &amp;&amp; flag == 0) &#123; // 判断父节点 if (dis[h[i]]&lt;dis[h[i / 2]]) swap(i, i / 2); else flag = 1; i = i / 2; &#125;&#125;int pop()&#123; int t; t = h[1]; h[1] = h[size]; //将堆的最后一个点赋值到堆顶 pos[h[1]] = 1; size--; siftdown(1); //pop顶点编号出来 return t;&#125;int main()&#123; int count = 0; for (i = 1; i &lt;= m; i++) scanf("%d %d %d", &amp;u[i], &amp;v[i], &amp;w[i]); // 初始化dis dis[1] = 0; for (i = 2; i &lt;= n; i++) dis[i] = inf; // 邻接表 for (i = 1; i &lt;= n; i++) first[i] = -1; for (i = 1; i &lt;= m; i++) &#123; next[i] = first[u[i]]; first[u[i]] = i; &#125; count++; k = first[1]; // 遍历邻接表。找出离顶点1相邻点的权值，放入dis中 while (k != -1) &#123; dis[v[k]] = w[k]; k = next[k]; &#125; // 初始化堆 size = n; for (i = 1; i &lt;= size; i++)&#123; h[i] = i; pos[i] = i; &#125; //生成最小堆 for (i = size / 2; i &gt;= 1; i--)&#123; siftdown(i); &#125; pop(); while (count &lt; n) &#123; j = pop(); count++; // 遍历以顶点j开头的所有边 // k=为第n条边 k = first[j]; while (k != -1) &#123; if (dis[v[k]]&gt;dis[u[k]] + w[k]) &#123; dis[v[k]] = dis[u[k]] + w[k]; siftup(pos[v[k]]); &#125; k = next[k]; &#125; &#125; for (i = 1; i &lt;= n; i++) printf("%d ", dis[i]); return 0;&#125; 输入1 2 11 3 122 3 92 4 33 5 54 3 44 5 134 6 155 6 4结果0 1 8 4 13 17 分析h是堆，值为顶点号；pos的值对应顶点在堆中的位置。h与pos配合，形成最小堆。注意，是根据各个顶点在dis中对应的离源点的距离生成最小堆。 第0次循环 第一次循环 将1号顶点出堆，size前移，根据1的出边（1-N，这里指的是1-2,1-3）更新dis。1号顶点变为确定值。并更新堆。第二次循环 将2号顶点出堆，size前移，根据2的出边更新dis。2号顶点变为确定值。并更新堆第三次循环 将四号顶点出堆，size前移，根据4的出边更新dis。4号顶点变为确定值。并更新堆第四次循环 将三号顶点出堆，size前移，根据3的出边更新dis。3号顶点变为确定值。并更新堆如此类推]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于最短路径的几个算法]]></title>
    <url>%2F2016%2F08%2F16%2F328%2F</url>
    <content type="text"><![CDATA[Flody-Warshall算法求任意两点之间的最短路径。称为“多源最短路径”## 分析如果要让任意两点（a到b）之间的路径变短，只能引入第三个点（k），有时候甚至不止一个k若只允许经过1号顶点。只需判断e[i][1]+e[1][j]是否比e[i][j]要小即可。e[i][j]表示从i号顶点到j号顶点之间的路程。只允许经过1号顶点1234for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) if(e[i][j]&gt;e[i][1]+e[1][j]) e[i][j]=e[i][1]+e[1][j];只允许经过1号和2号顶点12345678for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) if(e[i][j]&gt;e[i][1]+e[1][j]) e[i][j]=e[i][1]+e[1][j];for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) if(e[i][j]&gt;e[i][2]+e[2][j]) e[i][j]=e[i][2]+e[2][j];只允许经过1号2号3号顶点最终 实现代码12345for(k=1;k&lt;=n;k++) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) if(e[i][j]&gt;e[i][K]+e[K][j]) e[i][j]=e[i][K]+e[K][j]; 复杂度时间复杂度：O(N^3)空间复杂度：O(N^2) 特点适用于稠密图和顶点关系密切的图不能解决负权回路 Dijkstra算法 求1到23456最短路径。“单源最短路径”问题 分析我们建立一个数组dis。用于存放1号顶点到其余各个顶点的距离。 先找出一个离1号顶点最近的顶点。找出的是2号顶点。讨论2-3这条路径能否让1到3的路径变短，也就是比较dis[3]和dis[2]+e[2][3]的大小。可知dis[3]&gt;dis[2]+e[2][3]。我们称为“松弛”同理2-4，将dis[4]松弛为4都松弛完毕之后，将2号顶点在book数组中标记起来 接下来在剩下的3456顶点中，选出离1号顶点最短的顶点。当前离1号顶点最近的是4号顶点。因此dis[4]从“估计值”变为“确定值”接下来对4号顶点的所有相邻点进行松弛（4-5，4-6，4-3）都松弛完毕之后，将4号顶点在book数组中标记起来 接下来在剩下的356顶点中，选出离1号顶点最短的顶点。当前离1号顶点最近的是3号顶点。因此dis[3]从“估计值”变为“确定值”接下来对3号顶点的所有相邻点进行松弛（3-5）都松弛完毕之后，将3号顶点在book数组中标记起来 接下来在剩下的56顶点中，选出离1号顶点最短的顶点。当前离1号顶点最近的是5号顶点。因此dis[5]从“估计值”变为“确定值”接下来对5号顶点的所有相邻点进行松弛（5-6）都松弛完毕之后，将5号顶点在book数组中标记起来 最后对6号顶点进行松弛 Dijkstra算法的主要思想：通过”边“来松弛1号顶点到其他顶点的距离。 实现代码1234567891011121314151617181920212223242526272829// 初始化dis数组for(i=1;i&lt;=n;i++) dis[i]=e[1][i];// 初始化book数组for(i=1;i&lt;=n;i++) book[i]=0;book[1]=1;for(i=1;i&lt;=n;i++)&#123; min=inf;//inf假设为无限 // 找出离1号顶点最近的顶点 for(j=1;j&lt;=n;j++) &#123; if(book[j]==0&amp;&amp;dis[j]&lt;min) &#123; min=dis[j]; u=j; &#125; &#125; book[u]=1; for(v=1;v&lt;=n;v++) &#123; if(e[u][v]&lt;inf) &#123; if(dis[v]&gt;dis[u]+e[u][v]) dis[v]=dis[u]+e[u][v]; &#125; &#125;&#125; 复杂度时间复杂度：O(N^2)空间复杂度：O(M) 优化 可用堆降低至O(logN) 可用邻接表降至O(M+N)logN 邻接表对于边数M少于N^2的系数图，可以使用相邻接表代替邻接矩阵。使得事件复杂度降至O(M+N)logN对于M=N^2，O(M+N)logN是要大于O(N^2)的 存入 12345678910111213141516171819202122// n为顶点数，m为边数int n,m,i;// u为开始点，v为结束点，w为权值int u[6],v[6],w[6];int first[5],next[5];// 初始化firstfor (i = 1; i &lt;= n; i++)&#123; first[i]=-1&#125;// 输入// 1 4 9// 2 4 6// 1 2 5// 4 3 8// 1 3 7for(i=1;i&lt;=m;i++)&#123; scanf("%d %d %d",&amp;u[i],&amp;v[i],&amp;w[i]); next[i]=first[u[i]]; first[u[i]]=i;&#125; first是存放顶点对应的边数的数组，如果一个顶点有多条边，可以使用next遍历。如：12345// 1 4 9// 2 4 6// 1 2 5// 4 3 8// 1 3 7 顶点1对应有3条边；2，4有1条，3无。遍历 123456789for (int i = 0; i &lt; n; ++i)&#123; k=first[i]; while(k!=-1) &#123; // do somethings k=next[k]; &#125;&#125; Bellman-Ford算法解决负权边问题 核心代码v,u,w数组分别一一对应给出的边n为顶点数，m为边数1234for (int k = 1; k &lt;= n-1; ++k) for (int i = 1; i &lt;= m; ++i) //枚举每一条边 if(dis[v[i]]&gt;dis[u[i]]+w[i]) //对每一条边进行松弛 dis[v[i]]=dis[u[i]]+w[i] 分析 第一轮在对所有的边进行松弛之后，得到的是从1号顶点“只能经过一条边”到达其余各顶点的最短路径长度。第二轮在对所有的边进行松弛之后，得到的是从1号顶点“最多经过两条边”到达其余各顶点的最短路径长度。只需进行n-1轮。因为在一个含有n个顶点的图中，任意两点之间的最短路径最多包含n-1边最短路径肯定是一个不包含回路的简单路径。回路分为正权回路与负权回路正权回路：回路权值为正。去掉这个回路会得到更短的路径。负权回路：回路权值为负。每走一次会得到更短的路径。Bellman-Ford算法还可以检测一个图是否存在负权回路如果在进行n-1轮松弛之后，依然存在：12if(dis[v[i]]&gt;dis[u[i]]+w[i]) dis[v[i]]=dis[u[i]]+w[i] 复杂度时间复杂度：O(NM)，比Dijkstra还要高空间复杂度：O(M) 优化 Bellman-Ford算法经常会在未到达n-1轮松弛前就已经计算出最短路径。如果在新一轮的松弛中数组dis没有发生变化。就可以跳出循环。 Bellman-Ford的队列优化每次选取队首顶点u，对顶点u的所有出边进行松弛操作。如，有一条u-v，如果通过u-v这条边使得源点到顶点v的最短路径变短。(dis[u]+e[u][v]&lt;dis[v])，且顶点v不在当前的队列中，就将顶点v放入队尾。我们还需要对队列中的顶点去重对顶点u的所有出边松弛完毕之后，将顶点v出队。接下来不断从队列中取出新的队首顶点再进行如上操作直至队列为空。实例分析 取1-2，dis[1]+e[1][2]&lt;dis[2]。入队 取1-5 1号顶点处理完毕。出队取2-3,2-5。处理2-5的时候，由于5号顶点已经在队列中，所以不能再次入队。 如此类推。最终处理结果 实现代码本例使用邻接表存储12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// n为顶点数，m为边数int n,m,i;// u为开始点，v为结束点，w为权值int u[6],v[6],w[6];int first[5],next[5];// book数组用于记录那些顶点已经在队列中int dis[6],book[6]=&#123;0&#125;;int que[101]=&#123;0&#125;,head=1,tail=1;for (i = 1; i &lt;=n; i++)&#123; dis[i]=inf;&#125;dis[1]=0;for (i = 1; i &lt;= n; i++) book[i]=0;// 初始化firstfor (i = 1; i &lt;= n; i++)&#123; first[i]=-1&#125;// 输入// 1 4 9// 2 4 6// 1 2 5// 4 3 8// 1 3 7for(i=1;i&lt;=m;i++)&#123; scanf("%d %d %d",&amp;u[i],&amp;v[i],&amp;w[i]); next[i]=first[u[i]]; first[u[i]]=i;&#125;que[tail]=1;tail++; //入队book[1]=1; //标记while(head&lt;tail)&#123; k=first[que[head]]; while(k!=-1) //扫描当前顶点所有的边 &#123; if(dis[v[k]]&gt;dis[u[k]]+w[k]) &#123; dis[v[k]]=dis[u[k]]+w[k]; // 去重 if(book[v[k]]==0) &#123; que[tail]=v[k]; tail++; book[v[k]]=1; &#125; &#125; k=next[k]; &#125; // 出队 book[que[head]]=0; head++;&#125; 队列优化的Bellman-Ford算法：其实上就是只处理那些在前一遍松弛中改变了最短路径估计值的顶点（因为只有这样才可能引起它们的邻接点最短路径估计值发生改变。）使用队列优化的Bellman-Ford算法在形式上和广度优先搜索非常类似，不同的是在广度优先搜索的时候一个顶点出队后通常就不会再重新进入队列。当一个顶点的最短路径估值变小后，需要重新进行松弛。如果某个点进入队列的次数超过n次，则这个图有负环。复杂度最坏的情况下为O(NM)]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript——Ajax与Comet]]></title>
    <url>%2F2016%2F07%2F31%2F278%2F</url>
    <content type="text"><![CDATA[XMLHttpRequest对象12345678910111213141516171819202122232425function createXHR()&#123; if (typeof XMLHttpRequest != "undefined")&#123; return new XMLHttpRequest(); &#125; else if (typeof ActiveXObject != "undefined")&#123; if (typeof arguments.callee.activeXString != "string")&#123; //在早期的IE中，XHR对象是通过MSXML库中一个ActiveX对象实现的。 //对于IE早期的版本IE7-，可能会遇到三种不同版本的XHR对象。 var versions = ["MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"], i, len; for (i=0,len=versions.length; i &lt; len; i++)&#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex)&#123; //跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125; else &#123; throw new Error("No XHR object available."); &#125;&#125; 响应数据responseText：作为响应主体被返回的文本。responseXML：如果响应的内容类型是就”text/xml”或”application/xml”，这个属性中将保存包含着响应数据的XML DOM文档status：响应的HTTP状态。statusText：HTTP状态的说明。123456789var xhr = createXHR();xhr.open("get", "example.txt", false);xhr.send(null);if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.statusText); alert(xhr.responseText);&#125; else &#123; alert("Request was unsuccessful: " + xhr.status);&#125; readyState 属性0：未初始化。尚未调用open()方法1：启动。已经调用oepn()方法，但尚未调用send()方法。2：发送。已经调用send()方法，但尚未接收到响应。3：接收。已经接收到部分响应数据。4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。12var xhr = createXHR();//这里不使用this的原因。因为onreadystatechange 是哪吃力程序的作用域问题。如果使用this对象，在有的浏览器中会导致函数执行错误1234567891011xhr.onreadystatechange = function (event) &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125;&#125;;xhr.open("get", "example.txt", true);xhr.send(null); HTTP头部信息默认情况下，在发送XHR请求的同时，还会发送下列头部信息。Accept：浏览器能够处理的内容类型。Accept-Charset：浏览器能够显小的字符集。Accept-Encoding：浏览器能够处理的压缩编码。Accept-Language：浏览器当前设置的语言。Connection：浏览器与服务器之间连接的类型。Cookie：当前页面设置的任何CookieHost：发出请求的页面所在的域Referer：发出请求的页面的URI。注意，HTTP规范将这个头部字段拼写错了，而为保证与规范一致，也只能将错就错了（这个英文单词的正确拼法应该是referrer）User-Agent：浏览器的用户代理字符串。setRequestHeader()参数：头部信息的名称和值1xhr.setRequestHeader("MyHeader", "MyValue"); getRequestHeader()参数：头部信息的名称1var header=xhr.getRequestHeader("MyHeader"); getAllRequestHeader()包含所有头部信息的长字符串 GET请求必须使用encodeURIComponent()编码123456789function addURLParam(url, name, value) &#123; url += (url.indexOf(";?") == -1 ? "?" : "&amp;") url += encodeURIComponent(name) + "=" + encodeURIComponent(value) return url&#125;var url = "example. php"url = addURLParam(url, "name", "vincent")url = addURLParam(url, "bock", "java")xhr.open("get", url, false); POST请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function submitData() &#123; var xhr = createXHR(); xhr.onreadystatechange = function (event) &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125; &#125;; xhr.open("post", "postexample.php", true); //表单请求 xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); var form = document.getElementById("user-info"); //发送序列化数据 xhr.send(serialize(form));&#125;function serialize(form) &#123; var parts = new Array(); var field = null; for (var i = 0, len = form.elements.length; i &lt; len; i++) &#123; field = form.elements[i]; switch (field.type) &#123; case "select-one": case "select-multiple": for (var j = 0, optLen = field.options.length; j &lt; optLen; j++) &#123; var option = field.options[j]; if (option.selected) &#123; var optValue = ""; if (option.hasAttribute) &#123; optValue = (option.hasAttribute("value") ? option.value : option.text); &#125; else &#123; optValue = (option.attributes["value"].specified ? option.value : option.text); &#125; parts.push(encodeURIComponent(field.name) + "=" + encodeURIComponent(optValue)); &#125; &#125; break; case undefined: //fieldset case "file": //file input case "submit": //submit button case "reset": //reset button case "button": //custom button break; case "radio": //radio button case "checkbox": //checkbox if (!field.checked) &#123; break; &#125; /* falls through */ default: parts.push(encodeURIComponent(field.name) + "=" + encodeURIComponent(field.value)); &#125; &#125; return parts.join("&amp;");&#125; XMLHttpRequest2级FormData序列化表单以及创建于表单格式相同的数据（用于通过XHR传输）123456789101112131415function submitData() &#123; var xhr = createXHR(); xhr.onreadystatechange = function (event) &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125; &#125;; xhr.open("post", "postexample.php", true); var form = document.getElementById("user-info"); xhr.send(new FormData(form));&#125; 超时设置12345678910111213141516171819var xhr = createXHR();xhr.onreadystatechange = function (event) &#123; try &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125; &#125; catch (ex) &#123; &#125;&#125;;xhr.open("get", "timeout.php", true);xhr.timeout = 1000;xhr.ontimeout = function () &#123; alert("Request did not return in a second.");&#125;;xhr.send(null); overrideMimeType()用于重写XHR相应的MIME类型1xhr.overrideMImeType("text/xml"); 进度事件loadstart：在接收到响应数据的第一个字节时触发progress：在接收响应期间持续不断地触发。error：在请求发生错误时触发。abort：在因为调用abort(）方法而终止连接时触发。load：在接收到完整的响应数据时触发。loadend：在通信完成或者触发error、abort或load事件后触发 load事件用以代替readystatechange事件响应接受完毕后将会触发load事件，因此没有必要去检查readyState只要浏览器接收到服务器的响应，不管状态如何，都会触发load事件12345678xhr.onload = function (event) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125;&#125;; progress事件在浏览器接受新数据期间周期性触发onprogress事件 处理程序会接受一个event对象，其target属性是XHR对象，有额外三个属性：lengthComputable：表示进度信息是否可用position：已经接受的字节totalSize：Content-Length响应头部确定的预期字节数123456xhr.onprogress = function(event)&#123; var divStatus = document.getElementById("status"); if (event.lengthComputable)&#123; divStatus.innerHTML = "Received " + event.position + " of " + event.totalSize + " bytes"; &#125;&#125;; 跨源资源共享默认情况下，XHR对象只能访问与包含它的页面位于同一域中的资源。CORS（跨源资源共享）背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。GET或POST发送的请求，它没有自定义的头部，主题内容是text/plain。在发送该请求时，需要给他附加一个额外的Origin头部Origin:http//www.baidu.com如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中会发同样的源信息Access-Control-Allow-Origin:http//www.baidu.com IE对CORS的实现IE8中引入XDR(XdomainRequest)类型。与XHR类似，但能实现安全可靠的跨域通信。XDR与XHR不同之处 cookie不会随请求发送，也不会随响应返回。 只能设置请求头部信息中的Content-Type字段。 不能访问响应头部信息。 只支持GET和POST请求。这些变化使CSRF（Cross-Site Request Forgery,跨站点请求伪造）和XSS（Cross-SiteScnpting，跨站点脚本）的问题得到了缓解。被请求的资源可以根据它认为合适的任意数据（用户代理、来源页面等）。来决定是否设置Allow-origin头部作为请求的一部分，origin头部的值表示请求的来源域，以便远程资源明确地识别XDR请求。所有XDR请求都是异步执行的，不能用它来创建同步请求。123456789101112var xdr = new XDomainRequest();xdr.onload = function () &#123; alert(xdr.responseText);&#125;;//如果失败，会触发error事件，遗憾的是没有其他信息可用xdr.onerror = function () &#123; alert("Error!");&#125;;xdr.open("get", "http://www.somewhere-else.com/xdr.php");xdr.send(null);//终止请求xdr.abort(); 与XHR一样，XDR对象也支持timeout属性以及ontimeout事件处理程序。为支持POST请求，XDR对象提供了contentType属性，用于表示发送数据的格式 其他浏览器对CORS的实现在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。要请求位于另一个域中的资源，使用标准的XHR对象并在open()方法中传入绝对URL即可与IE不同，通过跨域XHR对象可以访问status和statusText属性。限制 不能使用setRequestHeader()设置自定义头部 不能发送和接收cokie 调用getAllRespnseHeaders()方法总会返回空字符串因此，对于本地资源，最好使用相对URLPreflighted RequestsCORS通过一种叫做Prefltghted Requests的透明服务器验证机制支持开发人员使用自定义的头部、GET或POST之外的方法，以及不同类型的主体内容。在使用下列高级选项来发送请求时，就会向服务器发送一个Preflight请求。这种请求使用OPTIONS方法，发送下列头部 origin:与简单的请求相同。 Access-Control-Request-Method：请求自身使用的方法。 Access-ControlRequest-Headers：（可选）自定义的头部信息，多个头部以逗号分隔POST发送的请求Origin：http:\www.nczonline.netAccess-Control-RequestMethod:POSTAccess-Control-Request-Headers：NCZ服务器通过在响应中发送如下头部 Access- Control-Allow-Origin：与简单的请求相同。 Access- Control-AllowMethods:允许的方法·多个方法以逗号分隔。 Access- Control-Allow-Headers:允许的头部，多个头部以逗号分隔 Access- Control-Max-Age：应该将这个Preflight请求缓存多长时间（以秒表小）。例如：1234Access- Control-Allow-Origin:http://www.nczonline.netAccess- Control-AllowMethods :POST,GETAccess- Control-Allow-Headers:NCZAccess- Control-Max-Age：1728000g 带凭据的请求默认情况下，跨源请求不提供凭据（cookie、HTTP认证及客户端SSL证明等）。如果服务器接受带凭据的请求，会用下面的HTTP头部来响应。Access-Control-Allow-Credentialg：true如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给JavaScript（于是，responseText中将是空字符串，status的值为0，而且会调用onerror事件处理程序）。 跨浏览器的CORS检测XHR是否支持CORS的最简单方式，就是检查是否存在withCredentials属性。再结合检测XDornainRequest对象是否存在·就可以兼顾所有浏览器了。12345678910111213141516171819function createCORSRequest(method, url) &#123; var xhr = new XMLHttpRequest(); if ("withCredentials" in xhr) &#123; xhr.open(method, url, true); &#125; else if (typeof XDomainRequest != "undefined") &#123; xhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; xhr = null; &#125; return xhr;&#125;var request = createCORSRequest("get", "http://www.somewhere-else.com/xdr.php");if (request) &#123; request.onload = function () &#123; //do something with request.responseText &#125;; request.send();&#125; XMLHttpRequest与XDomainRequest共同属性方法 abort()：用于停止正在进行的清求。 onerror()：用于替代onreadystatechange检测错误 onload()：用于替代onreadystatechange检测成功 responseText()：用于取得响应内容。 send()：比用于发送请求以上成员都包含在createcoCORSRequest()函数返回的对象中 其他跨域技术图像Ping上述第一种跨域请求技术是使用标签。我们知道，一个网页可以从任何网页中加载图像，不用担心跨域不跨域。这也是在线广告跟踪浏览量的主要方式。12345var img = new Image();img.onload = img.onerror = function () &#123; alert("Done!");&#125;;img.src = "http://www.example.com/test?name=Nicholas"; 图像Ping最常用于跟踪用户点击页面或动态广告光次数。图像Ping有两个主要的缺点 只能发送GET请求 无法访问服务器的响应文本因此，图像Ping只能用于浏览器与服务器间的单向通信。JSONPJSONP跟JSON差不多，只不过是被包含在函数调用中的JSONcallback({“name”:”vincent”})JSONP是通过动态&lt;script&gt;元素来使用的，使用时可以为src属性指定一个跨域URL这里的&lt;script&gt;元素，与以&lt;img&gt;兀素类似，都有能力不受限制地从其他域加载资源。因为JSONP是有效的JavaScript代码，所以在请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。123456function handleResponse(response) &#123; alert("You're at IP address " + response.ip + ", which is in " + response.city + ", " + response.region_name);&#125;var script = document.createElement("script");script.src = "http://freegeoip.net/json/?callback=handleResponse";document.body.insertBefore(script, document.body.firstChild); 优点： 在于能与直接访问相应文本，支持浏览器与服务器之间双向通信CometAjax是种从页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。Comet能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。有两种实现Comet的方式：长轮询和流。短轮询 长轮询长轮询是传统轮询（也称为短轮询）的一个翻版，页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断。 HTTP流流不同于上述两种轮询，因为它在页面的整个生命周期内只使用一个HTTP连接。具体来说，就是浏览器向服务器发送一个请求·而服务器保持连接打开，然后周期性地向浏览器发送数据。在Firefox，Opera，Safari和Chrome中，通过侦听readystatechange事件及检测readystate的值是否为3，就可以利用XHR对象实现HTTP流。在上述这些浏览器中，随着不断从服务器接收数据，readystate的值会周期性地变为3。当readystate值变为3时，respongerext属性中就会保存接收到的所有数据。123456789101112131415161718192021222324function createStreamingClient(url, progress, finished) &#123; var xhr = new XMLHttpRequest(), received = 0; xhr.open("get", url, true); xhr.onreadystatechange = function () &#123; var result; if (xhr.readyState == 3) &#123; //只取得最新数据冰糖调整计数器 result = xhr.responseText.substring(received); received += result.length; //调用回调函数 progress(result); &#125; else if (xhr.readyState == 4) &#123; finished(xhr.responseText); &#125; &#125;; xhr.send(null); return xhr;&#125;var client = createStreamingClient("streaming.php", function (data) &#123; alert("Received: " + data);&#125;, function (data) &#123; alert("Done!");&#125;); 服务器发送事件SSE（Server-Sent Events，服务器发送事件）是围绕只读Comet交互推出的API或者模式。SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的MIME类型必须婧text/event-stream,而且是浏览器中的JavaScript API能解析格式输出。SSE支持短轮询、长轮询和HTTP流，而且能在断开连接时自动确定何时重新连接。 SSE API123var source = new EventSource("event.php")//手动关闭连接source.close() EventSource有一个readyState属性0：正在链接到服务器1：打开了连接2：关闭了连接EventSource三个事件 open：在建立连接时触发。 message：在从服务器接收到新事件时触发。 error：在无法建立连接时触发 事件所谓的服务器事件会通过一个持久的HTTP响应发送·这个响应的MIME类型为text/event-stream,响应的格式是纯文本，最简单的情况是每个数据项都带有前缀data1234data:foodata:bardata:foodata:bar 对以上响应而言，事件流中的第一个message事件返回的event.data值为’foo’，第二个message事件返回的event．data值为”bar”,第三个message事件返回的event.data值为”foo\nbar·（注意中间的换行符）。对于多个连续的以data：开头的数据行，将作为多段数据解析，每个值之间以一个换行符分隔。只有在包含data：的数据行后面有空行时，才会触发message事件，因此在服务器上生成事件流时不能忘了多添加这一行。 通过id：前缀可以给特定的事件指定一个关联的ID，这个ID行位于data：行前面或后面皆可：data：fooid：1 设置了ID后，Eventsource对象会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个包含名为Last-Event-ID的特殊HTTP头部的请求，以便服务器知道下一次该触发哪个事件。在多次连接的事件流中，这种机制可以确保浏览器以正确的顺序收到连接的数据段。 Web Sockets在JavaScript中创建了Web Socket之后，会有一个HTTP请求发到浏览器以发起连接。在取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为Web Socket协议。由于WebSockets使用了自定义的协议，所以URL模式也略有不同。未加密的连接不再是http，而是ws。加密的连接也不是https，而是wss。 Web Sockets API必须给WebSocket构造函数 传入绝对URL。同源策略对Web Socket不适用。1var socket = new WebSocket("ws://www.examplr.com/server.php") 实例化WebSocket对象后，浏览器就会马上尝试创建链接readyState属性表示当前状态 Websocket.OPENING（0）：正在建立连接。 WebSocket.OPEN（1）：已经建立连接 WebSoCket.CLOSING（2）正在关闭连接。 WebSocket．CLOSE（3）已经关团连接。关闭连接 1socket.close() 发送和接收数据12345678910111213var socket = new WebSocket("ws://www.examplr.com/server.php")var socket = new WebSocket("ws://www.examplr.com/server.php")socket.send("hello world!")//由于只能发送纯文本数据，对于复杂的数据必须进行序列化var message = &#123; time: new Date(), text: 'hello world'&#125;socket.send(JSON.stringify(message))//当服务器向客户端发来消息时，WebSocket对象就会触发message事件。socket.onmessage = function (event) &#123; var data = event.data&#125; 其他事件Web Socket事件 open：在成功建立连接时触发。 error：在发生错误时触发，连接不能持续。 close：在连接关团时触发WebSocket不支持DOM2级事件侦听器。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mona Lisa]]></title>
    <url>%2F2016%2F07%2F06%2F208%2F</url>
    <content type="text"><![CDATA[Erupean jazz trio是我个人挺喜欢的一支小众爵士乐队。网上对他的介绍也少得可怜，在维基百科上仅仅是“European Jazz Trio, a jazz group co-founded by Marc van Roon。其实严格来说，不算是一支爵士风格的乐队，因为这个乐队曲目融合了古典流行爵士等风格。比如这张《Mona Lisa》，里面的最后一曲《The Londonderry Air》，跟弦乐的mix在一起，更像是仲夏晴朗午后一杯加了奶的咖啡。]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Jazz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的Web服务器]]></title>
    <url>%2F2016%2F06%2F30%2F191%2F</url>
    <content type="text"><![CDATA[Hello, Web现在，我们开始编写一个简单的Web服务器，基本思路如下： 等到别人连接到我们的服务器并发送HTTP请求 分析请求 搞清楚要回复什么 从数据库中获取数据 生成HTML文件 发送回去 Python有一个叫BaseHTTPServer的内置模块可以完成第1,2,6步的工作。在下面的例子中，我们只需要完成3~5步就可以了1234567891011121314class RequestHandler(BaseHTTPServer.BaseHTTPRequestHandler): Page = '''\ &lt;html&gt; &lt;body&gt; &lt;p&gt;Hello, web!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; ''' def do_GET(self): self.send_response(200) self.send_header("Content-type", "text/html") self.send_header("Content-Length", str(len(self.Page))) self.end_headers() self.wfile.write(self.Page) BaseHTTPRequestHandler类接收HTTP请求并决定使用什么方法处理请求。如果请求方法是GET，将会调用do_GET方法。我们的类RequestHandler重载了BaseHTTPRequestHandler。字符串变量Page 里面存放着我们回复客户端的HTML文档；方法send_response返回状态码200；方法send_header添加HTML头；方法end_headers插入一空行，分割头部跟页面。1234if __name__ == '__main__': serverAddress = ('', 8080) server = BaseHTTPServer.HTTPServer(serverAddress, RequestHandler) server.serve_forever() serverAddress 是个包含服务器地址跟端口的tuple，服务器地址为空字符串代表“本机”。然后我们创造BaseHTTPServer.HTTPServer的实例，然后运行。运行效果 更进一步我们一般很少用到完全静态的HTML文档。一般来说，都是用模板生成HTML文档。Page就是我们的模板`1234567891011121314Page = '''\ &lt;html&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;Header&lt;/td&gt; &lt;td&gt;Value&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Date and time&lt;/td&gt; &lt;td&gt;&#123;date_time&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Client host&lt;/td&gt; &lt;td&gt;&#123;client_host&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Client port&lt;/td&gt; &lt;td&gt;&#123;client_port&#125;s&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Command&lt;/td&gt; &lt;td&gt;&#123;command&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Path&lt;/td&gt; &lt;td&gt;&#123;path&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; ''' 我们不妨上面的do_GET方法分开，分成生成跟发送两部分。12345678910111213141516171819202122232425262728293031323334class RequestHandler(BaseHTTPServer.BaseHTTPRequestHandler): def do_GET(self): page = self.create_page() self.send_page(page) def create_page(self): pass def send_page(self, page): pass#发送部分，我们直接我们刚刚写的代码复制过来def send_page(self, page): self.send_response(200) self.send_header("Content-type", "text/html") self.send_header("Content-Length", str(len(page))) self.end_headers() self.wfile.write(page)#生成部分def create_page(self): values = &#123; 'date_time' : self.date_time_string(), 'client_host' : self.client_address[0], 'client_port' : self.client_address[1], 'command' : self.command, 'path' : self.path &#125; page = self.Page.format(**values) return page## 主题部分依然不变if __name__ == '__main__': serverAddress = ('', 8080) server = BaseHTTPServer.HTTPServer(serverAddress, RequestHandler) server.serve_forever() 运行效果 注意到，就算我们目录下没有“test.html”这个文件，也不会遇到404错误。 提供静态页面服务下一步，我们要编写一个真正能够工作的服务器——它会从我们的运行目录里读取任何静态的HTML文件。 分类和处理请求12345678910111213141516171819202122232425def do_GET(self): try: # 搜索当前目录下有无此HTML文档 full_path = os.getcwd() + self.path # 如果不存在 if not os.path.exists(full_path): raise ServerException("'&#123;0&#125;' not found".format(self.path)) # 如果存在 elif os.path.isfile(full_path): self.handle_file(full_path) #无法处理 else: raise ServerException("Unknown object '&#123;0&#125;'".format(self.path)) except Exception as msg: self.handle_error(msg)#handle_file 方法，读取HTML文件并使用send_content法返回内容def handle_file(self, full_path): try: # 以二进制模式打开 with open(full_path, 'rb') as reader: content = reader.read() self.send_content(content) except IOError as msg: msg = "'&#123;0&#125;' cannot be read: &#123;1&#125;".format(self.path, msg) self.handle_error(msg) 我们必须还要对错误情况进行处理 显示错误的页面123456789101112131415161718192021222324252627Error_Page = """\&lt;html&gt;&lt;body&gt;&lt;h1&gt;Error accessing &#123;path&#125;&lt;/h1&gt;&lt;p&gt;&#123;msg&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"""def handle_file(self, full_path): try: with open(full_path, 'rb') as reader: content = reader.read() self.send_content(content) except IOError as msg: msg = "'&#123;0&#125;' cannot be read: &#123;1&#125;".format(self.path, msg) self.handle_error(msg)#错误处理def handle_error(self, msg): content = self.Error_Page.format(path=self.path, msg=msg) self.send_content(content, 404)# 发送def send_content(self, content, status=200): self.send_response(status) self.send_header("Content-type", "text/html") self.send_header("Content-Length", str(len(content))) self.end_headers() self.wfile.write(content) 运行效果 监听目录下一步，我们编写一个可以显示文件列表的服务器（当访问的是文件夹的时候）。或者更深一步，访问文件夹的时候首先看目录下有没有index.html文件，若没有显示文件夹文件列表。我们重写了do_GET方法 分类和处理请求123456789101112def do_GET(self):try: #计算出物理路径. self.full_path = os.getcwd() + self.path # 找出用来处理请求的case. for case in self.Cases: if case.test(self): case.act(self) break# 错误处理except Exception as msg: self.handle_error(msg) 首先我们计算请求的物理路径。接下来的代码跟之前有很大不同，通过遍历Cases列表。每一个case都是一个只有两个方法（test，判断是否能处理请求；act，处理请求）的object。我们将self作为参数传进去test和act方法作进一步的处理。这里的self指的是RequestHandler实例（别忘了，我们是在编写RequestHandler的方法do_GET）下面是case类12345678910111213141516171819202122232425262728293031323334353637383940class case_no_file(object): '''文件或目录不存在''' def test(self, handler): return not os.path.exists(handler.full_path) def act(self, handler): raise ServerException("'&#123;0&#125;' not found".format(handler.path))#-------------------------------------------------------------------------------class case_existing_file(object): '''文件存在''' def test(self, handler): return os.path.isfile(handler.full_path) def act(self, handler): handler.handle_file(handler.full_path)#-------------------------------------------------------------------------------class case_directory_index_file(object): '''处理目录下的index.html文件''' def index_path(self, handler): return os.path.join(handler.full_path, 'index.html') def test(self, handler): return os.path.isdir(handler.full_path) and \ os.path.isfile(self.index_path(handler)) def act(self, handler): handler.handle_file(self.index_path(handler))#-------------------------------------------------------------------------------class case_directory_no_index_file(object): '''如果没有index.html，列出目录文件列表''' def index_path(self, handler): return os.path.join(handler.full_path, 'index.html') def test(self, handler): return os.path.isdir(handler.full_path) and \ not os.path.isfile(self.index_path(handler)) def act(self, handler): handler.list_dir(handler.full_path)#-------------------------------------------------------------------------------class case_always_fail(object): '''最底层的case类，处理其他case不能处理的情况''' def test(self, handler): return True def act(self, handler): raise ServerException("Unknown object '&#123;0&#125;'".format(handler.path)) 前面提到，在do_GET方法里面，将RequestHandler的实例作为handler参数传进去。在act方法里面调用RequestHandler（在act函数里面，handler就是RequestHandler的实例）的方法（如list_dir，handle_file等）进行处理。然后，我们把RequestHandler类完善一下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class RequestHandler(BaseHTTPServer.BaseHTTPRequestHandler): Cases = [case_no_file(), case_existing_file(), case_directory_index_file(), case_directory_no_index_file(), case_always_fail()] # 错误页面 Error_Page = """\ &lt;html&gt; &lt;body&gt; &lt;h1&gt;Error accessing &#123;path&#125;&lt;/h1&gt; &lt;p&gt;&#123;msg&#125;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; """ # 目录文件列表 Listing_Page = '''\ &lt;html&gt; &lt;body&gt; &lt;ul&gt; &#123;0&#125; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; ''' #分类和处理请求 def do_GET(self): try: #计算出物理路径. self.full_path = os.getcwd() + self.path # 找出用来处理请求的case. for case in self.Cases: if case.test(self): case.act(self) break # 错误处理 except Exception as msg: self.handle_error(msg) #读取HTML文件并使用send_content方法返回内容 def handle_file(self, full_path): try: with open(full_path, 'rb') as reader: content = reader.read() self.send_content(content) except IOError as msg: msg = "'&#123;0&#125;' cannot be read: &#123;1&#125;".format(self.path, msg) self.handle_error(msg) # 列出当前目录下的文件并使用send_content方法返回 def list_dir(self, full_path): try: entries = os.listdir(full_path) bullets = ['&lt;li&gt;&#123;0&#125;&lt;/li&gt;'.format(e) for e in entries if not e.startswith('.')] page = self.Listing_Page.format('\n'.join(bullets)) self.send_content(page) except OSError as msg: msg = "'&#123;0&#125;' cannot be listed: &#123;1&#125;".format(self.path, msg) self.handle_error(msg) def handle_error(self, msg): content = self.Error_Page.format(path=self.path, msg=msg) self.send_content(content, 404) # 发送 def send_content(self, content, status=200): self.send_response(status) self.send_header("Content-type", "text/html") self.send_header("Content-Length", str(len(content))) self.end_headers() self.wfile.write(content) 运行结果 CGI协议当然，大多数人都不想每次添加新的功能都修改服务器的源代码。一般都服务器都支持一套叫做“通用网关接口”的东西，允许Web服务器执行外部程序，并将它们的输出发送给Web浏览器。 CGI。在物理上是一段程序，运行在服务器上，提供同客户端HTML页面的接口。这样说大概还不好理解。那么我们看一个实际例子：现在的个人主页上大部分都有一个留言本。留言本的工作是这样的：先由用户在客户端输入一些信息，如评论之类的东西。接着用户按一下“发布或提交”（到目前为止工作都在客户端），浏览器把这些信息传送到服务器的CGI目录下特定的CGI程序中，于是CGI程序在服务器上按照预定的方法进行处理。在本例中就是把用户提交的信息存入指定的文件中。然后CGI程序给客户端发送一个信息，表示请求的任务已经结束。此时用户在浏览器里将看到“留言结束”的字样。整个过程结束。 假设我们想要服务器在HTML文档里显示本地时间，将其保存为simple.py1234567from datetime import datetimeprint '''\&lt;html&gt;&lt;body&gt;&lt;p&gt;Generated &#123;0&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'''.format(datetime.now()) 我们添加一个case handlertest方法检查目录下的py文件，如果有就可以用RequestHandler的run_cgi方法执行123456class case_cgi_file(object): def test(self, handler): return os.path.isfile(handler.full_path) and \ handler.full_path.endswith('.py') def act(self, handler): handler.run_cgi(handler.full_path) run_cgi核心思想很简单： 在子程序中运行程序 捕获标准输出 把数据发送回客户端 一个完整的CGI协议肯定比这复杂。比如，它要处理URL里面的参数。。。1234567def run_cgi(self, full_path): cmd = "python " + full_path child_stdin, child_stdout = os.popen2(cmd) child_stdin.close() data = child_stdout.read() child_stdout.close() self.send_content(data) 最后，我们把case handler类重写。所有case handler都继承base_case这个case handler基类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class base_case(object): def handle_file(self, handler, full_path): try: with open(full_path, 'rb') as reader: content = reader.read() handler.send_content(content) except IOError as msg: msg = "'&#123;0&#125;' cannot be read: &#123;1&#125;".format(full_path, msg) handler.handle_error(msg) def index_path(self, handler): return os.path.join(handler.full_path, 'index.html') def test(self, handler): assert False, 'Not implemented.' def act(self, handler): assert False, 'Not implemented.'case handlerclass case_no_file(base_case): def test(self, handler): return not os.path.exists(handler.full_path) def act(self, handler): raise ServerException("'&#123;0&#125;' not found".format(handler.path))#-------------------------------------------------------------------------------class case_cgi_file(base_case): def run_cgi(self, handler): cmd = "python " + handler.full_path child_stdin, child_stdout = os.popen2(cmd) child_stdin.close() data = child_stdout.read() child_stdout.close() handler.send_content(data) def test(self, handler): return os.path.isfile(handler.full_path) and \ handler.full_path.endswith('.py') def act(self, handler): self.run_cgi(handler)#-------------------------------------------------------------------------------class case_existing_file(base_case): def test(self, handler): return os.path.isfile(handler.full_path) def act(self, handler): self.handle_file(handler, handler.full_path)#-------------------------------------------------------------------------------class case_directory_index_file(base_case): def test(self, handler): return os.path.isdir(handler.full_path) and \ os.path.isfile(self.index_path(handler)) def act(self, handler): self.handle_file(handler, self.index_path(handler))#-------------------------------------------------------------------------------class case_directory_no_index_file(base_case): Listing_Page = '''\ &lt;html&gt; &lt;body&gt; &lt;ul&gt; &#123;0&#125; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; ''' def list_dir(self, handler, full_path): try: entries = os.listdir(full_path) bullets = ['&lt;li&gt;&#123;0&#125;&lt;/li&gt;'.format(e) for e in entries if not e.startswith('.')] page = self.Listing_Page.format('\n'.join(bullets)) handler.send_content(page) except OSError as msg: msg = "'&#123;0&#125;' cannot be listed: &#123;1&#125;".format(self.path, msg) handler.handle_error(msg) def test(self, handler): return os.path.isdir(handler.full_path) and \ not os.path.isfile(self.index_path(handler)) def act(self, handler): self.list_dir(handler, handler.full_path)#-------------------------------------------------------------------------------class case_always_fail(base_case): def test(self, handler): return True def act(self, handler): raise ServerException("Unknown object '&#123;0&#125;'".format(handler.path))]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写一个简单的模板引擎]]></title>
    <url>%2F2016%2F06%2F24%2F165%2F</url>
    <content type="text"><![CDATA[前言我们知道，互联网上的HTML页面极少是完全静态的。它们都或多或少掺入一些动态数据（比如，用户名），通常一个网页会含有大量的动态数据：展示的商品，或好友的动态等等。 怎么用一种简单的方法将动态数据插入到完全静态的页面中？要解决这个问题，我们必须设计出一种前端人员熟悉的类似于HTML标记语言的方式，将动态数据插入到静态的HTML页面中。举个例子1234567&lt;p&gt;Welcome, Vincent!&lt;/p&gt;&lt;p&gt;Products:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Apple: $1.00&lt;/li&gt; &lt;li&gt;Fig: $1.50&lt;/li&gt; &lt;li&gt;Pomegranate: $3.25&lt;/li&gt;&lt;/ul&gt; 我们知道，用户名是要动态的，因为页面根据不同的用户呈现出不同的效果；水果的列表也要是动态的，因为水果的价格不能一成不变，它需要从数据库中获取数据，动态改变价格或种类。 为了让HTML文档在我们代码中以字符串形式显示，我们必须将需要动态处理的数据单独标记出来，以便程序进行处理。12345678PAGE_HTML = """ &lt;p&gt;Welcome, &#123;name&#125;!&lt;/p&gt; &lt;p&gt;Products:&lt;/p&gt; &lt;ul&gt; &#123;products&#125; &lt;/ul&gt;"""PRODUCT_HTML = "&lt;li&gt;&#123;prodname&#125;: &#123;price&#125;&lt;/li&gt;\n" 可以看到，整个页面被放在名为PAGE_HTML的字符串中；而可以用循环显示的数据（如我们的水果清单）可以单独放在用名为PRODUCT_HTML的字符串。1234567def make_page(username, products): product_html = "" for prodname, price in products.iteritems(): product_html += PRODUCT_HTML.format( prodname=prodname, price=price) html = PAGE_HTML.format(name=username, product=product_html) return html 在上面的代码中，我们向make_page函数传入一个字符串与一个字典，分别表示用户名与水果。通过字符串的format函数可以将HTML中的标记的动态数据替换成我们想要的数据。可以看出，程序确实可以运行。但是随之而来的一个问题是，这段代码使用Python写的，不懂Python的人就不能使用了。而且，这只是个简单的HTML就已经要写如此复杂的代码。设想一下，当要处理的HTML文档是现在的100倍的时候，工作量是该有多大。 模板（Templates）最好的方法是，前端人员可以直接在HTML文档里面编辑，甚至使用一些简单的语句。12345678&lt;p&gt;Welcome, &#123;&#123;user_name&#125;&#125;!&lt;/p&gt;&lt;p&gt;Products:&lt;/p&gt;&lt;ul&gt;&#123;% for product in product_list %&#125; &lt;li&gt;&#123;&#123; product.name &#125;&#125;: &#123;&#123; product.price|format_price &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 我们知道，Python中的字符串是通过双引号或单引号标记起来的。当解释器遇到第一个双引号的时候，它就知道“哦，这里是一个字符串”，一直直到它遇到第二个双引号的时候，表示字符串的结束。 在我们的模板中也一样，当模板引擎遇到“&#123;&#123;”的时候，它就知道“哦，这里会输出一个表达式”，一直直到遇到“&#125;&#125;”才结束。1&lt;p&gt;Welcome, &#123;&#123;user_name&#125;&#125;!&lt;/p&gt; 我们从头开始看，“&lt;p&gt;Welcome, ”是静态的HTML内容，一直到遇到“&#123;&#123;”的时候，切换到动态模式，在输出的时候使用变量user_name代替。这让我们想到在Python里面，有类似的格式化函数1&lt;p&gt;Welcome, &#123;user_name&#125;!&lt;/p&gt;".format(user_name="vincent") 当然，模板还可以使用条件判断语句跟循环语句。 这些文件被称为“模板”，是因为他们使用相同的结构却能生成许多内容不同的页面。为了在我们的程序中使用HTML模板，我们需要编写一个模板引擎（template engine）：接受静态的模板，通过把动态数据与其组合起来，生成一个HTML文档。我们把这称为模板的解析（interpret）——把模板动态部分换成真实的数据。 语法模板引擎的语法不尽相同。接下来要编写的模板引擎的语法跟Django的（一个著名的Web框架）差不多。 表达式表达式在我们的模板引擎中用两对大括号括起来。它可是是一个变量，亦或是变量调用的方法。1&lt;p&gt;Welcome, &#123;&#123;user_name&#125;&#125;!&lt;/p&gt; 在Python中，我们可以用如下方法访问变量的属性或方法。123dict["key"]obj.attrobj.method() 在我们编写的模板引擎中，我们统一使用”.”操作符。来获取属性，如果获取的是可执行的方法将会自动执行。1234dict.keyobj.attrobj.method&lt;p&gt;The price is: &#123;&#123;product.price&#125;&#125;, with a &#123;&#123;product.discount&#125;&#125;% discount.&lt;/p&gt; 我们也能用一个叫做“过滤器（filter）”的函数，过滤我们想要的数据。过滤器通过“|”分割 1&lt;p&gt;Short name: &#123;&#123;story.subject|slugify|lower&#125;&#125;&lt;/p&gt; 条件判断语句条件判断语句，这是必须的。123&#123;% if user.is_logged_in %&#125; &lt;p&gt;Welcome, &#123;&#123; user.name &#125;&#125;!&lt;/p&gt;&#123;% endif %&#125; 循环语句循环能大大减少了代码量123456&lt;p&gt;Products:&lt;/p&gt;&lt;ul&gt; &#123;% for product in product_list %&#125; &lt;li&gt;&#123;&#123; product.name &#125;&#125;: &#123;&#123; product.price|format_price &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125; &lt;/ul&gt; 注释注释功能还是挺重要的1&#123;# This is the best template ever! #&#125; 开始着手模板引擎通常会做两件事： 分析模板（parsing the template）渲染模板（rendering the template）： 在模板中找出动态数据 处理逻辑语句（模板中的条件判断或循环语句） 执行点操作符和过滤器 问题的关键是我们如何把分析模板跟渲染模板连接在一起，也就是我们要通过“分析模板”这个步骤得出些什么东西——这些东西能够被渲染到HTML文件中。方法主要有两种：解析（interpretation）和编译（compilation）。 在解释型模板引擎中：“分析模板”阶段的产物是一些代表模板的数据，然后每次“渲染模板”阶段都要运重复这个过程。著名Web框架Django里面的模板引擎就是其中的代表。在编译型模板引擎中：“分析模板”阶段的产物是一些可直接执行的代码，“渲染模板”阶段执行这些代码并得到静态的HTML文件，无须再次编译。Jinja2与Mako就是其中的代表。 在速度方面，编译型模板引擎在第一次运行模板的时候速度会比解释型模板引擎要慢，而当第二次第三次…执行的时候，编译型模板引擎会比解释型模板引擎快。这是一个典型的“空间换时间”的例子。 我们的模板是编译型模板引擎，我们把模板编译成Python代码。每次运行这些Python代码都会渲染得到静态的HTML文件。我们的模板编译器应用到了代码生成（code generation）的技术，代码生成可以产生很多灵活而又功能强大的工具，包括但不限于程序语言编译器（programming language compilers）。代码生成可能比较复杂，但很实用。 编译成Python代码我们看回前面的代码。在分析模板阶段，模板引擎将会把它们转变成Python函数。12345678&lt;p&gt;Welcome, &#123;&#123;user_name&#125;&#125;!&lt;/p&gt;&lt;p&gt;Products:&lt;/p&gt;&lt;ul&gt; &#123;% for product in product_list %&#125; &lt;li&gt;&#123;&#123; product.name &#125;&#125;: &#123;&#123; product.price|format_price &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; 模板引擎会把模板转变成Python代码，虽然转换的结果看起来有点奇怪。12345678910111213141516171819202122def render_function(context, do_dots): c_user_name = context['user_name'] c_product_list = context['product_list'] c_format_price = context['format_price'] result = [] append_result = result.append extend_result = result.extend to_str = str extend_result([ '&lt;p&gt;Welcome, ', to_str(c_user_name), '!&lt;/p&gt;\n&lt;p&gt;Products:&lt;/p&gt;\n&lt;ul&gt;\n' ]) for c_product in c_product_list: extend_result([ '\n &lt;li&gt;', to_str(do_dots(c_product, 'name')), ':\n ', to_str(c_format_price(do_dots(c_product, 'price'))), '&lt;/li&gt;\n' ]) append_result('\n&lt;/ul&gt;\n') return ''.join(result) 每一个模板都会被转换成一个名为render_function的函数，第一个参数接收一个字典（第二个参数我们后面说）。 我们看看函数的开始我们把字典解包出来（因为这样会使得二次访问的时候速度更快），赋给带前缀“c_”的变量（加上前缀避免了命名冲突）123c_user_name = context['user_name'] c_product_list = context['product_list'] c_format_price = context['format_price'] 我们注意到append，extend，str方法赋给了局部变量result_append，result_extend和str。123append_result = result.appendextend_result = result.extendto_str = str 为什么要这样做？我们看得更深一些。 Python里面对象（Object）的方法（method）（如result.append(“hello”)）虽然看起来好像是一步执行，其实执行分为两步。第一步，获取对象的方法result.append；第二步，传递参数”hello”。所以我们可以将第一步的结果保存起来。这样做我们可以节省一步，这些细小的优化节省了一点点时间。1234#以下语句执行的结果一样result.append("hello")append_result = result.append append_result("hello") to_str也是一个细小的优化。Python里面，寻找局部变量比寻找全局变量或内置的对象和函数都要快。str是一个Python内置的对象，虽然无论在那里都可以使用，但是Python每次还是会寻找str。将其赋给一个局部变量，将会节省一点点时间。1234#string1与string2内容一样string1=str("hello world")to_str=strstring2=to_str("hello world") 接下来，我们使用result_append，result_extend把字符串添加到列表中。12&#123;&#123; ... &#125;&#125;：被转换成表达式，的点操作符使用函数do_dots （render_function的第二个参数）执行。&#123;% if ... %&#125; 或&#123;% for ... %&#125;：被转换成Python的条件判断和循环语句if与for。&#123;% endif%&#125;或&#123;% end或%&#125;代表语句的结束。 最后函数返回的是字符串。将多个部分的字符串快速转换拼接为长字符串的方法是，创建一个列表然后把他们join起来。1return ''.join(result) 编写引擎CodeBuilder类在我们编写Template类之前。我们先看看CodeBuilder。 模板引擎主要的工作就是分析模板并产生大量的Python代码。为了方便生成大量的Python代码，我们编写了CodeBuilder类，它生成代码，管理Python的缩进。为什么要管理缩进？因为我们要生成的Python代码是字符串的形式，然后使用exec函数执行。而Python是基于缩进来定义语法的，所以我们必须有一套办法来管理Python的缩进。 接来下我们开始编写，我们先看构造函数。构造函数生成一个名为code列表，用来保存最终生产的Python代码，还有一个名为indent_level 整形变量，用来管理Python的缩进。123def __init__(self, indent=0): self.code = [] self.indent_level = indent 我们重载了__str__方法，__str__返回一个字符串，将列表code里面的代码连接成字符串。12def __str__(self): return "".join(str(c) for c in self.code) add_line函数生成一行新的代码，它会根据当前的缩进自动进行代码的缩进和换行。12def add_line(self, line): self.code.extend([" " * self.indent_level, line, "\n"]) 根据Python的PEP8规范，规定一个缩进等于4个空格1INDENT_STEP = 4 indent和dedent方法，分别增加与减少缩进1234def indent(self): self.indent_level += self.INDENT_STEPdef dedent(self): self.indent_level -= self.INDENT_STEP add_section函数，生成一个新的CodeBuilder类。将当前列表code的代码连接成字符串（自动调用str方法），放入新的CodeBuilder类中，返回新的CodeBuilder类。1234 def add_section(self): section = CodeBuilder(self.indent_level)self.code.append(section)return section get_globals函数，执行code的代码（在我们的模板引擎中，也就是定义一个函数。），返回一个名为global_namespace的字典，里面包含有刚定义的函数。123456def get_globals(self): assert self.indent_level == 0 python_source = str(self) global_namespace = &#123;&#125; exec (python_source, global_namespace) return global_namespace 如下面的代码中，global_namespace[‘SEVENTEEN’]就是数字17，global_namespace[‘three’]就是刚定义的函数three。123456python_source = """ \ SEVENTEEN = 17 def three():return 3"""global_namespace = &#123;&#125;exec(python_source, global_namespace) 到此为止，我们的CodeBuilder类就已经完成了。CodeBuilder其实跟模板引擎没多大关系，我们仅仅是通过它来生成模板渲染的函数render_function。当然利用CodeBuilder定义的函数，因为不同的命名空间，所以完全避免的名字相同带来的冲突问题。 Template类Template类仅有少数的接口，构造函数接收类型为字符串的模板。它的render方法通过接收一个字典，进行模板的渲染。 我通过向Template的构造函数传入模板，产生一个实例，我们就完成了编译。之后我们可以多次调用render方法渲染，从而得到不同的结果。 构造函数还接收一个字典（一般来说，是一些过滤器），把它放在template类中，当我们调用render方法的时候会用到。12345678910template= Template( ''' &lt;h1&gt;Hello &#123;&#123;name|upper&#125;&#125;!&lt;/h1&gt; &#123;% for topic in topics %&#125; &lt;p&gt;You are interested in &#123;&#123;topic&#125;&#125;.&lt;/p&gt; &#123;% endfor %&#125; ''', &#123;'upper': str.upper&#125;, ) text = template.render(&#123; 'name': "Ned", 'topics': ['Python', 'Geometry', 'Juggling'], &#125;) 编译Duang！接来下我们开始编写，我们先看构造函数。编译的主要工作都在构造函数里面，构造函数时整个Template类的重中之重。我们一点一点来。 构造函数接收一个字符串以及多个变量（这些变量可以是函数，也可以是列表，字符串等在模板里面要用到的东西），将多个变量放入内部定义的context字典中。1234def __init__(self, text, *contexts): self.context = &#123;&#125; for context in contexts: self.context.update(context) 我们还需要一个集合来存放定义的变量。集合all_vars存放所有模板里面出现的变量，集合loop_vars存放模板循环里面（如for循环）里面出现的变量。你现在可能感到困惑，等会儿你就知道这两个小东西对我们有啥帮助了。12self.all_vars = set()self.loop_vars = set() 我们遇到了之前我们写的CodeBuilder类。我们通过add_line方法添加一行Python语句，定义一个名为render_function的函数，之前我们讲过render_function函数的第一个参数接收一个字典参数，第二个参数接收一个点操作符执行函数do_dots。 注意到CodeBuilder类十分简单，它甚至不知自己在做什么，它只会生成一行行新的代码。 我们使用了add_section方法生成一个新的CodeBuilder实例，并把之前编写的代码放入其中。这可以方便我们以后插入代码。12345678code = CodeBuilder()code.add_line("def render_function(context, do_dots):")code.indent()vars_code = code.add_section()code.add_line("result = []")code.add_line("append_result = result.append")code.add_line("extend_result = result.extend")code.add_line("to_str = str") 接下来我们定义一个flush_output函数，帮我们把buffered里面的Python语句通过CodeBuilder的add_line方法把添加到CodeBuilder实例的code列表中。1234567buffered = [] def flush_output(): if len(buffered) == 1: code.add_line("append_result(%s)" % buffered[0]) elif len(buffered) &gt; 1: code.add_line("extend_result([%s])" % ", ".join(buffered)) del buffered[:] 回到我们的模板，当我们处理模板的条件判断语句或循环语句的时候，我们想要确认这些语句是否正确。我们就需要一个栈。例如，当我们遇到一个&#123;% if .. %&#125;标签的时候。我们把“if”push进栈；当我们遇到&#123;% endif %&#125;的时候，我们pop栈，如果没有“if”在栈顶的话，将会报错。1 ops_stack = [] 现在，我们正式开始分析模板。通过正则表达式，我们把模板分成各个部分，然后放入列表tokens中。 re.split是一个用正则表达式把一个长字符串分割成几个短字符串的函数；r表示raw_string；?s说明“.”匹配任何东西，包括换行符；&#123;&#123;.?&#125;&#125;，&#123;%.?%&#125;，&#123;#.*?#&#125;分别匹配表达式，条件判断与循环语句，注释。1 tokens = re.split(r"(?s)(&#123;&#123;.*?&#125;&#125;|&#123;%.*?%&#125;|&#123;#.*?#&#125;)", text) 如果，有如下模板：1&lt;p&gt;Topics for &#123;&#123;name&#125;&#125;: &#123;% for t in topics %&#125;&#123;&#123;t&#125;&#125;, &#123;% endfor %&#125;&lt;/p&gt; 我们把它分割成：1234567891011['&lt;p&gt;Topics for ', '&#123;&#123;name&#125;&#125;', ': ','&#123;% for t in topics %&#125;', '','&#123;&#123;t&#125;&#125;', ', ','&#123;% endfor %&#125;', '&lt;/p&gt;'] 一件将模板分割成上面这样的列表，我们就可以遍历tokens列表并做下一步处理了。 每个token都被检测，看符合四种情况的哪一种。我们只需要检查前两个字符就可以。第一种情况是注释，我们直接忽略。123 for token in tokens: if token.startswith('&#123;#'): continue 对于&#123;&#123;…&#125;&#125;，我们砍掉两对大括号，忽略前后的空格，把里面的语句提取出来。然后把它传递给_expr_code方法。_expr_code方法会把我们模板的表达式转化成Python的表达式。我们会在后面详细说_expr_code这个方法。123 elif token.startswith('&#123;&#123;'): expr = self._expr_code(token[2:-2].strip()) buffered.append("to_str(%s)" % expr) 第三种情况就是&#123;% … %&#125;，首先我们运行flush_output函数通过CodeBuilder的add_line方法把buffered里面的Python语句添加到CodeBuilder实例的code列表中。123 elif token.startswith('&#123;%'): flush_output() words = token[2:-2].strip().split() 现在我们对于if，for或者end这三种情况分别作出不同的处理。 对于if的情况。if标签通常只有一个表达式，所以对于长度不符的情况，我们使用_syntax_error方法抛出一个错误。我们把“if”压进栈 ops_stack，以便我们检查endif标签。然后通过_expr_code方法，把if标签里面的表达式编译成Python可识别的代码。123456if words[0] == 'if': if len(words) != 2: self._syntax_error("Don't understand if", token) ops_stack.append('if') code.add_line("if %s:" % self._expr_code(words[1])) code.indent() 第二种情况就是for，这里出现了一个新的方法_variable。还记得我们之前说过的两个用来放变量的集合吗？方法_variable的作用除了检查变量是否有非法字符外，还会将变量添加到集合中。为了避免命名冲突，我们还把变量的名字加上了“c_”的前缀。注意，for..in的in后面可能跟的是一个变量，亦或是一个可迭代的表达式（如 for i in range(10)）。所以我们要使用_expr_code方法。123456789101112elif words[0] == 'for': if len(words) != 4 or words[2] != 'in': self._syntax_error("Don't understand for", token) ops_stack.append('for') self._variable(words[1], self.loop_vars) code.add_line( "for c_%s in %s:" % ( words[1], self._expr_code(words[3]) ) ) code.indent() 最后一种情况就是end，通过字符串的切片提取，与ops_stack栈顶的元素作比较，判断语句是否正确。最后注意到有一个反缩进。12345678910elif words[0].startswith('end'): if len(words) != 1: self._syntax_error("Don't understand end", token) end_what = words[0][3:] if not ops_stack: self._syntax_error("Too many ends", token) start_what = ops_stack.pop() if start_what != end_what: self._syntax_error("Mismatched end tag", end_what) code.dedent() 对于不可识别的，我们通过_syntax_error方法抛出错误12else: self._syntax_error("Don't understand tag", words[0]) 这样我们就完成了模板里面的三种不同的语法&#123;&#123;…&#125;&#125; ， &#123;#…#&#125; 和 &#123;%…%&#125; 的处理了。最后剩下普通的字符串。我们把它添加到buffered里面以便输出。repr函数与str函数类似，但是它是将对象转换成Python内部的字符串，而str是将对象转换成用户可读的友好的字符串。注意到我们的条件判断语句，主要就检测空的字符串，因为我们必须防止append_result(“”)这样无用的操作。123 else: if token: buffered.append(repr(token)) 最后，我们还需要检查一下ops_stack是否为空。当我们的语句都是合法的，有始有终的时候，ops_stack的值应为空的。如果不为空，我们已经在某处丢掉了end标签了。检查完之后，我们将调用flush_output函数，通过CodeBuilder的add_line方法把buffered里面的Python语句添加到CodeBuilder实例的code列表中123 if ops_stack: self._syntax_error("Unmatched action tag", ops_stack[-1]) flush_output() 我们来看看一个模板1234567&lt;p&gt;Welcome, &#123;&#123;user_name&#125;&#125;!&lt;/p&gt; &lt;p&gt;Products:&lt;/p&gt; &lt;ul&gt; &#123;% for product in product_list %&#125; &lt;li&gt;&#123;&#123; product.name &#125;&#125;: &#123;&#123; product.price|format_price &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; 在模板中user_name与product是两个变量，因为他们在两对大括号之间。集合all_vars里面也有他们的名字，因为方法_expr_code将它们添加到集合allvars里面。但只有user name需要从模板中提取出来，因为product是在循环里面定义的变量。在模板里面的所有变量，都会保存在名为allvars的集合里面；而所有在模板的语句里面定义的变量，都会保存在名为loop vars的集合里面。所以我们需要把在all_vars集合 而不在loopvars集合里面的变量找出来。把context里面的变量解包出来，放入加上“c”前缀的同名变量中。12 for var_name in self.all_vars - self.loop_vars: vars_code.add_line("c_%s = context[%r]" % (var_name, var_name)) 最后。我们把CodeBuilder的属性code代码都连接起来。使用get_globals方法，执行code的代码（在我们的模板引擎中，也就是定义一个函数。（def render_function(..):）），返回一个名为global_namespace的字典，里面包含有刚定义的函数。 现在self._render_function就是一个Python函数了，我们将会在模板的渲染阶段用到这个函数。123 code.add_line("return ''.join(result)") code.dedent() self._render_function = code.get_globals()['render_function'] 编译表达式上面我们只介绍了模板中的变量与语句，还有一个很重要的方法_expr_code。_expr_code将模板中的表达式编译成Python中的表达式。接下来我们来编写上面一直提到的_expr_code方法。在我们编写的模板中，表达式可以是单独一个变量。1&#123;&#123;user_name&#125;&#125; 也可是包含属性方法和过滤器的复杂形式。1&#123;&#123;user.name.localized|upper|escape&#125;&#125; _expr_code方法必须能处理所有的情况。第一考虑的是我们的表达式中是否存在“|”，如果存在，我们把它分隔开来，放在列表pipes 中。把“|”分离之后，pipes[0]即为变量与”.“操作符，我们对其继续用_expr_code方法。pipes的其他项为过滤器函数的名字，我们把它逐个放入all_vars集合中。然后生成一条“函数链” 如&#123;&#123;user.name.localized|upper|escape&#125;&#125;，运行之后就得到code=c_escape(c_upper(user.name.localized))1234567def _expr_code(self, expr): if "|" in expr: pipes = expr.split("|") code = self._expr_code(pipes[0]) for func in pipes[1:]: self._variable(func, self.all_vars) code = "c_%s(%s)" % (func, code) 对于表达式中存在的“.”。首先我们要理解“.”操作符是如何操作的，在模板中x.y在Python中有两种意思：x[‘y’]或者x.y（表示哪种意思取决于x[‘y’]或者x.y哪种是可行的）。如果结果是可执行的，自动执行。这种不确定性表明了，我们只能在运行的时候尝试这些可能性，而不是在编译的时候。所以我们把x.y.z编译成一个调用的函数do_dots(x, ‘y’, ‘z’) do_dots 函数会在编译完成的Python代码运行的时候传递进去。我们后面会详细讲述如何编写这个函数。12345elif "." in expr: dots = expr.split(".") code = self._expr_code(dots[0]) args = ", ".join(repr(d) for d in dots[1:]) code = "do_dots(%s, %s)" % (code, args) _expr_code方法的最后一部分，没有“|”，没有“.”的表达式。注意的是，传进all_vars集合的只是名字而已。1234else: self._variable(expr, self.all_vars) code = "c_%s" % exprreturn code 辅助方法抛出一个异常12def _syntax_error(self, msg, thing): raise TempliteSyntaxError("%s: %r" % (msg, thing)) 检查变量是否有非法字符，将变量添加到集合中。1234def _variable(self, name, vars_set): if not re.match(r"[_a-zA-Z][_a-zA-Z0-9]*$", name): self._syntax_error("Not a valid name", name) vars_set.add(name) 渲染当我们把模板编译成Python函数之后。渲染函数要做的是，处理动态的数据，然后调用生成的Python函数。注意到，这里的self.context是一个包含需要用来渲染模板的动态数据和过滤器函数的字典。我们在Template类的构造函数里面已经update过，一般来说我们在Template类的构造函数里update的是过滤器的函数；在方法render里面update的是用来渲染模板的动态数据。因为创建了一个Template实例出来就说明编译完成。调用render，通过传入不同的context实现不同的渲染。12345def render(self, context=None): render_context = dict(self.context) if context: render_context.update(context) return self._render_function(render_context, self._do_dots) 接下来是最后一个方法_do_dots。在编译阶段，模板表达式如x.y.z被编译成do_dots(x, ‘y’, ‘z’) 。首先把dot当做attribute，如果失败，当做key；如果可以被调用，调用它。123456789def _do_dots(self, value, *dots): for dot in dots: try: value = getattr(value, dot) except AttributeError: value = value[dot] if callable(value): value = value() return value 注意到每次调用self._render_function方法的时候，我们都传进去一个函数用来执行点表达式。但是很多时候我们传进去的函数都一样，我们还可以把这部分代码变成编译模板的一部分。当然，这是后面要讨论的东西了。 后记到此为止，我们的简单模板引擎就已经完工了。如果有兴趣的话你还可以为这个模板添加如下功能。 模板继承与包含 自定义标签 自动转义 带参数的过滤器 更加复杂的条件语句，如else和elif 多个循环嵌套 空格控制]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stardust]]></title>
    <url>%2F2016%2F06%2F21%2F158%2F</url>
    <content type="text"><![CDATA[去年冬天的最后一天65岁的Natalie Cole因病离世。 每逢冬天听起她跟她父亲Nat King Cole“合唱”的《When I Fall In Love》，心里总会泛起一股温暖。1965年，在Natalie Cole 9岁的时候，他父亲Nat King Cole因肺癌去世。31年后的1996年，Natalie Cole跟她的父亲的“合唱”第一次出现在这张唱片中。当然，这是通过音频技术将她父亲1956年的一张唱片的声音提取出来与她形成“合唱”的效果。我不知道相隔31年，跟自己的父亲合唱是一种什么样的感受。但我每次听这首歌的时候，总有一种时空交错的感觉，仿佛虽然时间会流逝，但总有一些东西会永远不变，是他们的歌声？还是他们歌声中的爱？ When I fall in love it will be forever or I I never fall in love，In a restless world like this isLove is ended before it begunAnd too many moonlight kissesSeem to cool in the warmth of the sunWhen I give my heart，it will be completely or I never give my heartAnd the moment I can feel that you feel that way toois when I fall in love with youwhen I fall in loveAnd the moment I can feel that you feel that way toois when I fall in love with you]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>90s</tag>
        <tag>Vocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nothing's Gonna Change]]></title>
    <url>%2F2016%2F06%2F17%2F145%2F</url>
    <content type="text"><![CDATA[一般人叫我推荐爵士的时候，我会推荐Simone Kopmajer的这张专辑。Simone Kopmajer这张专辑里收录的都是经典的欧美流行歌曲。经过重新编曲后，这些耳熟能详的欧美流行歌曲居然真的有点“爵士味”起来。全张专辑配器简单精致，只用钢琴，贝斯，鼓，和少许的萨克斯，让人平静且舒服。《Nothing’s gonna change my love for you》这既是专辑名字，也是一首歌的名字，是经典爱情片《廊桥遗梦》主题曲。这首歌演唱版本众多（可能大家听过最多的版本是方大同翻唱的版本了），原唱是黑人爵士乐手George Benson。Simone Kopmajer演唱的这首歌，全曲仅有一架钢琴作伴奏，没有花俏的和弦，简单平和但触动人心。 来自奥地利的Simone Kopmajer, 于1981年出生与音乐世家，双亲都是音乐老师，父亲还是音乐学校的校长，因此Simone八岁就开始接受钢琴训练，十二岁就开始在父亲领导的大乐团中担任歌手。 这张专辑的发行公司，是泰国一家小爵士唱片公司Hitman Jazz。]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Jazz</tag>
        <tag>Pop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于WP Slimstat Analytics插件拖慢网站解析]]></title>
    <url>%2F2016%2F06%2F17%2F138%2F</url>
    <content type="text"><![CDATA[前几天网站速度很慢，开瀑布图发现时间都花在等在php解析html上。后来分析错误，发现问题出在WP Slimstat Analytics上面。WP Slimstat Analytics是一款功能强大的流量分析软件，可是对网站解析的速度的拖慢也很“强大” 使用WP Slimstat Analytics之前 使用WP Slimstat Analytics之后 居然达到惊人的2秒多。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IIS显示404找不到该文件错误解决方法]]></title>
    <url>%2F2016%2F06%2F17%2F136%2F</url>
    <content type="text"><![CDATA[今天测试的时候发现服务器上一个后缀名为.woff2的文件出现404 Not Found。确认路径，文件名，后缀名无误后还是依然404。这有点吊诡。后来查资料发现，IIS只能识别MIME 中注册过的文件类型，所以如果需要识别自己定义的某些类型请自行添加到MIME中。泪。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Just One Night]]></title>
    <url>%2F2016%2F06%2F13%2F131%2F</url>
    <content type="text"><![CDATA[1980年，Eric Clapton在日本东京Budokan Theatre举办了一场个人演出。《Just One Night》这张专辑记录当晚蓝调之夜的盛况。Eric Clapton在演出中演唱了很多经典的作品，无论是Blues味十足《Double Trouble》亦或是脍炙人口的《Wonderful Tonight》。个人很喜欢这个Live版的《Double Trouble》，Eric Clapton在70年代渐渐转向流行乐，可是这场演出可是货真价实的Night Of Blues。 Eric Clapton算是个人很喜欢的乐手之一。他1945年出生于英国小镇Ripley，从小就对Blues感兴趣的他15岁就开始学习吉他。1962年，年仅17岁的Eric Clapton从金斯顿艺术大学(Kingston College of Art)辍学，开始凭借自己的吉他演奏技术在英国当地的大小酒馆里演出养活自己。成名之后他回忆道，“当时只要能看到Bo Diddley与Chuck Berry一眼，我就高兴的昏了头。所以当我发现Muddy Walters与Robert Johnson时，对我的影响力都很大。” 早期的Eric Clapton玩的是比较传统的Blues或者Blues Rock。Eric Clapton的伟大不在于玩Blues玩得溜，而是在于他把Blues这种黑人音乐加入个人特色，进行扩展，使其大众化，也形成了个人风格。 如今71岁的Eric Clapton依然活跃在舞台上面，Eric Clapton除了坚持每隔几年出一张新唱片外，还每三年举办一次Crossroads演唱会，邀请朋友们一起上台Jam。 2013 Crossroads Guitar Festival（左下角为Eric Clapton）这里放一个Eric Clapton他父亲的彩蛋 寻找父亲虽然克莱普顿的祖父母将他身世的真相全部告诉他，然而他父亲的确切身份在很多年后还是一个谜。克莱普顿只知道他父亲叫做爱德华·弗赖尔，没有其它更多的信息。这是克莱普顿焦虑不安的源泉，在他1988年的作品“父亲的眼睛”（My Father’s Eyes）中他写道： “我是如何来到世间？什么时候我所有的愿望可以实现？…当我看到我父亲的眼睛。”（How did I get here? When will all my hopes arrive?…When I look in my father’s eyes.） 一个多伦多的叫麦克尔的旅行者，开始着手揭开谜团。他调查了加拿大军队的服役档案，并寻找所有名字为爱德华·弗赖尔的人，终于找到了真相。他父亲全名为爱德华·瓦特·弗赖尔，于1920年3月21日在蒙特利尔出生，于1985年5月15日在北约克逝世。弗赖尔是一个音乐家（钢琴和萨克斯），他终生流浪，几度结婚，并育有几个孩子。显而易见，他从来不知道自己是埃里克·克莱普顿的父亲。]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>80s</tag>
        <tag>Blues</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress 中文tab出现404的解决办法]]></title>
    <url>%2F2016%2F06%2F11%2F116%2F</url>
    <content type="text"><![CDATA[打开wordpress的wp-includes目录下class-wp.php文件123456$pathinfo = isset( $_SERVER[&apos;PATH_INFO&apos;] ) ? $_SERVER[&apos;PATH_INFO&apos;] : &apos;&apos;;修改为：$pathinfo = isset( $_SERVER[&apos;PATH_INFO&apos;] ) ? mb_convert_encoding($_SERVER[&apos;PATH_INFO&apos;],&apos;utf-8&apos;, &apos;GBK&apos;) : &apos;&apos;;list( $req_uri ) = explode( &apos;?&apos;, $_SERVER[&apos;REQUEST_URI&apos;] );修改为：list( $req_uri ) = explode( &apos;?&apos;, mb_convert_encoding($_SERVER[&apos;REQUEST_URI&apos;], &apos;utf-8&apos;,&apos;GBK&apos;) ); 其实WP主要原因是WP存储在DB中的数据编码是UTF-8，而Windows系统默认的编码是GBK，才会导致问题的出现。修改之后，中文连接在WP后台显示不正常，因为WP后台默认UTF-8编码。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下使用vsftpd搭建ftp]]></title>
    <url>%2F2016%2F06%2F11%2F109%2F</url>
    <content type="text"><![CDATA[查看是否安装vsftp123rpm -qa | grep vsftpd# 若未安装，安装yum -y install vsftpd 启动vsftpd服务1service vsftpd start 若无法启动，查看21端口是否被其他进程占用。若被占用，杀掉。1netstat -ntulp |grep 21 kill PID号 配置vsftpd查看vsftpd位置12 # whereis vsftpdvsftpd: /usr/sbin/vsftpd /etc/vsftpd /usr/share/man/man8/vsftpd.8.gz 默认配置文件: /etc/vsftpd.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129# 下面是配置的选项及说明 ######### 核心设置 ########### # 允许本地用户登录local_enable=YES # 本地用户的写权限write_enable=YES # 使用FTP的本地文件权限,默认为077# 一般设置为022local_umask=022 # 切换目录时# 是否显示目录下.message的内容dirmessage_enable=YESdirlist_enable = NO #验证方式#pam_service_name=vsftpd # 启用FTP数据端口的数据连接connect_from_port_20=YES # 以独立的FTP服务运行listen=yes # 修改连接端口#listen_port=2121 ######### 匿名登录设置 ########### # 允许匿名登录anonymous_enable=NO # 如果允许匿名登录# 是否开启匿名上传权限#anon_upload_enable=YES # 如果允许匿名登录# 是否允许匿名建立文件夹并在文件夹内上传文件#anon_mkdir_write_enable=YES # 如果允许匿名登录# 匿名帐号可以有删除的权限#anon_other_write_enable=yes # 如果允许匿名登录# 匿名的下载权限# 匿名为Other,可设置目录/文件属性控制#anon_world_readable_only=no # 如果允许匿名登录# 限制匿名用户传输速率,单位bite#anon_max_rate=30000 ######### 用户限制设置 ############### 限制登录 # 用userlist来限制用户访问#userlist_enable=yes # 名单中的人不允许访问#userlist_deny=no # 限制名单文件放置的路径#userlist_file=/etc/vsftpd/userlist_deny.chroot #### 限制目录 # 限制所有用户都在家目录#chroot_local_user=yes# 调用限制在家目录的用户名单chroot_list_enable=YES# 限制在家目录的用户名单所在路径chroot_list_file=/etc/vsftpd/chroot_list ######### 日志设置 ########### # 日志文件路径设置xferlog_file=/var/log/vsftpd.log # 激活上传/下载的日志xferlog_enable=YES # 使用标准的日志格式#xferlog_std_format=YES######### 安全设置 ########### # 用户空闲超时,单位秒#idle_session_timeout=600 # 数据连接空闲超时,单位秒#data_connection_timeout=120 # 将客户端空闲1分钟后断开#accept_timeout=60 # 中断1分钟后重新连接#connect_timeout=60 # 本地用户传输速率,单位bite#local_max_rate=50000 # FTP的最大连接数#max_clients=200 # 每IP的最大连接数#max_per_ip=5######### 被动模式设置 ############ 是否开户被动模式pasv_enable=yes # 被动模式最小端口pasv_min_port=5000 # 被动模式最大端口pasv_max_port=6000######### 其他设置 ########### # 欢迎信息ftpd_banner=Welcome to Ftp Server! 添加ftp防火墙规则123/sbin/iptables -I INPUT -p tcp --dport 21 -j ACCEPT/etc/rc.d/init.d/iptables save/etc/init.d/iptables restart 添加用户1useradd -d /home/ftp -s /sbin/nologin ftpuser PS不能用root用户登录，因为/etc/vsftpd/ftpusers ，/etc/vsftpd/user_list 两个列表中有root的名字，如需要用root的名字登录，请注释掉。（一般不建议这样做因为vsftpd密码是以明文方式传输的）]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS服务器图形化界面安装及XAMPP部署]]></title>
    <url>%2F2016%2F06%2F11%2F107%2F</url>
    <content type="text"><![CDATA[使用PuTTY远程连接到终端到 官网 下载PuTTY，打开Putty，并输入主机名或IP，点击Open。之后会切换到另一个窗口，显示提示login as:，这时输入用户名（如管理员用户名root),按下回车键出现输入密码提示，直接键入密码按下回车键就登录成功了。 CentOS6.5安装vncserver实现图形化访问安装gnome图形化桌面123#yum groupinstall -y &quot;X Window System&quot;#yum groupinstall -y &quot;Desktop&quot;#yum groupinstall -y &quot;Chinese Support&quot; 安装vncserver并配置安装vncserver1#yum install -y tigervnc-server 配置vncserver配置为开机自启动1#chkconfig --level 345 vncserver on 配置vnc密码12345678910[root@sunth ~]# vncserverYou will require a password to access your desktops.Password:Verify:xauth: creating new authority file /root/.Xauthorityxauth: (stdin):1: bad display name &quot;sunth.localdomain:1&quot; in &quot;add&quot; commandNew &apos;sunth.localdomain:1 (root)&apos; desktop is sunth.localdomain:1Creating default startup script /root/.vnc/xstartupStarting applications specified in /root/.vnc/xstartupLog file is /root/.vnc/sunth.localdomain:1.log 配置为使用gnome桌面修改 /root/.vnc/xstartup文件，把最后的 twm &amp; 删掉 加上 gnome-session &amp;。12345678910111213141516171819202122232425262728#!/bin/sh[ -r /etc/sysconfig/i18n ] &amp;&amp; . /etc/sysconfig/i18nexport LANGexport SYSFONTvncconfig -iconic &amp;unset SESSION_MANAGERunset DBUS_SESSION_BUS_ADDRESSOS=`uname -s`if [ $OS = 'Linux' ]; then case "$WINDOWMANAGER" in *gnome*) if [ -e /etc/SuSE-release ]; then PATH=$PATH:/opt/gnome/bin export PATH fi ;; esacfiif [ -x /etc/X11/xinit/xinitrc ]; then exec /etc/X11/xinit/xinitrcfiif [ -f /etc/X11/xinit/xinitrc ]; then exec sh /etc/X11/xinit/xinitrcfi[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresourcesxsetroot -solid greyxterm -geometry 80x24+10+10 -ls -title "$VNCDESKTOP Desktop" &amp;gnome-session &amp; 配置vncserver启动后监听端口和环境参数修改/etc/sysconfig/vncservers 文件添加以下内容12VNCSERVERS=&quot;1:root&quot;VNCSERVERARGS[1]=&quot;-geometry 1200x800&quot; 重启vncserver服务1#service vncserver restart 允许root访问图形界面和生成新的machine-id12#sed -i &apos;s/.*!= root.*/#&amp;/&apos; /etc/pam.d/gdm#dbus-uuidgen &gt;/var/lib/dbus/machine-id 关闭selinux和NetworkManager服务检查selinux服务并关闭1#vi /etc/selinux/config 确认里面的SELINUX字段的值是disabled，如果不是则改为disabled。 关闭NetworkManager服务1#chkconfig --del NetworkManager 测试登录：在官网可以下载客户端VNC ViewerVNC Server写上服务器的IP+编号（第二步，第四小步VNCSERVERS后面的数字） 部署安装XAMPP准备工作12yum updateyum remove httpd* 升级系统，然后清理已有的环境以免出现安装冲突。 下载XAMPP在 sourceforge 寻找合适的版本。下载。12cd /tmpwget http://downloads.sourceforge.net/project/xampp/XAMPP%20Linux/1.8.3/xampp-linux-x64-1.8.3-4-installer.run 提权，安装12chmod 755 xampp-linux*./xampp-linux* 安装完毕，启动XAMPP1/opt/lampp/lampp start 设置XAMPP打开/opt/lampp/etc/httpd.conf文件，按需设置 P.S yum -y install firefox，使用firefox而不使用chrome是因为chrome用root开不了。 可以改一下putty的配色，原配色好难看。附连接]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Serendipity Street]]></title>
    <url>%2F2016%2F06%2F10%2F99%2F</url>
    <content type="text"><![CDATA[第一次听Chantal Chamberland的歌声时就被她沙哑沧桑的“摇滚腔”所吸引。一张爵士专辑，用如此“摇滚味”的嗓音来演绎，确实特别，也确实好听。年轻时演唱摇滚乐的Chantal Chamberland。在2002年推出第一张爵士老歌翻唱专辑《This Is Our Time》。这张《Serendipity Street》是Chantal Chamberland的第二张专辑，标准的爵士三重奏，再加上Chantal Chamberland自己的吉他伴奏，配器简单但是感觉十足。顺便说一句，专辑中用的是Acoustic Bass，但录出来的效果却是电Bass的感觉。 专辑中大多数都是《Cry Me A River》，《God Bless the Child》之类的老歌，老时光的味道，甚至连Chantal Chamberland自己写的两首原创《It’s You》与《Across the Room》都有一种Old Times的感觉。《 Les Feuilles Mortes 》一曲更是好听得让人感动，Chantal Chamberland独特的沙哑嗓音演绎着这首六十年前的法国香颂，让人仿佛回到了老时光里的巴黎。当然大家更加熟悉这首歌的英文版——《Autumn Leaves》。 Les feuilles mortes（意为 “the dead leaves”，枯叶）是作曲家Joseph Kosma（1905-1969）在1945年于法国创作的香颂。1946年，法国歌手,影星Yves Montand（1921.10.13-1991.11.09 ）在影片” LesPortes de la Nuit《夜之门》”中，演唱了这首歌。但这部电影在当时并不成功，虽然小有知名度的Yves Montand当时已经和Edith Piaf 在一起，但是Montand也没有因为这部电影以及这首主题曲而受人注目。直到1948年，已经走红的Yves Montand 在友人引荐下认识了诗人Jacques Prévert。Yves Montand 非常赏识Jacques的才华，便邀请 Jacques Prévert重新填词，Yves Montand 再次演唱，终于使这首经典流芳百世。1950年，美国音乐人John Herndon Mercer（1909-1976）将”Les Feuilles Mortes”改写成英文版”Autumn Leaves”。值得一提的是，这首歌的录音很棒。我记得貌似刘汉盛榜单也有这张专辑。这张CD的音质非常好，如果您没有感觉纯净的美感，第一个就错了。第二个吸引人的地方是低频，此处的低频软Q又有弹性，但量感不会太多，就好像我们吃了肥瘦分布均匀的雪花肥牛一般，或像是鲔鱼大肚肉，既带着诱人的油花，入口却是爽口的。这么迷人的低频哪里来的呢?是恰恰好的脚踩大鼓噗噗声与Bass的巧妙混合。第三个吸引人的地方当然是女歌手Chantal的嗓音。她的嗓音宽松不紧绷，声音线条饱满庞大，壮硕还带着磁性，很是迷人。假若您听到的是紧绷不够温暖、不够柔软、不够壮硕的嗓音，那就错了。]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Jazz</tag>
        <tag>Swing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于WordPress上传图片权限问题]]></title>
    <url>%2F2016%2F06%2F10%2F95%2F</url>
    <content type="text"><![CDATA[今天WordPress不知出现什么毛病，上传的图片都没有访问的权限。跑去服务器看下刚上传的文件。妈蛋居然没有权限。 奇怪的是，自动生成的缩略图居然有权限。 Uploads文件夹我是赋予写入跟修改权限的，图片可以上传，可是上传上去的图片IIS没有读取的权限。这是什么鬼。注意到，新上传的图片虽然IIS_IUSRS没有读取权限。但是just_somethings这个组有很高的权限。just_somethings这个是什么鬼？这要涉及到“应用程序池标识”了。查看巨硬的文档，找到如下信息： 应用程序池的标识是运行应用程序池的工作进程所使用的服务帐户名称。 默认情况下，应用程序池以 Network Service 用户帐户运行，该帐户拥有低级别的用户权限。 您可以将应用程序池配置为以 Windows Server® 2008 操作系统中的内置用户帐户之一运行。 例如，您可以指定 Local System 用户帐户，此帐户与 Network Service 或 Local Service 内置用户帐户相比，具有更高级别的用户权限。 但请注意，以具有高级别用户权限的帐户运行应用程序池存在严重的安全风险。这么说来，just_somethings这个组就是“运行应用程序池的工作进程所使用的服务帐户名称”OK解决方法来了，到Uploads目录下，把匿名身份验证改为“应用程序池标识”。搞定]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈设计模式——抽象工厂模式]]></title>
    <url>%2F2016%2F06%2F10%2F80%2F</url>
    <content type="text"><![CDATA[情景从前，有一家叫做骚尼大法（简称大法）的公司，有富土康一个生产企业。富土康开了两条生产线，手机生产线跟电视生产线。大法跟富土康这两个好基友一直相处得很好，直到某一天来了个大米。大米跟大法有样学样生产其手机来，那么现在富土康的手机生产线跟电视生产线就生产大米跟大法的产品了。我们看图。 UML类图 大米(DaMi)跟大法(DaFa)是两个抽象产品，而大米手机(DaMi_Phone)大米电视(DaMi_TV)，大法手机(DaFA_Phone)大法电视(DaFA_TV)是对像个抽象产品的具体分类实现。富土康(Futukang)是抽象工厂接口，它里面包含所有产品创建的抽象方法。Futukang_Phone，Futukang_TV就是具体的工厂。通常是运行时创建一个具体工厂(ConcreteFactory)，这个具体工厂再创建特定实现的产品对象(ConcreteProduct)。为创建不同的产品对象，客户端对应不同的具体工厂。 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;using namespace std;class DaFa&#123;public: virtual void Show() = 0;&#125;;class DaFa_Phone : public DaFa&#123;public: void Show() &#123; cout&lt;&lt; "I'm DaFa_Phone"&lt;&lt;endl; &#125;&#125;;class DaFa_TV : public DaFa&#123;public: void Show() &#123; cout&lt;&lt; "I'm DaFa_TV"&lt;&lt;endl; &#125;&#125;;class DaMi&#123;public: virtual void Show() = 0;&#125;;class DaMi_Phone : public DaMi&#123;public: void Show() &#123; cout&lt;&lt; "I'm DaMi_Phone"&lt;&lt;endl; &#125;&#125;;class DaMi_TV : public DaMi&#123;public: void Show() &#123; cout&lt;&lt; "I'm DaMi_TV"&lt;&lt;endl; &#125;&#125;;class Futukang&#123;public: virtual DaMi *CreateDaMi() = 0; virtual DaFa *CreateDaFa() = 0;&#125;;class Futukang_Phone : public Futukang&#123;public: DaMi *CreateDaMi() &#123; return new DaMi_Phone (); &#125; DaFa *CreateDaFa() &#123; return new DaFa_Phone (); &#125;&#125;;class Futukang_TV : public Futukang&#123;public: DaMi *CreateDaMi() &#123; return new DaMi_TV (); &#125; DaFa *CreateDaFa() &#123; return new DaFa_TV (); &#125;&#125;;int main(int argc , char *argv [])&#123; Futukang *factory_phone = new Futukang_Phone (); DaMi *dami_phone = factory_phone-&gt;CreateDaMi(); DaFa *dafa_phone = factory_phone-&gt;CreateDaFa(); dami_phone-&gt;Show(); dafa_phone-&gt;Show(); Futukang *factory_tv = new Futukang_TV (); DaMi *dami_tv = factory_tv-&gt;CreateDaMi(); DaFa *dafa_tv = factory_tv-&gt;CreateDaFa(); dami_tv-&gt;Show(); dafa_tv-&gt;Show(); if (factory_phone != NULL) &#123; delete factory_phone; factory_phone = NULL; &#125; if (factory_tv != NULL) &#123; delete factory_tv; factory_tv = NULL; &#125; if (dami_phone != NULL) &#123; delete dami_phone; dami_phone = NULL; &#125; if (dafa_phone != NULL) &#123; delete dafa_phone; dafa_phone = NULL; &#125; if (dami_tv != NULL) &#123; delete dami_tv; dami_tv = NULL; &#125; if (dafa_tv != NULL) &#123; delete dafa_tv; dafa_tv = NULL; &#125; return 0;&#125; 优点： 跟工厂方法模式相比，少创建了对象。容易维护管理。 让具体的创建实例的过程与客户端分离，产品的具体类名也被具体工厂的实现分离。 适用于产品种类结构多的场合，主要用于创建一组（有多个种类）相关的产品，为它们提供创建的接口 缺点： 新增一个Product的时候将会变得异常麻烦 情景2：大米跟大法在富士康相处得很好，可是某一天来了个诺基鸭。除了要增加个诺基鸭，诺基鸭手机，诺基鸭电视三个类之外。还要弄个诺基鸭砖头。还要把富土康，富土康手机，富土康电视都修改一遍。太麻烦了，大米跟大法两个不干了，决定重新修改。 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;iostream&gt;using namespace std;class DaFa&#123;public: virtual void Show() = 0;&#125;;class DaFa_Phone : public DaFa&#123;public: void Show() &#123; cout&lt;&lt; "I'm DaFa_Phone"&lt;&lt;endl; &#125;&#125;;class DaFa_TV : public DaFa&#123;public: void Show() &#123; cout&lt;&lt; "I'm DaFa_TV"&lt;&lt;endl; &#125;&#125;;class DaMi&#123;public: virtual void Show() = 0;&#125;;class DaMi_Phone : public DaMi&#123;public: void Show() &#123; cout&lt;&lt; "I'm DaMi_Phone"&lt;&lt;endl; &#125;&#125;;class DaMi_TV : public DaMi&#123;public: void Show() &#123; cout&lt;&lt; "I'm DaMi_TV"&lt;&lt;endl; &#125;&#125;;class Nuojiya&#123;public: virtual void Show() = 0;&#125;;class Nuojiya_Phone : public Nuojiya&#123;public: void Show() &#123; cout&lt;&lt; "I'm Nuojiya_Phone"&lt;&lt;endl; &#125;&#125;;class Nuojiya_TV : public Nuojiya&#123;public: void Show() &#123; cout&lt;&lt; "I'm Nuojiya_TV"&lt;&lt;endl; &#125;&#125;;class Nuojiya_Brick:public Nuojiya&#123;public: void Show() &#123; cout&lt;&lt; "I'm Nuojiya_Brick"&lt;&lt;endl; &#125;&#125;;class Futukang&#123;private: char item;public: Futukang(char _item)&#123;item=_item;&#125; DaFa* CreateDaFa()&#123; DaFa* result=NULL; switch(item)&#123; case 'P': result=new DaFa_Phone; break; case 'T': result=new DaFa_TV; break; &#125; return result; &#125; DaMi* CreateDaMi()&#123; DaMi* result=NULL; switch(item)&#123; case 'P': result=new DaMi_Phone; break; case 'T': result=new DaMi_TV; break; &#125; return result; &#125; Nuojiya* CreateNuojiya()&#123; Nuojiya* result=NULL; switch(item)&#123; case 'P': result=new Nuojiya_Phone; break; case 'T': result=new Nuojiya_TV; break; case'B': result=new Nuojiya_Brick; break; &#125; return result; &#125;&#125;;int main(int argc , char *argv [])&#123; Futukang phone=Futukang('P'); Futukang tv=Futukang('T'); Futukang brick=Futukang('B'); DaFa* dafa_phone=phone.CreateDaFa(); DaFa* dafa_tv=tv.CreateDaFa(); DaMi* dami_phone=phone.CreateDaMi(); DaMi* dami_tv=tv.CreateDaMi(); Nuojiya* nuojiya_phone=phone.CreateNuojiya(); Nuojiya* nuojiya_tv=tv.CreateNuojiya(); Nuojiya* nuojiya_brick=brick.CreateNuojiya(); dafa_phone-&gt;Show(); dafa_tv-&gt;Show(); dami_phone-&gt;Show(); dami_tv-&gt;Show(); nuojiya_phone-&gt;Show(); nuojiya_tv-&gt;Show(); nuojiya_brick-&gt;Show(); return 0;&#125; 去除Futukang_TV，Futukang_Phone，Futukang。取而代之的是Futukang这一个类，用一个简单工厂模式来实现。当然，在这以后，无论外界发生什么事情都不关大米跟大法两家的事了，就算新增一个“蓝翔”，富土康再新增一条“挖掘机”的流水线，都不关他们的事了。只需要在Futukang新增一个方法，然后再客户端作相应的修改就行。达到了解耦的目的。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈设计模式——建造者模式]]></title>
    <url>%2F2016%2F06%2F09%2F64%2F</url>
    <content type="text"><![CDATA[情景我们知道，电脑一般是由CPU，主板，内存，显卡，电源，硬盘几大零件注册。我们假设，这几大零件分为好中差三个等级。我们要用这些零件组装三台电脑，分别是服务器电脑，游戏电脑，普通办公电脑。 服务器电脑，我们要求CPU，主板，内存，电源，硬盘为‘好’，显卡为‘一般’。 游戏电脑，我们要求CPU，内存，显卡为‘好’。主板，电源，硬盘为‘一般’。 普通办公电脑，我们要求CPU，内存，硬盘，电源为‘一般’。显卡为‘差’。 UML类图 PcBuilder，你可以把他理解成为戴尔，联想等电脑生产商。它是一个建造电脑的抽象类，是为创建Pc对象的各个部件指定的抽象接口。 ServerBuilder等三个ConcreteBuilder，他们是具体的建造者。实现PcBuilder接口，构造和装配各个部件。 Pc,当然是指具体的电脑了。 PcDirector，指挥者，是构建一个使用PcBuild接口的对象。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;typedef enum HardwareLEVELenum&#123; DefaultLevel, Bad, Normal, Good&#125;HardwareLEVEL;class PC&#123;public: void SetPC(string level)&#123;_level=level;&#125; void SetCPU(HardwareLEVEL CPU)&#123; _CPU = CPU; &#125; void SetGPU(HardwareLEVEL GPU)&#123; _GPU = GPU; &#125; void SetMotherboard(HardwareLEVEL Motherboard)&#123; _Motherboard = Motherboard; &#125; void SetHarddisk(HardwareLEVEL Harddisk)&#123; _Harddisk = Harddisk; &#125; void SetRAM(HardwareLEVEL RAM)&#123; _RAM = RAM; &#125; void SetPower(HardwareLEVEL Power)&#123; _Power = Power; &#125; void ShowPC() &#123; cout&lt;&lt;"I'm a "&lt;&lt;_level&lt;&lt;endl; cout&lt;&lt;"HardWare Level(1~3)"&lt;&lt;endl; cout&lt;&lt;"CPU:"&lt;&lt;_CPU&lt;&lt;endl; cout&lt;&lt;"GPU:"&lt;&lt;_GPU&lt;&lt;endl; cout&lt;&lt;"Motherboard:"&lt;&lt;_Motherboard&lt;&lt;endl; cout&lt;&lt;"Harddisk:"&lt;&lt;_Harddisk&lt;&lt;endl; cout&lt;&lt;"RAM:"&lt;&lt;_RAM&lt;&lt;endl; cout&lt;&lt;"Power:"&lt;&lt;_Power&lt;&lt;endl; cout&lt;&lt;endl; &#125;private: string _level; HardwareLEVEL _CPU; HardwareLEVEL _GPU; HardwareLEVEL _Motherboard; HardwareLEVEL _Harddisk; HardwareLEVEL _RAM; HardwareLEVEL _Power;&#125;;class Builder&#123;public: virtual void BuildPC()&#123;&#125; virtual void BuildCPU()&#123;&#125; virtual void BuildGPU()&#123;&#125; virtual void BuildMotherboard()&#123;&#125; virtual void BuildHarddisk()&#123;&#125; virtual void BuildRAM()&#123;&#125; virtual void BuildPower()&#123;&#125; virtual PC *GetPC()&#123; return NULL; &#125;&#125;;class ServerPCBuilder : public Builder&#123;public: ServerPCBuilder()&#123; _ServerPC = new PC(); &#125; void BuildPC()&#123;_ServerPC-&gt;SetPC("ServerPC");&#125;; void BuildCPU()&#123; _ServerPC-&gt;SetCPU(Good); &#125; void BuildGPU()&#123; _ServerPC-&gt;SetGPU(Normal); &#125; void BuildMotherboard()&#123; _ServerPC-&gt;SetMotherboard(Good); &#125; void BuildHarddisk()&#123; _ServerPC-&gt;SetHarddisk(Good); &#125; void BuildRAM()&#123; _ServerPC-&gt;SetRAM(Good); &#125; void BuildPower()&#123; _ServerPC-&gt;SetPower(Good); &#125; PC *GetPC()&#123; return _ServerPC; &#125;private: PC *_ServerPC;&#125;;class GamePCBuilder : public Builder&#123;public: GamePCBuilder()&#123; _GamerPC = new PC(); &#125; void BuildPC()&#123;_GamerPC-&gt;SetPC("GamePC");&#125;; void BuildCPU()&#123; _GamerPC-&gt;SetCPU(Good); &#125; void BuildGPU()&#123; _GamerPC-&gt;SetGPU(Good); &#125; void BuildMotherboard()&#123; _GamerPC-&gt;SetMotherboard(Normal); &#125; void BuildHarddisk()&#123; _GamerPC-&gt;SetHarddisk(Normal); &#125; void BuildRAM()&#123; _GamerPC-&gt;SetRAM(Good); &#125; void BuildPower()&#123; _GamerPC-&gt;SetPower(Normal); &#125; PC *GetPC()&#123; return _GamerPC; &#125;private: PC *_GamerPC;&#125;;class OfficePCBuilder : public Builder&#123;public: OfficePCBuilder()&#123; _OfficePC = new PC(); &#125; void BuildPC()&#123;_OfficePC-&gt;SetPC("OfficePC");&#125;; void BuildCPU()&#123; _OfficePC-&gt;SetCPU(Normal); &#125; void BuildGPU()&#123; _OfficePC-&gt;SetGPU(Bad); &#125; void BuildMotherboard()&#123; _OfficePC-&gt;SetMotherboard(Normal); &#125; void BuildHarddisk()&#123; _OfficePC-&gt;SetHarddisk(Normal); &#125; void BuildRAM()&#123; _OfficePC-&gt;SetRAM(Normal); &#125; void BuildPower()&#123; _OfficePC-&gt;SetPower(Normal); &#125; PC *GetPC()&#123; return _OfficePC; &#125;private: PC *_OfficePC;&#125;;class Director&#123;public: Director(Builder *builder) &#123; m_Builder = builder; &#125; void CreatePC();private: Builder *m_Builder;&#125;;void Director::CreatePC()&#123; m_Builder-&gt;BuildPC(); m_Builder-&gt;BuildCPU(); m_Builder-&gt;BuildGPU(); m_Builder-&gt;BuildMotherboard(); m_Builder-&gt;BuildHarddisk(); m_Builder-&gt;BuildMotherboard(); m_Builder-&gt;BuildHarddisk(); m_Builder-&gt;BuildRAM(); m_Builder-&gt;BuildPower();&#125;int main(int argc, char *argv[])&#123; Builder *builderPC1 = new ServerPCBuilder(); Director directorPC1(builderPC1); directorPC1.CreatePC(); PC *PC1 = builderPC1-&gt;GetPC(); Builder *builderPC2 = new GamePCBuilder(); Director directorPC2(builderPC2); directorPC2.CreatePC(); PC *PC2 = builderPC2-&gt;GetPC(); Builder *builderPC3 = new OfficePCBuilder(); Director directorPC3(builderPC3); directorPC3.CreatePC(); PC *PC3 = builderPC3-&gt;GetPC(); if (PC1 == NULL) return 0; if (PC2 == NULL) return 0; if (PC3 == NULL) return 0; PC1-&gt;ShowPC(); PC2-&gt;ShowPC(); PC3-&gt;ShowPC(); delete PC1; PC1 = NULL; delete builderPC1; builderPC1 = NULL; delete PC2; PC2 = NULL; delete builderPC2; builderPC2 = NULL; delete PC3; PC1 = NULL; delete builderPC3; builderPC3 = NULL; return 0;&#125;; 建造者模式建造者模式(Builder)，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 就上面那个例子，我们知道，一个复杂对象（电脑）的创建，通常是由许多子对象（硬件）所组成的。由于需求的不同，组成复杂对象（电脑）的子对象（硬件）也不同（例如上面例子的服务器电脑，游戏电脑，办公电脑）。但是，我们知道，无论需求怎么样变化，电脑还是由CPU等几大硬件组成的。建造者模式就提供了一种“封装机制”来将各个对象的变化隔离开，最终，组合成复杂对象的过程是不会变的。 使用建造者模式，用户只需指定需要建造的类型就可以得到他们，具体的建造的过程和细节就不需知道了。 优点 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者。若需要新增一个电脑产品，只需再定义一个具体的建造者就行了。 将建造代码与表示代码分离。 缺点 要求所创建的产品一般具有较多的共同点。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Breakfast On The Morning Tram]]></title>
    <url>%2F2016%2F06%2F09%2F59%2F</url>
    <content type="text"><![CDATA[列车上的早餐，薄煎饼，咖啡的气味似乎已经漂浮在空中。拉开窗帘，昨晚暴雨洗刷的天空似乎更明媚，阳光伴随Stacey Kent的歌声传进列车里。 Stacey Kent加入Blue Note公司的首张专辑，全片由她的萨克斯风手老公Jim Tomlinson担任制作和编曲，全片以吉他、键盘、贝斯、鼓和萨克斯风这样的小型五人组合搭配，清清淡淡的传统爵士伴奏。专辑中翻唱了Serge Gainsbourg的两首法语歌，这个精通英语 法语 意大利语的女人，当她唱起法国香颂时，我甚至不相信她来自纽约。首曲《Ice Hotel》一副早晨睁开朦胧睡眼醒来的感觉，似乎整首歌都是伴随着阳光跟咖啡的气息。翻唱Louis Armstrong的《What A Wonderful World》唱出了Stacey Kent个人的味道，听这首歌时你脑海里会浮现出旅行途中，列车外蓝天白云，绿树红玫，列车里婴儿的啼哭声，熙熙攘攘的人群。]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Jazz</tag>
        <tag>Bossa Nova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[South of the Border,West of the Sun]]></title>
    <url>%2F2016%2F06%2F08%2F44%2F</url>
    <content type="text"><![CDATA[村上春树在《爵士群像》一书中曾提到，他一直以为《South of The Border》这首歌是Nat King Cole所唱，并且以此为基础写了《国境之南，太阳之西》这本小说，后来才发现Nat King Cole根本没唱过这首歌。巧合的是，村上春树在1992出版了这本书，而这张专辑同年12月完成的专辑。 爵士乐早期的Swing乐风一直是村上春树最喜爱的类型，参与这张专辑演出的三位大师正是爵士Swing乐派的顶尖老将。钢琴手Claude Williamson乐风承传Bud Powell，五十年代崛起至今一直是West Coast Jazz的重要人物；贝斯手Andy Simpkins同样崛起於五十年代，曾任Sarah Vaughan巡迴演唱乐手，至今依然活跃与洛杉矶地区；鼓手Albert “Tootie” Heath更曾与John Coltrane、J.J. Johnson、Dexter Gordon、Herbie Hancock等爵士巨匠共事。由这三位老当益壮的乐手所共同架构的钢琴三重奏，当然流露出浓郁纯正的Swing韵味。 专辑中除了收录《Star Crossed Lovers》、《Pretendo》、《As Time Goes By》等多首耳熟能详的Jazz standard，开头曲《South of The Border》轻松愉快；终曲《West of The Sun》则是浪漫抒情。周日午后一杯手冲咖啡，一边听着Jazz一边看着村上春树的小说，不失为一种极好的休闲方式。 Venus制作人原哲夫先生：“Venus爵士乐希望能够带给乐迷们如同坐在Jazz Club第一排中间座位听音乐那样的感动。因此，请大家在自己心爱的音响系统中聆听Venus，重现舞台的原貌。相信一定可以让您们享受到真正的Acoustic Jazz Sound！” 来自日本的Venus厂牌，成立于1992年，录制了为数众多的经典爵士名盘，其音乐层次丰富、充满渲染力，而能让听众如临现场的高水准录音品质也是Venus的一大特色，不少专辑都陆续推出了高音质HQCD版及黑胶版，旗下唱片更屡屡荣获日本专业爵士乐杂志Swing Journal金赏奖。原哲夫在Venus中投入了对爵士乐的热情，迄今，Venus已成为日本爵士乐界最受瞩目的厂牌之一。]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Jazz</tag>
        <tag>70s</tag>
        <tag>Swing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[忙乎个大半天，Blog终于成型了]]></title>
    <url>%2F2016%2F06%2F08%2F25%2F</url>
    <content type="text"><![CDATA[早上刚刚考完计算机网络，累死。不行，我还没吃饭，现在去吃个粽子。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[At Fillmore East]]></title>
    <url>%2F2016%2F06%2F08%2F16%2F</url>
    <content type="text"><![CDATA[《At Fillmore East》是美国乐队the Allman Brothers Band的一张现场专辑。这张1971年7月由Capricorn Records发行的专辑，记录了the Allman Brothers Band在纽约Fillmore East摇滚俱乐部1971年3月的三夜的演出。可惜三个月后滑棒吉他Duane Allman因车祸去世，次年贝斯Berry Oakley也因车祸去世。自1974年起乐队内部出现了裂痕，Gregg Allman也沉溺在毒品的刺激中。之后，乐队虽然推出了数张专辑，但已不复昔日的盛况，最后与1976年解散。 Duane Allman，于1971年因车祸去世，死时仅24，滚石“Top100 Guitarist”排名第二，仅次于Jimmy，使用滑棒吉他Slide Guitar风靡摇滚界，被称为蓝调滑棒吉他之父。他的弟弟Gregg Allman，毒瘾很重，虽然继承了哥哥的摇滚理想，但之后音乐已经无法和早期相比。 专辑封面从左至右：黑人鼓手Jai Johanny Johanson，滑棒吉他Duane Allman（71年死于车祸），键盘Gregg Allman，主琴Dickey Betts，贝斯Berry Oakley（72年死于车祸），鼓手Butch Trucks 。 这张专辑在滚石500中排名第49。 我有幸听到的是MSLP重制的版本。第一轨的《Statesboro Blues》的滑棒吉他就让我立刻爱上这张专辑，Duane Allman的滑棒实在6到不行。滑棒吉他，口琴，一股浓浓的南方布鲁斯味。《Whipping Post》（邮差包？）这首Long Jam更是值了回票价，Duane 跟他弟Jam到热血沸腾。 不过MSLP重制的版本貌似只收录了部分歌曲，如果要入，推荐入双CD收藏版。 下面贴下网上一篇乐评，个人觉得很有感觉。 从上个世纪末到如今，在美国人的脑子里有三种美国人：大城市里的美国人，高节奏、刺激、五光十色，同时，腐败堕落。还有小镇上的美国人，热诚、率直、田园风味，而从无变化。再就是住在郊外小区的美国人，乾净，整齐，井井有条，诸事方便，也就是说，索然无味。美国人总是怀着伤感，住在大城市里和郊外小区的中产阶级们，总在梦想着回到小镇上。自然，除了旅游度假，他们从来没有真的回去。但是，人们暗怀着一种虚幻的小镇心? 在地域文化思维里，他们想过另外一种美国人吗?这种人不住大城市，也不住郊外小区，或者小镇。这些人住在中等城市里。所谓的中等城市，既不像纽约，也不像各州首府类的大型城市，更不是乡村。可以说，住在这种中等城市里的人在美国文化中没有自己的地位。于是，这些中等城市的居民不知道自己算哪种人。中等城市里的人有着无名的寂寞，难以言状的焦躁，承受着某种类似精神分裂的状态。而这种美国中等城市的精神分裂症，有一个我喜欢的乐队，Allman Brothers，也许给了最好的表达。Allman Brothers，这个乐队60年代末成立，来自乔治亚南方的Macon城。Macon这个城市，好象沼泽农田中的石头古迹玛雅，位于乔治亚中部平川，有一条浑浊的河流。这个城市大约7万5千人口，有个大学。对于小镇来说，Macon太大，对于大城市来说，Macon太小。20年前这里的主要工厂倒闭了，城市再也没能从倒闭中恢复元气，于是城市无整体规划，因为太穷无以发展出郊外中产阶级小区。Macon是个什么呢?这就是一个问题。而这个问题，Allman Brothers乐队从未回答。 Allman Brothers，是以主要乐手兄弟的姓命名的乐队，好象巧合了”人皆兄弟”的意思。这个乐队的成员都长自Macon，他们听英国摇滚，披头士，所以，乐队开始时候打扮的像摇滚乐手，音乐风格和60年代末郊外小区青少年中流行的摇滚相似，这群音乐天才吸引了无数郊外小区的追星族。仅仅几年的功夫，这支乐队就登上座落纽约的，美国最权威的摇滚俱乐部舞台，Fillmore East。在Fillmore East的一次表演中，乐队的现场录音成为美国音乐的传奇，震翻了世界流行乐坛：Allman Brothers，这帮子由篮领工人子弟组成的南方乐队，这群白人，在舞台上表演的是Blues，篮调，而不是摇滚。60年代末的时候，对于居住安稳的郊外小区中产阶级的耳朵来说，蓝调是遥远到全够不着边的声音。蓝调是乡间黑人的音乐。是贫困的音乐。是痛苦的音乐。蓝调的旋律简单、激烈，演奏时伴随阵颤性的吉他，和一对声音尖利的歌手，所谓”召唤和回应”，是非洲的歌唱方式。放大想象一下Allman Brothers演唱舞台的背景，当时美国正发生黑人和蓝领白人之间的种族骚乱，整个国家弄得高度分裂，而一群白人歌手纵情高唱蓝调!这一群Allman Brothers究竟属于什么人?音乐评论家们问。白人青年在唱黑人蓝调的什么?接下来的几年，Allman Brothers没有回答这个问题，却提出更多问题。70年代初期，Allman Brothers录制了一张唱片，在音乐中加入了爵士乐的成分。爵士乐也是黑人音乐，不过，是冷感的，经常是很理性的，演奏包括大量的、复杂的乐器组合以及少数的人声。这个时期的一般流行歌曲，平均长度不过两三分钟，而Allman Brothers制作的几首歌长达10到20分钟。还有，爵士音乐并非是乡下黑人的音乐，而是挤在大城市公寓里的黑人音乐。 Allman Brothers究竟属于什么人?评论家们再次发问。然而，Allman Brothers从来没有做临终忏悔的交代。乐队最后的唱片展现了美国乡村音乐风味。这种音乐正是美国梦怀的小镇居民们所爱。唱片展现了典型的乡村音乐特色，伴随摇铃般的优美回旋，间或微微的叹息。乡村音乐的主旋律表达被艰苦劳做和贫困折磨的妇女和家庭。发明乡村音乐的南方白人，好多人和唱蓝调的黑人穷乡亲的生活其实很相近，因此从蓝调里借了不少东西。而到了此时，?出了类：这是一个融合性的乐队。换句话说，他们拿来所能发现的各种音乐融合出自己。 的确。他们的确曾经如此这般。 在我到美国之前Allman Brothers就不存在了。车祸使两名乐手身亡，其中包括乐队的灵魂，Duane Allman，并且，像很多美国乐手，其他几个成员的艺术生涯毁于吸毒和酗酒。不过，我仍然可以倾听极富才华的音乐，我仍然可以来看这座中等城市，Macon。 你可以想见，这是一种怎样枯涩寂寞的地方。绝大多数的建筑陈旧，没有任何别致的风格，个别新楼显得和城市格格不入。是春天，是樱桃花盛开的时候，整条街，整条街的花，使城市非常美，有了身份。花季只有两个星期。最早录制Allman Brothers唱片的公司关着门，早些年就倒闭了。不过，我仍然可以到他们当年晚上录音之后吃饭的黑人餐馆里来坐一坐。 这是一个非常简陋的餐馆。门上有一块退色的可口可乐招牌。这里的食物，又辣，又油，口味很重，是南方黑人的盛餐：面包、炸鸡、炸okra，是一种手指头大小，类似瓠瓜的非洲小瓜，大罐子烤牛肉、煮罗卜、煮黑眼豆、辣兮兮的西红柿酱、炸玉米糕，用南方的甜冰茶通通送下肚肠。好象，天下穷人都爱用油炸，用大甜大辣的重口味，来加强，来崇拜得之不易的食物?这种黑人饭食叫”Soul food”，灵魂之餐，假定吃东西也是一种宗教经验?在这个简陋的小饭馆的一面墙上站满了Allman Brothers。是照片。凝结住永远年轻的乐队成员们，他们搂着小个子的黑人店主。 这个小餐馆没有名字。完全没有。只有那个退色的可口可乐招牌，对传奇性的乐队，在家乡做着缅怀的孤独标志。 当我走在这个城市的街上，不由不默想这支乐队的自我毁灭。就如这座中型的城市，这是怎样一种生与死之间的方位?这个地方叫Macon，在整个国家的文化里没有这个城市的位置，这个城市没有任何特征，难道，正是这种全无特征，驱使Allman Brothers创造了如此多样的旋律?难道，也正是这一点，驱使乐队集体自杀? Allman Brothers，同样没有回答我的问题。]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Blues</tag>
        <tag>70s</tag>
        <tag>Rock</tag>
      </tags>
  </entry>
</search>
